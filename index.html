<!DOCTYPE html>
<html lang="th">

<head>
    <meta charset="UTF-8">
    <title>‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏£‡∏ó‡πÑ‡∏ü‡∏ü‡πâ‡∏≤</title>
    <link rel="stylesheet" href="style.css">
    <link rel="icon" type="image/png" href="favicon.png"> 
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="./holiday_results/holiday_2022.js"></script>
    <script src="./holiday_results/holiday_2023.js"></script>
    <script src="./holiday_results/holiday_2024.js"></script>
    <script src="./holiday_results/holiday_2025.js"></script>
</head>

<body>
    <div class="container">
        <h1>‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏£‡∏ó‡πÑ‡∏ü‡∏ü‡πâ‡∏≤‡∏à‡∏≤‡∏Å‡πÑ‡∏ü‡∏•‡πå Excel</h1>

        <div id="dropArea" class="drop-area">
            <span class="icon">üìÑ</span>
            <p>‡∏•‡∏≤‡∏Å‡πÑ‡∏ü‡∏•‡πå Excel (.xlsx, .xls) ‡∏°‡∏≤‡∏ß‡∏≤‡∏á‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà</p>
            <p>‡∏´‡∏£‡∏∑‡∏≠‡∏Ñ‡∏•‡∏¥‡∏Å‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏ü‡∏•‡πå</p>
            <input type="file" id="excelFile" accept=".xlsx, .xls">
        </div>

        <div class="controls">
            <div class="control-group">
                <label for="monthYearSelector">‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÄ‡∏î‡∏∑‡∏≠‡∏ô:</label>
                <div class="select-wrapper">
                    <select id="monthYearSelector" onchange="updateDisplay()">
                    </select>
                </div>
            </div>

            <div class="control-group">
                <label for="arTypeSelector">‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó Portion:</label>
                <div class="select-wrapper">
                    <select id="arTypeSelector" onchange="updateDisplay()">
                        <option value="AR1">AR1</option>
                        <option value="AR6">AR6</option>
                        <option value="HA1">HA1</option>
                    </select>
                </div>
            </div>

            <div class="control-group">
                <label for="unitSelector">‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏´‡∏ô‡πà‡∏ß‡∏¢:</label>
                <div class="select-wrapper">
                    <select id="unitSelector" onchange="updateDisplay()">
                        <option value="kwh_kvarh">kWh, kVarh</option>
                        <option value="kw_kvar">kW, kVar</option>
                    </select>
                </div>
            </div>

            <div class="control-group">
                <label for="dataTypeSelector">Import/Export:</label>
                <div class="select-wrapper">
                    <select id="dataTypeSelector" onchange="updateDisplay()">
                        <option value="wh_import">Wh Import</option>
                        <option value="wh_export">Wh Export</option>
                    </select>
                </div>
            </div>

            <div class="control-group checkbox-group">
                <input type="checkbox" id="applyMultiplier" onchange="updateDisplay()">
                <label for="applyMultiplier" class="custom-checkbox">
                    ‡∏Ñ‡∏π‡∏ì‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏î‡πâ‡∏ß‡∏¢‡∏ï‡∏±‡∏ß‡∏Ñ‡∏π‡∏ì
                    <span class="icon-checked">‚úî</span> <span class="icon-unchecked"></span> </label>
            </div>

            <div class="control-group">
                <button id="exportExcel" class="button">Export Data to Excel</button>
            </div>
        </div>

        <div id="output" class="output-section"></div>
    </div>
    <script>
        const holidays = new Set();
        let globalResults = []; // Stores all raw data from the Excel file
        let isProcessed = false; // Status if file is processed
        let meterNumber = '';

        // monthlySummaries and monthlyMaxValues will now store the data for the CURRENTLY DISPLAYED summary data (all months)
        let monthlySummaries = {};
        let monthlyMaxValues = {};

        let sortState = {
            columnIndex: null,
            direction: 'asc'
        };

        const dropArea = document.getElementById('dropArea');
        const excelFileInput = document.getElementById('excelFile');

        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropArea.addEventListener(eventName, preventDefaults, false);
            document.body.addEventListener(eventName, preventDefaults, false);
        });

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        ['dragenter', 'dragover'].forEach(eventName => {
            dropArea.addEventListener(eventName, () => dropArea.classList.add('drag-over'), false);
        });

        ['dragleave', 'drop'].forEach(eventName => {
            dropArea.addEventListener(eventName, () => dropArea.classList.remove('drag-over'), false);
        });

        dropArea.addEventListener('drop', handleDrop, false);

        function handleDrop(e) {
            const dt = e.dataTransfer;
            const files = dt.files;

            if (files.length > 0) {
                // Reset isProcessed when a new file is dropped
                isProcessed = false;
                excelFileInput.files = files;
                process();
            }
        }

        dropArea.addEventListener('click', () => {
            excelFileInput.click();
        });

        excelFileInput.addEventListener('change', () => {
            if (excelFileInput.files.length > 0) {
                // Reset isProcessed when a new file is selected
                isProcessed = false;
                process();
            }
        });

        // Helper function to extract BKK time components from a UTC-adjusted Date object.
        function getBKKTimeComponents(utcDateObj) {
            return {
                hour: utcDateObj.getUTCHours(),
                minute: utcDateObj.getUTCMinutes(),
                second: utcDateObj.getUTCSeconds(),
                day: utcDateObj.getUTCDate(),
                month: utcDateObj.getUTCMonth(), // 0-indexed
                year: utcDateObj.getUTCFullYear(),
                dayOfWeek: utcDateObj.getUTCDay() // BKK day of week (0=Sun, 6=Sat)
            };
        }

        // Helper function to get a Date object representing midnight of a calendar day in BKK timezone.
        // The returned Date object's UTC components will *directly* represent BKK midnight.
        function getBKKMidnightUTCAdjusted(year, monthIndex, day) { // monthIndex is 0-indexed
            // Create a Date object where its UTC components directly represent BKK midnight for the given day.
            const d = new Date(Date.UTC(year, monthIndex, day, 0, 0, 0));
            return d;
        }

        // ******** ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏õ‡∏•‡∏á Excel Date ‡πÄ‡∏õ‡πá‡∏ô BKK Time ‡πÉ‡∏ô‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö UTC-adjusted (‡∏à‡∏∏‡∏î‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏ó‡∏µ‡πà‡∏õ‡∏£‡∏±‡∏ö) ********
        function convertExcelDateToBKKUTCAdjusted(rawDate) {
            let dateObj;
            const bkkOffsetMs = 7 * 60 * 60 * 1000; // 7 hours in milliseconds

            if (rawDate instanceof Date) {
                dateObj = new Date(rawDate.getTime() + bkkOffsetMs);
            } else if (typeof rawDate === 'number') {
                const parsed = XLSX.SSF.parse_date_code(rawDate);
                dateObj = new Date(Date.UTC(parsed.y, parsed.m - 1, parsed.d, parsed.H, parsed.M, parsed.S));
            } else if (typeof rawDate === 'string') {
                const match = rawDate.match(/(\d{1,2})\/(\d{1,2})\/(\d{4})\s*(\d{1,2}):(\d{2}):(\d{2})|(\d{4})-(\d{1,2})-(\d{1,2})T(\d{1,2}):(\d{2}):(\d{2})/);
                if (match) {
                    let year, month, day, hour, minute, second;
                    if (match[1]) { // DD/MM/YYYY HH:mm:ss format
                        [, day, month, year, hour, minute, second] = match;
                        year = parseInt(year) > 2500 ? parseInt(year) - 543 : parseInt(year); // Convert Buddhist year to AD
                    } else if (match[7]) { //YYYY-MM-DDTHH:mm:ss format
                        [, , , , , , year, month, day, hour, minute, second] = match;
                    }
                    dateObj = new Date(Date.UTC(parseInt(year), parseInt(month) - 1, parseInt(day), parseInt(hour), parseInt(minute), parseInt(second)));
                } else {
                    let tempDate = new Date(rawDate);
                    if (!isNaN(tempDate.getTime())) {
                        dateObj = new Date(tempDate.getTime() + bkkOffsetMs);
                    } else {
                        return null;
                    }
                }
            } else {
                return null;
            }

            return isNaN(dateObj.getTime()) ? null : dateObj;
        }
        // ******************************************************************************

        function collectHolidays() {
            holidays.clear();
            const allHolidayVars = [
                typeof holiday_2022 !== 'undefined' ? holiday_2022 : null,
                typeof holiday_2023 !== 'undefined' ? holiday_2023 : null,
                typeof holiday_2024 !== 'undefined' ? holiday_2024 : null,
                typeof holiday_2025 !== 'undefined' ? holiday_2025 : null
            ];
            allHolidayVars.forEach(data => {
                if (!data || !data.data) return;
                data.data.forEach(entry => {
                    if (entry.tou === 1 && entry.holiday) {
                        const [d, m, byear] = entry.holiday.split('/');
                        const year = parseInt(byear) - 543;

                        const bkkHolidayMidnight = getBKKMidnightUTCAdjusted(year, parseInt(m) - 1, parseInt(d));

                        const isoDate = bkkHolidayMidnight.toISOString().split('T')[0];
                        holidays.add(isoDate);
                    }
                });
            });
        }

        function isHoliday(date) {
            let checkDate = new Date(date.getTime());

            const bkkComponents = getBKKTimeComponents(checkDate);
            let hour = bkkComponents.hour;
            let min = bkkComponents.minute;

            if (hour === 0 && min < 15) {
                checkDate.setUTCHours(checkDate.getUTCHours() - 24);
            }

            const finalBkkComponents = getBKKTimeComponents(checkDate);
            const iso = finalBkkComponents.year + '-' +
                String(finalBkkComponents.month + 1).padStart(2, '0') + '-' +
                String(finalBkkComponents.day).padStart(2, '0');
            return holidays.has(iso);
        }

        function getRate(date) {
            let checkDate = new Date(date.getTime());

            const bkkComponents = getBKKTimeComponents(checkDate);
            let hour = bkkComponents.hour;
            let min = bkkComponents.minute;

            if (hour === 0 && min < 15) {
                checkDate.setUTCHours(checkDate.getUTCHours() - 24);
                const adjustedBkkComponents = getBKKTimeComponents(checkDate);
                hour = adjustedBkkComponents.hour;
                min = adjustedBkkComponents.minute;
            }

            const day = getBKKTimeComponents(checkDate).dayOfWeek;
            if (isHoliday(date) || day === 0 || day === 6) {
                return 'Holiday';
            }

            const totalMin = hour * 60 + min;
            const peakStart = 9 * 60 + 15; // 09:15
            const peakEnd = 22 * 60; // 22:00

            if (totalMin >= peakStart && totalMin <= peakEnd) {
                return 'Peak';
            } else {
                return 'Off-peak';
            }
        }

        function getDaysInMonth(year, month) {
            return new Date(Date.UTC(year, month, 0)).getUTCDate();
        }

        function getReadingDay(year, month, arType) { // month is 1-indexed here (1-12)
            const numDaysInMonth = getDaysInMonth(year, month);

            if (arType === 'AR1') {
                return numDaysInMonth - 10;
            } else if (arType === 'AR6') {
                return numDaysInMonth - 2;
            } else if (arType === 'HA1') {
                return 1;
            }
            console.error(`[getReadingDay] Unknown AR Type: ${arType}`);
            return -1;
        }

        function isInBillingPeriod(dateObject, arType, targetMonth, targetYear) {
            let billingPeriodStartDate, billingPeriodEndDate;

            if (arType === 'HA1') {
                billingPeriodStartDate = getBKKMidnightUTCAdjusted(targetYear, targetMonth - 1, 1);
                billingPeriodStartDate.setMinutes(billingPeriodStartDate.getMinutes() + 15);

                let nextMonth = targetMonth + 1;
                let nextMonthYear = targetYear;
                if (nextMonth > 12) {
                    nextMonth = 1;
                    nextMonthYear++;
                }
                billingPeriodEndDate = getBKKMidnightUTCAdjusted(nextMonthYear, nextMonth - 1, 1);

            } else {
                let prevReadingMonth = targetMonth - 1;
                let prevReadingYear = targetYear;
                if (prevReadingMonth === 0) {
                    prevReadingMonth = 12;
                    prevReadingYear--;
                }

                const prevReadingDay = getReadingDay(prevReadingYear, prevReadingMonth, arType);
                if (prevReadingDay === -1) {
                    return false;
                }

                billingPeriodStartDate = getBKKMidnightUTCAdjusted(prevReadingYear, prevReadingMonth - 1, prevReadingDay);
                billingPeriodStartDate.setMinutes(billingPeriodStartDate.getMinutes() + 15);

                const currentReadingDay = getReadingDay(targetYear, targetMonth, arType);
                if (currentReadingDay === -1) {
                    return false;
                }

                let thisMonthReadingDate = getBKKMidnightUTCAdjusted(targetYear, targetMonth - 1, currentReadingDay);
                billingPeriodEndDate = new Date(thisMonthReadingDate.getTime());
                billingPeriodEndDate.setUTCHours(0);
                billingPeriodEndDate.setUTCMinutes(0);
                billingPeriodEndDate.setUTCSeconds(0);
            }
            // console.log(`Checking date: ${dateObject.toISOString()} against period: ${billingPeriodStartDate.toISOString()} to ${billingPeriodEndDate.toISOString()}`);
            return dateObject.getTime() >= billingPeriodStartDate.getTime() && dateObject.getTime() <= billingPeriodEndDate.getTime();
        }

        function sortTable(columnIndex) {
            if (!isProcessed) return;

            if (sortState.columnIndex === columnIndex) {
                sortState.direction = sortState.direction === 'asc' ? 'desc' : 'asc';
            } else {
                sortState.columnIndex = columnIndex;
                if (columnIndex === 0) { // Datetime
                    sortState.direction = 'asc';
                } else if (columnIndex === 1) { // Rate
                    sortState.direction = 'asc';
                } else { // Numeric columns
                    sortState.direction = 'desc';
                }
            }

            updateDisplay(); // Re-render the detailed table after sorting
        }

        function customRound(value, decimalPlaces) {
            const factor = Math.pow(10, decimalPlaces);
            return Math.round(value * factor) / factor;
        }

        function populateMonthYearSelector() {
            const selector = document.getElementById('monthYearSelector');
            selector.innerHTML = '';

            const monthNames = ["‡∏°‡∏Å‡∏£‡∏≤‡∏Ñ‡∏°", "‡∏Å‡∏∏‡∏°‡∏†‡∏≤‡∏û‡∏±‡∏ô‡∏ò‡πå", "‡∏°‡∏µ‡∏ô‡∏≤‡∏Ñ‡∏°", "‡πÄ‡∏°‡∏©‡∏≤‡∏¢‡∏ô", "‡∏û‡∏§‡∏©‡∏†‡∏≤‡∏Ñ‡∏°", "‡∏°‡∏¥‡∏ñ‡∏∏‡∏ô‡∏≤‡∏¢‡∏ô", "‡∏Å‡∏£‡∏Å‡∏é‡∏≤‡∏Ñ‡∏°", "‡∏™‡∏¥‡∏á‡∏´‡∏≤‡∏Ñ‡∏°", "‡∏Å‡∏±‡∏ô‡∏¢‡∏≤‡∏¢‡∏ô", "‡∏ï‡∏∏‡∏•‡∏≤‡∏Ñ‡∏°", "‡∏û‡∏§‡∏®‡∏à‡∏¥‡∏Å‡∏≤‡∏¢‡∏ô", "‡∏ò‡∏±‡∏ô‡∏ß‡∏≤‡∏Ñ‡∏°"];

            const uniqueMonthYears = new Set();
            globalResults.forEach(r => {
                const {
                    year,
                    month
                } = getBKKTimeComponents(r.dateObject);
                uniqueMonthYears.add(`${year}-${(month + 1).toString().padStart(2, '0')}`);
            });

            const sortedUniqueMonthYears = Array.from(uniqueMonthYears).sort();

            const allOption = document.createElement('option');
            allOption.value = 'all';
            allOption.textContent = '‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î';
            selector.appendChild(allOption);

            sortedUniqueMonthYears.forEach(periodStr => {
                const [yearStr, monthStr] = periodStr.split('-');
                const year = parseInt(yearStr);
                const month = parseInt(monthStr);

                const option = document.createElement('option');
                option.value = `${year}-${month.toString().padStart(2, '0')}`;
                option.textContent = `${monthNames[month - 1]} ${year + 543}`;
                selector.appendChild(option);
            });

            if (sortedUniqueMonthYears.length > 0) {
                // Set default to the latest month available
                selector.value = sortedUniqueMonthYears[sortedUniqueMonthYears.length - 1];
            }
        }

        function getBillingPeriodDates(selectedYear, selectedMonth, arType) {
            let billingPeriodStartDate, billingPeriodEndDate;

            if (arType === 'HA1') {
                billingPeriodStartDate = getBKKMidnightUTCAdjusted(selectedYear, selectedMonth - 1, 1);
                billingPeriodStartDate.setMinutes(billingPeriodStartDate.getMinutes() + 15);

                let nextMonth = selectedMonth + 1;
                let nextMonthYear = selectedYear;
                if (nextMonth > 12) {
                    nextMonth = 1;
                    nextMonthYear++;
                }
                billingPeriodEndDate = getBKKMidnightUTCAdjusted(nextMonthYear, nextMonth - 1, 1);

            } else {
                let prevReadingMonth = selectedMonth - 1;
                let prevReadingYear = selectedYear;
                if (prevReadingMonth === 0) {
                    prevReadingMonth = 12;
                    prevReadingYear--;
                }

                const prevReadingDay = getReadingDay(prevReadingYear, prevReadingMonth, arType);
                if (prevReadingDay === -1) {
                    console.error(`[getBillingPeriodDates] Failed to get previous reading day for ${prevReadingYear}-${prevReadingMonth}`);
                    return {
                        startDate: null,
                        endDate: null
                    };
                }

                billingPeriodStartDate = getBKKMidnightUTCAdjusted(prevReadingYear, prevReadingMonth - 1, prevReadingDay);
                billingPeriodStartDate.setMinutes(billingPeriodStartDate.getMinutes() + 15);


                const currentReadingDay = getReadingDay(selectedYear, selectedMonth, arType);
                if (currentReadingDay === -1) {
                    console.error(`[getBillingPeriodDates] Could not determine currentReadingDay for ${selectedYear}-${selectedMonth}`);
                    return {
                        startDate: null,
                        endDate: null
                    };
                }

                let thisMonthReadingDate = getBKKMidnightUTCAdjusted(selectedYear, selectedMonth - 1, currentReadingDay);
                billingPeriodEndDate = new Date(thisMonthReadingDate.getTime());
                billingPeriodEndDate.setUTCHours(0);
                billingPeriodEndDate.setUTCMinutes(0);
                billingPeriodEndDate.setUTCSeconds(0);
            }

            return {
                startDate: billingPeriodStartDate,
                endDate: billingPeriodEndDate
            };
        }


        function calculateAllMonthsSummariesAndMaxes(selectedArType, selectedDataType) {
            const calculatedMonthlySummaries = {};
            const calculatedMonthlyMaxValues = {};

            const applyMultiplierForSummaryCalculation = document.getElementById('applyMultiplier').checked;

            const decimalPlacesForKwSummary = 3;

            // First, determine all unique billing months present in the data for the selected AR type
            const uniqueBillingMonthYears = new Set();
            globalResults.forEach(r => {
                const bkkComponents = getBKKTimeComponents(r.dateObject);
                const calendarMonthKey = `${bkkComponents.year}-${(bkkComponents.month + 1).toString().padStart(2, '0')}`;
                uniqueBillingMonthYears.add(calendarMonthKey);
            });

            Array.from(uniqueBillingMonthYears).sort().forEach(monthKey => {
                const [yearStr, monthStr] = monthKey.split('-');
                const targetYear = parseInt(yearStr);
                const targetMonth = parseInt(monthStr);

                const { startDate, endDate } = getBillingPeriodDates(targetYear, targetMonth, selectedArType);

                if (!startDate || !endDate) {
                    return;
                }

                calculatedMonthlySummaries[monthKey] = {
                    'Peak': { wh: 0, varh: 0 },
                    'Off-peak': { wh: 0, varh: 0 },
                    'Holiday': { wh: 0, varh: 0 }
                };
                calculatedMonthlyMaxValues[monthKey] = {
                    'Peak': { wh: 0, varh: 0, wh_datetime: '', varh_datetime: '' },
                    'Off-peak': { wh: 0, varh: 0, wh_datetime: '', varh_datetime: '' },
                    'Holiday': { wh: 0, varh: 0, wh_datetime: '', varh_datetime: '' }
                };

                globalResults.forEach(r => {
                    const dateObjectBKK = r.dateObject;
                    if (dateObjectBKK.getTime() >= startDate.getTime() && dateObjectBKK.getTime() <= endDate.getTime()) {
                        const originalWhValue = selectedDataType === 'wh_import' ? r.originalWhImportValue : r.originalWhExportValue;
                        const originalVarhValue = r.originalVarhValue || 0;
                        const rate = getRate(dateObjectBKK);
                        const currentMultiplierForSummaryCalculation = applyMultiplierForSummaryCalculation ? r.rowMultiplier : 1;

                        const wh_sum_value = (originalWhValue * currentMultiplierForSummaryCalculation);
                        const varh_sum_value = (originalVarhValue * currentMultiplierForSummaryCalculation);

                        calculatedMonthlySummaries[monthKey][rate].wh += wh_sum_value;
                        calculatedMonthlySummaries[monthKey][rate].varh += varh_sum_value;

                        // Calculation for kW Max and kVar Max
                        const kW_calculated_base = customRound((Math.round(originalWhValue * 4) * currentMultiplierForSummaryCalculation / 1000), decimalPlacesForKwSummary);
                        const kVar_calculated_base = customRound((Math.round(originalVarhValue * 4) * currentMultiplierForSummaryCalculation / 1000), decimalPlacesForKwSummary);

                        if (kW_calculated_base > calculatedMonthlyMaxValues[monthKey][rate].wh ||
                            (kW_calculated_base === calculatedMonthlyMaxValues[monthKey][rate].wh &&
                                new Date(r.datetime) < new Date(calculatedMonthlyMaxValues[monthKey][rate].wh_datetime))) {
                            calculatedMonthlyMaxValues[monthKey][rate].wh = kW_calculated_base;
                            calculatedMonthlyMaxValues[monthKey][rate].wh_datetime = r.datetime;
                        }
                        if (kVar_calculated_base > calculatedMonthlyMaxValues[monthKey][rate].varh ||
                            (kVar_calculated_base === calculatedMonthlyMaxValues[monthKey][rate].varh &&
                                new Date(r.datetime) < new Date(calculatedMonthlyMaxValues[monthKey][rate].varh_datetime))) {
                            calculatedMonthlyMaxValues[monthKey][rate].varh = kVar_calculated_base;
                            calculatedMonthlyMaxValues[monthKey][rate].varh_datetime = r.datetime;
                        }
                    }
                });
            });

            return { monthlySummaries: calculatedMonthlySummaries, monthlyMaxValues: calculatedMonthlyMaxValues };
        }


        let monthlyCurrentPage = 1;
        const monthlyItemsPerPage = 7; // ‡πÅ‡∏™‡∏î‡∏á 12 ‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏ï‡πà‡∏≠‡∏´‡∏ô‡πâ‡∏≤ (‡∏õ‡∏£‡∏±‡∏ö‡πÑ‡∏î‡πâ)

        function renderMonthlySummaryTable(monthlySummariesToRender, monthlyMaxValuesToRender, selectedDataType) {
            if (!isProcessed || Object.keys(monthlySummariesToRender).length === 0) {
                return `
            <div class="summary-section">
                <h2 class="section-title">‡∏™‡∏£‡∏∏‡∏õ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏û‡∏•‡∏±‡∏á‡∏á‡∏≤‡∏ô‡∏£‡∏≤‡∏¢‡πÄ‡∏î‡∏∑‡∏≠‡∏ô</h2>
                <p>‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏û‡∏•‡∏±‡∏á‡∏á‡∏≤‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó AR ‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å</p>
            </div>
        `;
            }

            const wh_unit = selectedDataType === 'wh_import' ? 'kWh (Import)' : 'kWh (Export)';

            const monthNames = ["‡∏°.‡∏Ñ.", "‡∏Å.‡∏û.", "‡∏°‡∏µ.‡∏Ñ.", "‡πÄ‡∏°.‡∏¢.", "‡∏û.‡∏Ñ.", "‡∏°‡∏¥.‡∏¢.", "‡∏Å.‡∏Ñ.", "‡∏™.‡∏Ñ.", "‡∏Å.‡∏¢.", "‡∏ï.‡∏Ñ.", "‡∏û.‡∏¢.", "‡∏ò.‡∏Ñ."];
            const sortedMonthKeys = Object.keys(monthlySummariesToRender).sort((a, b) => {
                const [yearA, monthA] = a.split('-').map(Number);
                const [yearB, monthB] = b.split('-').map(Number);
                if (yearA !== yearB) return yearA - yearB;
                return monthA - monthB;
            });

            const totalPages = Math.ceil(sortedMonthKeys.length / monthlyItemsPerPage);
            if (monthlyCurrentPage > totalPages) monthlyCurrentPage = totalPages;

            const startIndex = (monthlyCurrentPage - 1) * monthlyItemsPerPage;
            const endIndex = startIndex + monthlyItemsPerPage;
            const monthKeysToShow = sortedMonthKeys.slice(startIndex, endIndex);

            let monthlyTableHtml = `
        <div class="summary-section">
        <h2 class="section-title">‡∏™‡∏£‡∏∏‡∏õ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏û‡∏•‡∏±‡∏á‡∏á‡∏≤‡∏ô‡∏£‡∏≤‡∏¢‡πÄ‡∏î‡∏∑‡∏≠‡∏ô</h2>
        <div class="monthly-summary-table-container">
        <table>
            <thead>
                <tr>
                    <th>‡πÄ‡∏î‡∏∑‡∏≠‡∏ô/‡∏õ‡∏µ</th>
                    <th>${wh_unit} (‡∏£‡∏ß‡∏°)</th>
                    <th>${wh_unit} (Peak)</th>
                    <th>${wh_unit} (Off-Peak)</th>
                    <th>${wh_unit} (Holiday)</th>
                    <th>kW Max(Peak)</th>
                    <th>kW Max(Off-Peak)</th>
                    <th>kW Max(Holiday)</th>
                    <th>kVar Max(‡∏£‡∏ß‡∏°‡∏ó‡∏∏‡∏Å‡πÄ‡∏£‡∏ó)</th>
                    <th>‡πÄ‡∏ß‡∏•‡∏≤ kW (peak) ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î</th>
                    <th>‡πÄ‡∏ß‡∏•‡∏≤ kW (Off-Peak) ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î</th>
                    <th>‡πÄ‡∏ß‡∏•‡∏≤ kW (Holiday) ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î</th>
                </tr>
            </thead>
            <tbody>
    `;

            const decimalPlacesForKwhSummary = 2;
            const decimalPlacesForKwSummary = 3;

            monthKeysToShow.forEach(monthKey => {
                const [yearStr, monthStr] = monthKey.split('-');
                const year = parseInt(yearStr);
                const monthIndex = parseInt(monthStr) - 1;

                const currentMonthSummary = monthlySummariesToRender[monthKey];
                const currentMonthMax = monthlyMaxValuesToRender[monthKey];

                const displayTotalWhMonth = customRound(((currentMonthSummary['Peak'].wh + currentMonthSummary['Off-peak'].wh + currentMonthSummary['Holiday'].wh) / 1000), decimalPlacesForKwhSummary);

                const displayPeakWh = customRound((currentMonthSummary['Peak'].wh / 1000), decimalPlacesForKwhSummary);
                const displayOffPeakWh = customRound((currentMonthSummary['Off-peak'].wh / 1000), decimalPlacesForKwhSummary);
                const displayHolidayWh = customRound((currentMonthSummary['Holiday'].wh / 1000), decimalPlacesForKwhSummary);

                const displayPeakKw = customRound(currentMonthMax['Peak'].wh, decimalPlacesForKwSummary);
                const displayOffPeakKw = customRound(currentMonthMax['Off-peak'].wh, decimalPlacesForKwSummary);
                const displayHolidayKw = customRound(currentMonthMax['Holiday'].wh, decimalPlacesForKwSummary);

                let baseMaxKvarMonthOverall = 0;
                ['Peak', 'Off-peak', 'Holiday'].forEach(rate => {
                    if (currentMonthMax[rate].varh > baseMaxKvarMonthOverall) {
                        baseMaxKvarMonthOverall = currentMonthMax[rate].varh;
                    }
                });
                const displayMaxKvarMonthOverall = customRound(baseMaxKvarMonthOverall, decimalPlacesForKwSummary);

                monthlyTableHtml += `
            <tr>
                <td>${monthNames[monthIndex]} ${year + 543}</td>
                <td>${displayTotalWhMonth.toFixed(decimalPlacesForKwhSummary)}</td>
                <td>${displayPeakWh.toFixed(decimalPlacesForKwhSummary)}</td>
                <td>${displayOffPeakWh.toFixed(decimalPlacesForKwhSummary)}</td>
                <td>${displayHolidayWh.toFixed(decimalPlacesForKwhSummary)}</td>
                <td>${displayPeakKw.toFixed(decimalPlacesForKwSummary)}</td>
                <td>${displayOffPeakKw.toFixed(decimalPlacesForKwSummary)}</td>
                <td>${displayHolidayKw.toFixed(decimalPlacesForKwSummary)}</td>
                <td>${displayMaxKvarMonthOverall.toFixed(decimalPlacesForKwSummary)}</td>
                <td><small>${currentMonthMax['Peak'].wh_datetime || 'N/A'}</small></td>
                <td><small>${currentMonthMax['Off-peak'].wh_datetime || 'N/A'}</small></td>
                <td><small>${currentMonthMax['Holiday'].wh_datetime || 'N/A'}</small></td>
            </tr>
        `;
            });

            monthlyTableHtml += `
            </tbody>
        </table>
        </div>
    `;

            monthlyTableHtml += `
    <div class="pagination-controls">
        <button onclick="changeMonthlyPage(-1)" ${monthlyCurrentPage === 1 ? 'disabled' : ''}>&lt;</button>
        <span>‡∏´‡∏ô‡πâ‡∏≤ ${monthlyCurrentPage} / ${totalPages}</span>
        <button onclick="changeMonthlyPage(1)" ${monthlyCurrentPage === totalPages ? 'disabled' : ''}>&gt;</button>
    </div>
    </div>
`;

            return monthlyTableHtml;
        }

        function changeMonthlyPage(direction) {
            monthlyCurrentPage += direction;
            updateDisplay(); // re-render ‡πÉ‡∏´‡∏°‡πà
        }


        function renderResultsAsHtml(unitType, selectedMonthYear, selectedArType, selectedDataType) {
            if (!isProcessed) return '';

            let whUnit, varhUnit;
            const applyMultiplier = document.getElementById('applyMultiplier').checked;

            let whCalculation, varhCalculation;
            let decimalPlacesForSummary;
            let decimalPlacesForTable;

            if (unitType === 'kw_kvar') {
                whUnit = 'kW';
                varhUnit = 'kVar';
                decimalPlacesForSummary = 3;
                decimalPlacesForTable = 3;

                whCalculation = (wh_val_raw, currentMultiplier) => {
                    const roundedWhTimesFour = Math.round(parseFloat(wh_val_raw) * 4);
                    return customRound((roundedWhTimesFour * currentMultiplier / 1000), decimalPlacesForTable);
                };
                varhCalculation = (varh_val_raw, currentMultiplier) => {
                    const roundedVarhTimesFour = Math.round(parseFloat(varh_val_raw) * 4);
                    return customRound((roundedVarhTimesFour * currentMultiplier / 1000), decimalPlacesForTable);
                };
            } else {
                whUnit = selectedDataType === 'wh_import' ? 'Wh Import' : 'Wh Export';
                varhUnit = 'Varh';
                decimalPlacesForSummary = 2;
                decimalPlacesForTable = 5;

                whCalculation = (wh_val_raw, currentMultiplier) => {
                    return customRound((parseFloat(wh_val_raw) * currentMultiplier), decimalPlacesForTable);
                };

                varhCalculation = (varh_val_raw, currentMultiplier) => {
                    return customRound((parseFloat(varh_val_raw) * currentMultiplier), decimalPlacesForTable);
                };
            }

            let tableRowsHtml = '';

            let overallMaxBaseKwCalculated = { value: 0, datetime: '' };
            let overallMaxBaseKvarCalculated = { value: 0, datetime: '' };

            let filteredResults = [];
            if (selectedMonthYear === 'all') {
                filteredResults = [...globalResults];
            } else {
                const [yearStr, monthStr] = selectedMonthYear.split('-');
                const selectedMonthInt = parseInt(monthStr);
                const selectedYearInt = parseInt(yearStr);

                filteredResults = globalResults.filter(r => {
                    const isWithinBillingPeriod = isInBillingPeriod(r.dateObject, selectedArType, selectedMonthInt, selectedYearInt);
                    return isWithinBillingPeriod;
                });
            }

            const dataToRender = [...filteredResults];
            if (sortState.columnIndex !== null) {
                const directionModifier = sortState.direction === 'asc' ? 1 : -1;
                const selectedUnit = document.getElementById('unitSelector').value;
                const applyMultiplierForSort = document.getElementById('applyMultiplier').checked;

                let whUnitConverterForSort, varhUnitConverterForSort;
                if (selectedUnit === 'kw_kvar') {
                    whUnitConverterForSort = (wh_val, mult) => (Math.round(parseFloat(wh_val) * 4) / 1000) * mult;
                    varhUnitConverterForSort = (varh_val, mult) => (Math.round(parseFloat(varh_val) * 4) / 1000) * mult;
                } else {
                    whUnitConverterForSort = (wh_val, mult) => (parseFloat(wh_val) * mult);
                    varhUnitConverterForSort = (varh_val, mult) => (parseFloat(varh_val) * mult);
                }

                dataToRender.sort((a, b) => {
                    let valA, valB;
                    const multA = applyMultiplierForSort ? a.rowMultiplier : 1;
                    const multB = applyMultiplierForSort ? b.rowMultiplier : 1;
                    let wh_val_A = selectedDataType === 'wh_import' ? a.originalWhImportValue : a.originalWhExportValue;
                    let wh_val_B = selectedDataType === 'wh_import' ? b.originalWhImportValue : b.originalWhExportValue;

                    switch (sortState.columnIndex) {
                        case 0:
                            valA = a.dateObject.getTime();
                            valB = b.dateObject.getTime();
                            break;
                        case 1:
                            valA = getRate(a.dateObject);
                            valB = getRate(b.dateObject);
                            const rateOrder = {
                                'Holiday': 1,
                                'Off-peak': 2,
                                'Peak': 3
                            };
                            return (rateOrder[valA] - rateOrder[valB]) * directionModifier;
                        case 2:
                            valA = whUnitConverterForSort(wh_val_A, multA);
                            valB = whUnitConverterForSort(wh_val_B, multB);
                            break;
                        case 3:
                            valA = varhUnitConverterForSort(a.originalVarhValue, multA);
                            valB = varhUnitConverterForSort(b.originalVarhValue, multB);
                            break;
                        case 4:
                            valA = a.rowMultiplier;
                            valB = b.rowMultiplier;
                            break;
                        default:
                            return 0;
                    }

                    if (typeof valA === 'string') {
                        return valA.localeCompare(valB) * directionModifier;
                    } else {
                        return (valA - valB) * directionModifier;
                    }
                });
            }

            let peakMaxKwAll, offPeakMaxKwAll, holidayMaxKwAll;
            let peakMaxKvarAll, offPeakMaxKvarAll, holidayMaxKvarAll;

            if (selectedMonthYear === 'all') {
                const maxes = {
                    'Peak': { wh: 0, varh: 0, wh_datetime: '', varh_datetime: '' },
                    'Off-peak': { wh: 0, varh: 0, wh_datetime: '', varh_datetime: '' },
                    'Holiday': { wh: 0, varh: 0, wh_datetime: '', varh_datetime: '' }
                };

                dataToRender.forEach(r => {
                    const rawWh = selectedDataType === 'wh_import' ? r.originalWhImportValue : r.originalWhExportValue;
                    const rawVarh = r.originalVarhValue || 0;
                    const currentMultiplier = applyMultiplier ? r.rowMultiplier : 1;
                    const rate = getRate(r.dateObject);

                    const kW_calculated = customRound((Math.round(rawWh * 4) * currentMultiplier / 1000), 3);
                    const kVar_calculated = customRound((Math.round(rawVarh * 4) * currentMultiplier / 1000), 3);

                    if (kW_calculated > maxes[rate].wh) {
                        maxes[rate].wh = kW_calculated;
                        maxes[rate].wh_datetime = r.datetime;
                    }
                    if (kVar_calculated > maxes[rate].varh) {
                        maxes[rate].varh = kVar_calculated;
                        maxes[rate].varh_datetime = r.datetime;
                    }
                });

                peakMaxKwAll = maxes['Peak'].wh;
                offPeakMaxKwAll = maxes['Off-peak'].wh;
                holidayMaxKwAll = maxes['Holiday'].wh;
                peakMaxKvarAll = maxes['Peak'].varh;
                offPeakMaxKvarAll = maxes['Off-peak'].varh;
                holidayMaxKvarAll = maxes['Holiday'].varh;
            }


            dataToRender.forEach(r => {
                const rawWh = selectedDataType === 'wh_import' ? r.originalWhImportValue : r.originalWhExportValue;
                const rawVarh = r.originalVarhValue || 0;
                const currentMultiplier = applyMultiplier ? r.rowMultiplier : 1;

                if (unitType === 'kw_kvar') {
                    const currentCalculatedKwBase = (Math.round(rawWh * 4) / 1000) * currentMultiplier;
                    const currentCalculatedKvarBase = (Math.round(rawVarh * 4) / 1000) * currentMultiplier;

                    if (currentCalculatedKwBase > overallMaxBaseKwCalculated.value ||
                        (currentCalculatedKwBase === overallMaxBaseKwCalculated.value &&
                            new Date(r.datetime) < new Date(overallMaxBaseKwCalculated.datetime))) {
                        overallMaxBaseKwCalculated.value = currentCalculatedKwBase;
                        overallMaxBaseKwCalculated.datetime = r.datetime;
                    }

                    if (currentCalculatedKvarBase > overallMaxBaseKvarCalculated.value ||
                        (currentCalculatedKvarBase === overallMaxBaseKvarCalculated.value &&
                            new Date(r.datetime) < new Date(overallMaxBaseKvarCalculated.datetime))) {
                        overallMaxBaseKvarCalculated.value = currentCalculatedKvarBase;
                        overallMaxBaseKvarCalculated.datetime = r.datetime;
                    }
                }

                const currentWh = whCalculation(rawWh, currentMultiplier);
                const currentVarh = varhCalculation(rawVarh, currentMultiplier);

                let displayWhInTable, displayVarhInTable;
                displayWhInTable = currentWh.toFixed(decimalPlacesForTable);
                displayVarhInTable = currentVarh.toFixed(decimalPlacesForTable);

                let displayDatetime = r.datetime;
                const cls = getRate(r.dateObject).toLowerCase().replace('-', '');
                tableRowsHtml += `<tr class="${cls}">
            <td>${displayDatetime}</td><td>${getRate(r.dateObject)}</td>
            <td>${displayWhInTable}</td><td>${displayVarhInTable}</td>
            <td>${applyMultiplier ? r.rowMultiplier.toFixed(4) : 1}</td>
        </tr>`;
            });


            let mainSummaryHtml = '';

            mainSummaryHtml += '<div class="rate-summary-container">';

            if (unitType === 'kw_kvar') {
                const displayOverallMaxKw = customRound(overallMaxBaseKwCalculated.value, decimalPlacesForSummary);
                const displayOverallMaxKvar = customRound(overallMaxBaseKvarCalculated.value, decimalPlacesForSummary);

                let displayPeakMaxKw, displayOffPeakMaxKw, displayHolidayMaxKw;
                let displayPeakMaxKvar, displayOffPeakMaxKvar, displayHolidayMaxKvar;
                let peakKwDatetime, offPeakKwDatetime, holidayKwDatetime;
                let peakKvarDatetime, offPeakKvarDatetime, holidayKvarDatetime;


                if (selectedMonthYear !== 'all') {
                    const currentMonthMaxData = monthlyMaxValues[selectedMonthYear];
                    displayPeakMaxKw = customRound(currentMonthMaxData['Peak'].wh, decimalPlacesForSummary);
                    displayOffPeakMaxKw = customRound(currentMonthMaxData['Off-peak'].wh, decimalPlacesForSummary);
                    displayHolidayMaxKw = customRound(currentMonthMaxData['Holiday'].wh, decimalPlacesForSummary);
                    displayPeakMaxKvar = customRound(currentMonthMaxData['Peak'].varh, decimalPlacesForSummary);
                    displayOffPeakMaxKvar = customRound(currentMonthMaxData['Off-peak'].varh, decimalPlacesForSummary);
                    displayHolidayMaxKvar = customRound(currentMonthMaxData['Holiday'].varh, decimalPlacesForSummary);
                    peakKwDatetime = currentMonthMaxData['Peak'].wh_datetime;
                    offPeakKwDatetime = currentMonthMaxData['Off-peak'].wh_datetime;
                    holidayKwDatetime = currentMonthMaxData['Holiday'].wh_datetime;
                    peakKvarDatetime = currentMonthMaxData['Peak'].varh_datetime;
                    offPeakKvarDatetime = currentMonthMaxData['Off-peak'].varh_datetime;
                    holidayKvarDatetime = currentMonthMaxData['Holiday'].varh_datetime;
                } else {
                    displayPeakMaxKw = customRound(peakMaxKwAll, decimalPlacesForSummary);
                    displayOffPeakMaxKw = customRound(offPeakMaxKwAll, decimalPlacesForSummary);
                    displayHolidayMaxKw = customRound(holidayMaxKwAll, decimalPlacesForSummary);
                    displayPeakMaxKvar = customRound(peakMaxKvarAll, decimalPlacesForSummary);
                    displayOffPeakMaxKvar = customRound(offPeakMaxKvarAll, decimalPlacesForSummary);
                    displayHolidayMaxKvar = customRound(holidayMaxKvarAll, decimalPlacesForSummary);
                    peakKwDatetime = 'N/A';
                    offPeakKwDatetime = 'N/A';
                    holidayKwDatetime = 'N/A';
                    peakKvarDatetime = 'N/A';
                    offPeakKvarDatetime = 'N/A';
                    holidayKvarDatetime = 'N/A';
                }

                mainSummaryHtml += `
            <div class="summary-box overall-max-summary">
                <h3>kW/kVar ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î‡∏£‡∏ß‡∏°‡∏ó‡∏∏‡∏Å‡πÄ‡∏£‡∏ó</h3>
                <p>kW: <strong>${displayOverallMaxKw.toFixed(decimalPlacesForSummary)} ${whUnit}</strong><br>
                <small>‡πÄ‡∏°‡∏∑‡πà‡∏≠: ${overallMaxBaseKwCalculated.datetime || 'N/A'}</small></p>
                <p>kVar: <strong>${displayOverallMaxKvar.toFixed(decimalPlacesForSummary)} ${varhUnit}</strong><br>
                <small>‡πÄ‡∏°‡∏∑‡πà‡∏≠: ${overallMaxBaseKvarCalculated.datetime || 'N/A'}</small></p>
            </div>
            <div class="summary-box max-kw-peak-summary summary-peak">
                <h3>kW/kVar ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î (Peak)</h3>
                <p>kW: <strong>${displayPeakMaxKw !== 'N/A' ? displayPeakMaxKw.toFixed(decimalPlacesForSummary) : 'N/A'} ${whUnit}</strong><br>
                <small>‡πÄ‡∏°‡∏∑‡πà‡∏≠: ${peakKwDatetime}</small></p>
                <p>kVar: <strong>${displayPeakMaxKvar !== 'N/A' ? displayPeakMaxKvar.toFixed(decimalPlacesForSummary) : 'N/A'} ${varhUnit}</strong><br>
                <small>‡πÄ‡∏°‡∏∑‡πà‡∏≠: ${peakKvarDatetime}</small></p>
            </div>
            <div class="summary-box max-kw-off-peak-summary summary-off-peak">
                <h3>kW/kVar ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î (Off-peak)</h3>
                <p>kW: <strong>${displayOffPeakMaxKw !== 'N/A' ? displayOffPeakMaxKw.toFixed(decimalPlacesForSummary) : 'N/A'} ${whUnit}</strong><br>
                <small>‡πÄ‡∏°‡∏∑‡πà‡∏≠: ${offPeakKwDatetime}</small></p>
                <p>kVar: <strong>${displayOffPeakMaxKvar !== 'N/A' ? displayOffPeakMaxKvar.toFixed(decimalPlacesForSummary) : 'N/A'} ${varhUnit}</strong><br>
                <small>‡πÄ‡∏°‡∏∑‡πà‡∏≠: ${offPeakKvarDatetime}</small></p>
            </div>
            <div class="summary-box max-kw-holiday-summary summary-holiday">
                <h3>kW/kVar ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î (Holiday)</h3>
                <p>kW: <strong>${displayHolidayMaxKw !== 'N/A' ? displayHolidayMaxKw.toFixed(decimalPlacesForSummary) : 'N/A'} ${whUnit}</strong><br>
                <small>‡πÄ‡∏°‡∏∑‡πà‡∏≠: ${holidayKwDatetime}</small></p>
                <p>kVar: <strong>${displayHolidayMaxKvar !== 'N/A' ? displayHolidayMaxKvar.toFixed(decimalPlacesForSummary) : 'N/A'} ${varhUnit}</strong><br>
                <small>‡πÄ‡∏°‡∏∑‡πà‡∏≠: ${holidayKvarDatetime}</small></p>
            </div>
        `;
            }

            mainSummaryHtml += '</div>';

            const headers = [{
                title: '‡∏ß‡∏±‡∏ô‡πÄ‡∏ß‡∏•‡∏≤',
                index: 0
            }, {
                title: '‡πÄ‡∏£‡∏ó',
                index: 1
            }, {
                title: whUnit,
                index: 2
            }, {
                title: varhUnit,
                index: 3
            }, {
                title: '‡∏ï‡∏±‡∏ß‡∏Ñ‡∏π‡∏ì',
                index: 4
            }];

            const headerHtml = headers.map(h => {
                const isActiveSort = sortState.columnIndex !== null && sortState.columnIndex === h.index;
                const sortClass = isActiveSort ? `active-sort ${sortState.direction}` : '';
                return `<th class="sortable ${sortClass}" onclick="sortTable(${h.index})" data-column-index="${h.index}">
                ${h.title} <span class="sort-indicator"></span>
            </th>`;
            }).join('');

            let tableHtml = `<h2 class="section-title">‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏£‡∏≤‡∏¢ 15 ‡∏ô‡∏≤‡∏ó‡∏µ</h2><table><tr>${headerHtml}</tr>${tableRowsHtml}</table>`;

            return mainSummaryHtml + tableHtml;
        }


        async function process() {
            if (isProcessed) {
                console.log("File already processed. Skipping re-processing.");
                return;
            }

            collectHolidays();
            const file = excelFileInput.files[0];
            if (!file) {
                alert("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏ü‡∏•‡πå Excel ‡∏´‡∏£‡∏∑‡∏≠‡∏•‡∏≤‡∏Å‡πÑ‡∏ü‡∏•‡πå‡∏°‡∏≤‡∏ß‡∏≤‡∏á‡∏Å‡πà‡∏≠‡∏ô‡∏Ñ‡∏£‡∏±‡∏ö/‡∏Ñ‡πà‡∏∞");
                return;
            }

            dropArea.innerHTML = `<span class="icon" style="color: #28a745;">‚úÖ</span><p>‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å: <strong>${file.name}</strong></p>`;
            document.getElementById('output').innerHTML = '<p>‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÑ‡∏ü‡∏•‡πå...</p>';


            const reader = new FileReader();
            reader.onload = function (e) {
                const data = new Uint8Array(e.target.result);
                const wb = XLSX.read(data, {
                    type: 'array',
                    cellDates: true
                });
                const sheet = wb.Sheets[wb.SheetNames[0]];

                let startRowForData = 3;
                let rawDateCol, whImportCol, whExportCol, varhCol;
                let isCompactFormat = false;

                const headerRowCompact = XLSX.utils.sheet_to_json(sheet, { header: 1, range: 'A1:C1' })[0];
                // console.log("Header row for compact check:", headerRowCompact); // Commented out for cleaner console

                if (headerRowCompact &&
                    headerRowCompact[0] === 'DATE_M' &&
                    headerRowCompact[1] === 'WH' &&
                    headerRowCompact[2] === 'VARHIMP Total') {

                    console.log("Detected compact format (3 columns).");
                    isCompactFormat = true;
                    startRowForData = 1;
                    rawDateCol = 0;
                    whImportCol = 1;
                    whExportCol = null;
                    varhCol = 2;

                    meterNumber = 'N/A (Compact File)';
                } else {
                    console.log("Detected standard format.");
                    isCompactFormat = false;
                    startRowForData = 3;
                    rawDateCol = 2;
                    whImportCol = 26;
                    whExportCol = 30; // Column AE
                    varhCol = 34;

                    if (sheet['A4'] && sheet['A4'].v !== undefined) {
                        meterNumber = sheet['A4'].v.toString();
                    } else {
                        meterNumber = 'N/A';
                    }
                }


                const rows = XLSX.utils.sheet_to_json(sheet, {
                    header: 1
                });

                globalResults = [];
                isProcessed = false;

                for (let i = startRowForData; i < rows.length; i++) {
                    const rawDate = rows[i][rawDateCol];
                    const originalWhImportValue = parseFloat(rows[i][whImportCol]) || 0;
                    const originalWhExportValue = whExportCol !== null ? parseFloat(rows[i][whExportCol]) || 0 : 0;
                    const originalVarhValue = parseFloat(rows[i][varhCol]) || 0;

                    if (!rawDate || (isNaN(originalWhImportValue) && isNaN(originalWhExportValue)) || isNaN(originalVarhValue)) continue;

                    let dateObjectBKK = convertExcelDateToBKKUTCAdjusted(rawDate);
                    if (!dateObjectBKK) continue;

                    // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÇ‡∏Ñ‡πâ‡∏î‡∏™‡πà‡∏ß‡∏ô‡∏ô‡∏µ‡πâ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏ï‡∏±‡∏ß‡∏Ñ‡∏π‡∏ì‡∏Ç‡∏≠‡∏á‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏ö‡∏£‡∏£‡∏ó‡∏±‡∏î
                    let rowMultiplier = 0;
                    if (!isCompactFormat) {
                        const e_val = parseFloat(rows[i][4]) || 0; // Column E (index 4)
                        const f_val = parseFloat(rows[i][5]) || 0; // Column F (index 5)
                        const g_val = parseFloat(rows[i][6]) || 0; // Column G (index 6)
                        const h_val = parseFloat(rows[i][7]) || 0; // Column H (index 7)

                        if (f_val !== 0 && h_val !== 0) {
                            rowMultiplier = (e_val / f_val) * (g_val / h_val);
                        }
                    } else {
                        rowMultiplier = 1; // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÑ‡∏ü‡∏•‡πå‡πÅ‡∏ö‡∏ö compact
                    }

                    const totalMinutesFromBKKMidnight = dateObjectBKK.getUTCHours() * 60 + dateObjectBKK.getUTCMinutes() + dateObjectBKK.getUTCSeconds() / 60;
                    const roundedTotalMinutesBKK = Math.round(totalMinutesFromBKKMidnight / 15) * 15;

                    const roundedDateObjectUTC = new Date(Date.UTC(
                        dateObjectBKK.getUTCFullYear(),
                        dateObjectBKK.getUTCMonth(),
                        dateObjectBKK.getUTCDate(),
                        0,
                        roundedTotalMinutesBKK,
                        0, 0
                    ));

                    const displayBkkComponents = getBKKTimeComponents(roundedDateObjectUTC);
                    const formattedDatetime = `${displayBkkComponents.year}/${(displayBkkComponents.month + 1).toString().padStart(2, '0')}/${displayBkkComponents.day.toString().padStart(2, '0')} ${displayBkkComponents.hour.toString().padStart(2, '0')}:${displayBkkComponents.minute.toString().padStart(2, '0')}:00`;

                    globalResults.push({
                        datetime: formattedDatetime,
                        originalWhImportValue: originalWhImportValue,
                        originalWhExportValue: originalWhExportValue,
                        originalVarhValue: originalVarhValue,
                        dateObject: roundedDateObjectUTC,
                        rowMultiplier: rowMultiplier // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ñ‡πà‡∏≤ rowMultiplier ‡πÄ‡∏Ç‡πâ‡∏≤‡πÑ‡∏õ‡πÉ‡∏ô object ‡∏Ç‡∏≠‡∏á‡πÅ‡∏ï‡πà‡∏•‡∏∞‡πÅ‡∏ñ‡∏ß
                    });
                }

                isProcessed = true;
                sortState.columnIndex = null;
                sortState.direction = 'asc';

                populateMonthYearSelector();
                updateDisplay();
            };
            reader.readAsArrayBuffer(file);
        }

        function updateDisplay() {
            if (!isProcessed) {
                return;
            }

            const selectedMonthYear = document.getElementById('monthYearSelector').value;
            const selectedArType = document.getElementById('arTypeSelector').value;
            const selectedUnit = document.getElementById('unitSelector').value;
            const selectedDataType = document.getElementById('dataTypeSelector').value;
            const applyMultiplier = document.getElementById('applyMultiplier').checked;

            console.log(`[updateDisplay] User selected Month/Year: ${selectedMonthYear}, AR Type: ${selectedArType}, Data Type: ${selectedDataType}`);

            const outputDiv = document.getElementById('output');
            outputDiv.innerHTML = '';

            const { monthlySummaries: calculatedMonthlySummaries, monthlyMaxValues: calculatedMonthlyMaxValues } =
                calculateAllMonthsSummariesAndMaxes(selectedArType, selectedDataType);

            monthlySummaries = calculatedMonthlySummaries;
            monthlyMaxValues = calculatedMonthlyMaxValues;

            outputDiv.innerHTML += renderMonthlySummaryTable(monthlySummaries, monthlyMaxValues, selectedDataType);

            const summaryBoxWrapper = document.createElement('div');
            summaryBoxWrapper.className = 'summary-box-wrapper column-layout';

            let multiplierInfoHtml = '<p>‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡∏±‡∏ß‡∏Ñ‡∏π‡∏ì: <strong>N/A</strong></p>';
            if (globalResults.length > 0) {
                const multiplierRanges = {};
                globalResults.forEach(r => {
                    const multiplier = r.rowMultiplier.toFixed(4);
                    const datetime = r.datetime;
                    if (!multiplierRanges[multiplier]) {
                        multiplierRanges[multiplier] = {
                            start: datetime,
                            end: datetime
                        };
                    } else {
                        if (new Date(datetime) < new Date(multiplierRanges[multiplier].start)) {
                            multiplierRanges[multiplier].start = datetime;
                        }
                        if (new Date(datetime) > new Date(multiplierRanges[multiplier].end)) {
                            multiplierRanges[multiplier].end = datetime;
                        }
                    }
                });

                if (Object.keys(multiplierRanges).length > 0) {
                    let rangesHtml = '<ul class="multiplier-list">';
                    for (const mult in multiplierRanges) {
                        if (multiplierRanges.hasOwnProperty(mult)) {
                            const range = multiplierRanges[mult];
                            rangesHtml += `<li><strong>‡∏ï‡∏±‡∏ß‡∏Ñ‡∏π‡∏ì ${mult}</strong><br>‡∏ï‡∏±‡πâ‡∏á‡πÅ‡∏ï‡πà ${range.start}<br>‡∏ñ‡∏∂‡∏á ${range.end}</li>`;
                        }
                    }
                    rangesHtml += '</ul>';
                    multiplierInfoHtml = `<div class="multiplier-info">
                <p><strong>‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡∏±‡∏ß‡∏Ñ‡∏π‡∏ì:</strong></p>
                ${rangesHtml}
            </div>`;
                }
            }

            const meterInfoHtml = `
        <div class="summary-box meter-info">
            <h3>‡∏™‡∏£‡∏∏‡∏õ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏°‡∏¥‡πÄ‡∏ï‡∏≠‡∏£‡πå‡πÅ‡∏•‡∏∞‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏û‡∏•‡∏±‡∏á‡∏á‡∏≤‡∏ô</h3>
            <p>‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏•‡∏Ç‡∏°‡∏¥‡πÄ‡∏ï‡∏≠‡∏£‡πå: <strong>${meterNumber || 'N/A'}</strong></p>
            ${multiplierInfoHtml}
        </div>`;
            summaryBoxWrapper.innerHTML += meterInfoHtml;

            // START: MODIFIED CODE FOR INTERVAL CHECK
            const billingPeriodInfoDiv = document.createElement('div');
            billingPeriodInfoDiv.className = 'summary-box billing-period-info';

            billingPeriodInfoDiv.innerHTML = '<h3>‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• Interval</h3>';

            const uniqueMonthYears = new Set();
            globalResults.forEach(r => {
                const { year, month } = getBKKTimeComponents(r.dateObject);
                uniqueMonthYears.add(`${year}-${(month + 1).toString().padStart(2, '0')}`);
            });

            const sortedUniqueMonthYears = Array.from(uniqueMonthYears).sort();
            const monthNames = ["‡∏°‡∏Å‡∏£‡∏≤‡∏Ñ‡∏°", "‡∏Å‡∏∏‡∏°‡∏†‡∏≤‡∏û‡∏±‡∏ô‡∏ò‡πå", "‡∏°‡∏µ‡∏ô‡∏≤‡∏Ñ‡∏°", "‡πÄ‡∏°‡∏©‡∏≤‡∏¢‡∏ô", "‡∏û‡∏§‡∏©‡∏†‡∏≤‡∏Ñ‡∏°", "‡∏°‡∏¥‡∏ñ‡∏∏‡∏ô‡∏≤‡∏¢‡∏ô", "‡∏Å‡∏£‡∏Å‡∏é‡∏≤‡∏Ñ‡∏°", "‡∏™‡∏¥‡∏á‡∏´‡∏≤‡∏Ñ‡∏°", "‡∏Å‡∏±‡∏ô‡∏¢‡∏≤‡∏¢‡∏ô", "‡∏ï‡∏∏‡∏•‡∏≤‡∏Ñ‡∏°", "‡∏û‡∏§‡∏®‡∏à‡∏¥‡∏Å‡∏≤‡∏¢‡∏ô", "‡∏ò‡∏±‡∏ô‡∏ß‡∏≤‡∏Ñ‡∏°"];

            if (sortedUniqueMonthYears.length > 0) {
                let intervalListHtml = '<ul class="interval-list">';

                sortedUniqueMonthYears.forEach(monthKey => {
                    const [yearStr, monthStr] = monthKey.split('-');
                    const selectedMonthInt = parseInt(monthStr);
                    const selectedYearInt = parseInt(yearStr);
                    const monthName = monthNames[selectedMonthInt - 1];

                    const numDaysInMonth = getDaysInMonth(selectedYearInt, selectedMonthInt);
                    const expectedIntervals = numDaysInMonth * 96;
                    let actualIntervals = 0;

                    globalResults.forEach(r => {
                        if (isInBillingPeriod(r.dateObject, selectedArType, selectedMonthInt, selectedYearInt)) {
                            actualIntervals++;
                        }
                    });

                    const statusClass = actualIntervals < expectedIntervals ? 'warning' : 'complete';
                    const statusText = actualIntervals < expectedIntervals ? '‚ö†Ô∏è' : '‚úÖ';

                    intervalListHtml += `
                <li class="${statusClass}">
                    <strong>‡πÄ‡∏î‡∏∑‡∏≠‡∏ô ${monthName} ${selectedYearInt + 543}:</strong>
                    <span class="count">${actualIntervals} / ${expectedIntervals}</span>
                    <span class="status">${statusText}</span>
                </li>
            `;
                });

                intervalListHtml += '</ul>';
                billingPeriodInfoDiv.innerHTML += intervalListHtml;
            } else {
                billingPeriodInfoDiv.innerHTML += `<p>‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• Interval ‡πÉ‡∏ô‡πÑ‡∏ü‡∏•‡πå</p>`;
            }
            summaryBoxWrapper.appendChild(billingPeriodInfoDiv);
            // END: MODIFIED CODE FOR INTERVAL CHECK

            const consumptionSummaryDiv = document.createElement('div');
            consumptionSummaryDiv.className = 'summary-box consumption-summary';
            let displayPeakWh = 0, displayPeakVarh = 0;
            let displayOffPeakWh = 0, displayOffPeakVarh = 0;
            let displayHolidayWh = 0, displayHolidayVarh = 0;
            let displayTotalWh = 0, displayTotalVarh = 0;
            const decimalPlacesForSummary = 2;

            if (selectedMonthYear !== 'all' && monthlySummaries[selectedMonthYear]) {
                const selectedMonthSummary = monthlySummaries[selectedMonthYear];
                displayPeakWh = selectedMonthSummary['Peak'].wh / 1000;
                displayPeakVarh = selectedMonthSummary['Peak'].varh / 1000;
                displayOffPeakWh = selectedMonthSummary['Off-peak'].wh / 1000;
                displayOffPeakVarh = selectedMonthSummary['Off-peak'].varh / 1000;
                displayHolidayWh = selectedMonthSummary['Holiday'].wh / 1000;
                displayHolidayVarh = selectedMonthSummary['Holiday'].varh / 1000;

                displayTotalWh = displayPeakWh + displayOffPeakWh + displayHolidayWh;
                displayTotalVarh = displayPeakVarh + displayOffPeakVarh + displayHolidayVarh;
            } else if (selectedMonthYear === 'all') {
                for (const monthKey in monthlySummaries) {
                    if (monthlySummaries.hasOwnProperty(monthKey)) {
                        const monthSummary = monthlySummaries[monthKey];
                        displayPeakWh += monthSummary['Peak'].wh / 1000;
                        displayPeakVarh += monthSummary['Peak'].varh / 1000;
                        displayOffPeakWh += monthSummary['Off-peak'].wh / 1000;
                        displayOffPeakVarh += monthSummary['Off-peak'].varh / 1000;
                        displayHolidayWh += monthSummary['Holiday'].wh / 1000;
                        displayHolidayVarh += monthSummary['Holiday'].varh / 1000;
                    }
                }
                displayTotalWh = displayPeakWh + displayOffPeakWh + displayHolidayWh;
                displayTotalVarh = displayPeakVarh + displayOffPeakVarh + displayHolidayVarh;
            }

            const whTitle = selectedDataType === 'wh_import' ? 'kWh (Import)' : 'kWh (Export)';

            consumptionSummaryDiv.innerHTML = `
        <h3>‡∏™‡∏£‡∏∏‡∏õ‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏û‡∏•‡∏±‡∏á‡∏á‡∏≤‡∏ô (‡∏£‡∏ß‡∏°)</h3>
        <div class="summary-list">
            <div class="summary-list-item peak-row">
                <span class="rate-label">‡∏£‡∏ß‡∏° Peak:</span>
                <span class="value-label"><strong>${displayPeakWh.toFixed(decimalPlacesForSummary)} kWh</strong>, <strong>${displayPeakVarh.toFixed(decimalPlacesForSummary)} kVarh</strong></span>
            </div>
            <div class="summary-list-item off-peak-row">
                <span class="rate-label">‡∏£‡∏ß‡∏° Off-peak:</span>
                <span class="value-label"><strong>${displayOffPeakWh.toFixed(decimalPlacesForSummary)} kWh</strong>, <strong>${displayOffPeakVarh.toFixed(decimalPlacesForSummary)} kVarh</strong></span>
            </div>
            <div class="summary-list-item holiday-row">
                <span class="rate-label">‡∏£‡∏ß‡∏° Holiday:</span>
                <span class="value-label"><strong>${displayHolidayWh.toFixed(decimalPlacesForSummary)} kWh</strong>, <strong>${displayHolidayVarh.toFixed(decimalPlacesForSummary)} kVarh</strong></span>
            </div>
            <div class="summary-list-item total-row">
                <span class="rate-label">‡∏£‡∏ß‡∏°‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î:</span>
                <span class="value-label"><strong>${displayTotalWh.toFixed(decimalPlacesForSummary)} kWh</strong>, <strong>${displayTotalVarh.toFixed(decimalPlacesForSummary)} kVarh</strong></span>
            </div>
        </div>
    `;

            summaryBoxWrapper.appendChild(consumptionSummaryDiv);

            outputDiv.appendChild(summaryBoxWrapper);

            outputDiv.innerHTML += renderResultsAsHtml(selectedUnit, selectedMonthYear, selectedArType, selectedDataType);

            updateExportButtonVisibility();
            updateCharts();
        }

        function exportTableToExcel() {
            if (!isProcessed) {
                alert("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå Excel ‡∏Å‡πà‡∏≠‡∏ô‡∏ó‡∏≥‡∏Å‡∏≤‡∏£‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å");
                return;
            }

            const unitType = document.getElementById('unitSelector').value;
            const applyMultiplier = document.getElementById('applyMultiplier').checked;
            const selectedDataType = document.getElementById('dataTypeSelector').value;

            let whUnit, varhUnit;
            let whCalculation, varhCalculation;
            let decimalPlaces;

            if (unitType === 'kw_kvar') {
                whUnit = 'kW';
                varhUnit = 'kVar';
                decimalPlaces = 3;

                whCalculation = (wh_val_raw, mult) => {
                    const roundedWhTimesFour = Math.round(parseFloat(wh_val_raw) * 4);
                    return customRound((roundedWhTimesFour * mult / 1000), decimalPlaces);
                };
                varhCalculation = (varh_val_raw, mult) => {
                    const roundedVarhTimesFour = Math.round(parseFloat(varh_val_raw) * 4);
                    return customRound((roundedVarhTimesFour * mult / 1000), decimalPlaces);
                };
            } else {
                whUnit = selectedDataType === 'wh_import' ? 'Wh Import' : 'Wh Export';
                varhUnit = 'Varh';
                decimalPlaces = 5;

                whCalculation = (wh_val_raw, mult) => {
                    return customRound((parseFloat(wh_val_raw) * mult), decimalPlaces);
                };

                varhCalculation = (varh_val_raw, mult) => {
                    return customRound((parseFloat(varh_val_raw) * mult), decimalPlaces);
                };
            }

            const dataToExport = [];

            dataToExport.push(['‡∏ß‡∏±‡∏ô‡πÄ‡∏ß‡∏•‡∏≤', '‡πÄ‡∏£‡∏ó', whUnit, varhUnit, '‡∏ï‡∏±‡∏ß‡∏Ñ‡∏π‡∏ì']);

            let dataForExport = [];
            const selectedMonthYear = document.getElementById('monthYearSelector').value;
            const selectedArType = document.getElementById('arTypeSelector').value;

            if (selectedMonthYear === 'all') {
                dataForExport = [...globalResults];
            } else {
                const [yearStr, monthStr] = selectedMonthYear.split('-');
                const selectedMonthInt = parseInt(monthStr);
                const selectedYearInt = parseInt(yearStr);

                dataForExport = globalResults.filter(r => {
                    return isInBillingPeriod(r.dateObject, selectedArType, selectedMonthInt, selectedYearInt);
                });
            }

            if (sortState.columnIndex !== null) {
                const directionModifier = sortState.direction === 'asc' ? 1 : -1;
                const selectedUnitForSort = document.getElementById('unitSelector').value;
                const applyMultiplierForSort = document.getElementById('applyMultiplier').checked;

                let whUnitConverterForSort, varhUnitConverterForSort;
                if (selectedUnitForSort === 'kw_kvar') {
                    whUnitConverterForSort = (wh_val, mult) => (Math.round(parseFloat(wh_val) * 4) / 1000) * mult;
                    varhUnitConverterForSort = (varh_val, mult) => (Math.round(parseFloat(varh_val) * 4) / 1000) * mult;
                } else {
                    whUnitConverterForSort = (wh_val, mult) => (parseFloat(wh_val) * mult);
                    varhUnitConverterForSort = (varh_val, mult) => (parseFloat(varh_val) * mult);
                }

                dataForExport.sort((a, b) => {
                    let valA, valB;
                    const multA = applyMultiplierForSort ? a.rowMultiplier : 1;
                    const multB = applyMultiplierForSort ? b.rowMultiplier : 1;
                    let wh_val_A = selectedDataType === 'wh_import' ? a.originalWhImportValue : a.originalWhExportValue;
                    let wh_val_B = selectedDataType === 'wh_import' ? b.originalWhImportValue : b.originalWhExportValue;

                    switch (sortState.columnIndex) {
                        case 0:
                            valA = a.dateObject.getTime();
                            valB = b.dateObject.getTime();
                            break;
                        case 1:
                            valA = getRate(a.dateObject);
                            valB = getRate(b.dateObject);
                            const rateOrder = {
                                'Holiday': 1,
                                'Off-peak': 2,
                                'Peak': 3
                            };
                            return (rateOrder[valA] - rateOrder[valB]) * directionModifier;
                        case 2:
                            valA = whUnitConverterForSort(wh_val_A, multA);
                            valB = whUnitConverterForSort(wh_val_B, multB);
                            break;
                        case 3:
                            valA = varhUnitConverterForSort(a.originalVarhValue, multA);
                            valB = varhUnitConverterForSort(b.originalVarhValue, multB);
                            break;
                        case 4: // Multiplier
                            valA = a.rowMultiplier;
                            valB = b.rowMultiplier;
                            break;
                        default:
                            return 0;
                    }

                    if (typeof valA === 'string') {
                        return valA.localeCompare(valB) * directionModifier;
                    } else {
                        return (valA - valB) * directionModifier;
                    }
                });
            }

            dataForExport.forEach(r => {
                if (!r || !r.dateObject) {
                    console.error("Skipping malformed data row during export:", r);
                    return;
                }

                const wh = selectedDataType === 'wh_import' ? r.originalWhImportValue : r.originalWhExportValue;
                const varh = r.originalVarhValue || 0;

                // ‡πÉ‡∏ä‡πâ‡∏Ñ‡πà‡∏≤ rowMultiplier ‡∏à‡∏≤‡∏Å‡∏≠‡πá‡∏≠‡∏ö‡πÄ‡∏à‡∏Å‡∏ï‡πå‡∏Ç‡∏≠‡∏á‡πÅ‡∏ñ‡∏ß‡∏ô‡∏±‡πâ‡∏ô‡πÜ
                const currentMultiplierForDisplayOrExport = applyMultiplier ? r.rowMultiplier : 1;

                const currentWh = whCalculation(wh, currentMultiplierForDisplayOrExport);
                const currentVarh = varhCalculation(varh, currentMultiplierForDisplayOrExport);

                const rate = getRate(r.dateObject);

                dataToExport.push([
                    r.datetime,
                    rate,
                    currentWh.toFixed(decimalPlaces),
                    currentVarh.toFixed(decimalPlaces),
                    applyMultiplier ? r.rowMultiplier.toFixed(4) : 1
                ]);
            });

            const ws = XLSX.utils.aoa_to_sheet(dataToExport);
            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, "Electric Rates Filtered");

            const now = new Date();
            const day = String(now.getDate()).padStart(2, '0');
            const month = String(now.getMonth() + 1).padStart(2, '0');
            const year = now.getFullYear();
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            const seconds = String(now.getSeconds()).padStart(2, '0');

            const formattedDateTime = `${day}/${month}/${year}_${hours}${minutes}${seconds}`;
            const filename = `${meterNumber || 'N_A'}_${formattedDateTime}.xlsx`;

            XLSX.writeFile(wb, filename);
        }

        document.getElementById('exportExcel').addEventListener('click', exportTableToExcel);

        function updateExportButtonVisibility() {
            const exportButton = document.getElementById('exportExcel');
            if (isProcessed && globalResults.length > 0) {
                exportButton.style.display = 'block';
            } else {
                exportButton.style.display = 'none';
            }
        }
        document.addEventListener('DOMContentLoaded', updateExportButtonVisibility);
    </script>
</body>

</html>
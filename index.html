<!DOCTYPE html>
<html lang="th">

<head>
    <meta charset="UTF-8">
    <title>‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏£‡∏ó‡πÑ‡∏ü‡∏ü‡πâ‡∏≤ (Neumorphism)</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="./holiday_results/holiday_2022.js"></script>
    <script src="./holiday_results/holiday_2023.js"></script>
    <script src="./holiday_results/holiday_2024.js"></script>
    <script src="./holiday_results/holiday_2025.js"></script>
</head>

<body>
    <div class="container">
        <h1>‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏£‡∏ó‡πÑ‡∏ü‡∏ü‡πâ‡∏≤‡∏à‡∏≤‡∏Å‡πÑ‡∏ü‡∏•‡πå Excel</h1>

        <div id="dropArea" class="drop-area">
            <span class="icon">üìÑ</span>
            <p>‡∏•‡∏≤‡∏Å‡πÑ‡∏ü‡∏•‡πå Excel (.xlsx, .xls) ‡∏°‡∏≤‡∏ß‡∏≤‡∏á‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà</p>
            <p>‡∏´‡∏£‡∏∑‡∏≠‡∏Ñ‡∏•‡∏¥‡∏Å‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏ü‡∏•‡πå</p>
            <input type="file" id="excelFile" accept=".xlsx, .xls">
        </div>

        <div class="controls">
            <div class="control-group">
                <label for="monthYearSelector">‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÄ‡∏î‡∏∑‡∏≠‡∏ô:</label>
                <div class="select-wrapper">
                    <select id="monthYearSelector" onchange="updateDisplay()">
                    </select>
                </div>
            </div>

            <div class="control-group">
                <label for="arTypeSelector">‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó AR:</label>
                <div class="select-wrapper">
                    <select id="arTypeSelector" onchange="updateDisplay()">
                        <option value="AR1">AR1</option>
                        <option value="AR6">AR6</option>
                        <option value="HA1">HA1</option>
                    </select>
                </div>
            </div>

            <div class="control-group">
                <label for="unitSelector">‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏´‡∏ô‡πà‡∏ß‡∏¢:</label>
                <div class="select-wrapper">
                    <select id="unitSelector" onchange="updateDisplay()">
                        <option value="kwh_kvarh">kWh, kVarh</option>
                        <option value="kw_kvar">kW, kVar</option>
                    </select>
                </div>
            </div>

            <div class="control-group checkbox-group">
                <input type="checkbox" id="applyMultiplier" onchange="updateDisplay()">
                <label for="applyMultiplier" class="custom-checkbox">
                    ‡∏Ñ‡∏π‡∏ì‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏î‡πâ‡∏ß‡∏¢‡∏ï‡∏±‡∏ß‡∏Ñ‡∏π‡∏ì
                    <span class="icon-checked">‚úî</span> <span class="icon-unchecked"></span> </label>
            </div>

            <div class="control-group">
                <button id="exportExcel" class="button">Export Data to Excel</button>
            </div>
        </div>

        <div id="output"></div>
    </div>

    <script>
        const holidays = new Set();
        let globalResults = [];
        let isProcessed = false; // ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÑ‡∏ü‡∏•‡πå
        let meterNumber = '';
        let multiplier = 0;

        // *** ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡∏≠‡∏á monthlySummaries ‡πÅ‡∏•‡∏∞ monthlyMaxValues ***
        let monthlySummaries = {}; // ‡πÄ‡∏Å‡πá‡∏ö‡∏ú‡∏•‡∏£‡∏ß‡∏° kWh, kVarh ‡∏£‡∏≤‡∏¢‡πÄ‡∏î‡∏∑‡∏≠‡∏ô (‡∏´‡∏•‡∏±‡∏á‡∏Ñ‡∏π‡∏ì‡∏ï‡∏±‡∏ß‡∏Ñ‡∏π‡∏ì)
        let monthlyMaxValues = {}; // ‡πÄ‡∏Å‡πá‡∏ö‡∏Ñ‡πà‡∏≤‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î kW, kVar ‡∏£‡∏≤‡∏¢‡πÄ‡∏î‡∏∑‡∏≠‡∏ô (‡∏´‡∏•‡∏±‡∏á‡∏Ñ‡∏π‡∏ì‡∏ï‡∏±‡∏ß‡∏Ñ‡∏π‡∏ì)
        // *************************************************************

        let sortState = {
            columnIndex: null,
            direction: 'asc'
        };

        const dropArea = document.getElementById('dropArea');
        const excelFileInput = document.getElementById('excelFile');

        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropArea.addEventListener(eventName, preventDefaults, false);
            document.body.addEventListener(eventName, preventDefaults, false);
        });

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        ['dragenter', 'dragover'].forEach(eventName => {
            dropArea.addEventListener(eventName, () => dropArea.classList.add('drag-over'), false);
        });

        ['dragleave', 'drop'].forEach(eventName => {
            dropArea.addEventListener(eventName, () => dropArea.classList.remove('drag-over'), false);
        });

        dropArea.addEventListener('drop', handleDrop, false);

        function handleDrop(e) {
            const dt = e.dataTransfer;
            const files = dt.files;

            if (files.length > 0) {
                // ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï isProcessed ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏•‡∏≤‡∏Å‡πÑ‡∏ü‡∏•‡πå‡πÉ‡∏´‡∏°‡πà
                isProcessed = false;
                excelFileInput.files = files;
                process();
            }
        }

        dropArea.addEventListener('click', () => {
            excelFileInput.click();
        });

        excelFileInput.addEventListener('change', () => {
            if (excelFileInput.files.length > 0) {
                // ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï isProcessed ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏ü‡∏•‡πå‡πÉ‡∏´‡∏°‡πà
                isProcessed = false;
                process();
            }
        });

        // Helper function to extract BKK time components from a UTC-adjusted Date object.
        // It assumes the input utcDateObj has already been adjusted to reflect BKK time
        // in its UTC components.
        function getBKKTimeComponents(utcDateObj) {
            return {
                hour: utcDateObj.getUTCHours(),
                minute: utcDateObj.getUTCMinutes(),
                second: utcDateObj.getUTCSeconds(),
                day: utcDateObj.getUTCDate(),
                month: utcDateObj.getUTCMonth(), // 0-indexed
                year: utcDateObj.getUTCFullYear(),
                dayOfWeek: utcDateObj.getUTCDay() // BKK day of week (0=Sun, 6=Sat)
            };
        }

        // Helper function to get a Date object representing midnight of a calendar day in BKK timezone.
        // The returned Date object's UTC components will *directly* represent BKK midnight.
        function getBKKMidnightUTCAdjusted(year, monthIndex, day) { // monthIndex is 0-indexed
            // Create a Date object where its UTC components directly represent BKK midnight for the given day.
            const d = new Date(Date.UTC(year, monthIndex, day, 0, 0, 0));
            return d;
        }

        // ******** ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏õ‡∏•‡∏á Excel Date ‡πÄ‡∏õ‡πá‡∏ô BKK Time ‡πÉ‡∏ô‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö UTC-adjusted (‡∏à‡∏∏‡∏î‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏ó‡∏µ‡πà‡∏õ‡∏£‡∏±‡∏ö) ********
        function convertExcelDateToBKKUTCAdjusted(rawDate) {
            let dateObj;
            const bkkOffsetMs = 7 * 60 * 60 * 1000; // 7 hours in milliseconds

            if (rawDate instanceof Date) {
                // ‡∏´‡∏≤‡∏Å‡πÄ‡∏õ‡πá‡∏ô Date object ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß (‡∏≠‡∏≤‡∏à‡∏°‡∏≤‡∏à‡∏≤‡∏Å cellDates: true)
                // Date object ‡∏ô‡∏µ‡πâ‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÇ‡∏î‡∏¢ XLSX library ‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ‡πÄ‡∏ß‡∏•‡∏≤‡∏ó‡πâ‡∏≠‡∏á‡∏ñ‡∏¥‡πà‡∏ô‡∏Ç‡∏≠‡∏á‡∏£‡∏∞‡∏ö‡∏ö‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡∏¥‡∏î‡πÑ‡∏ü‡∏•‡πå
                // ‡πÄ‡∏£‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÉ‡∏´‡πâ UTC components ‡∏Ç‡∏≠‡∏á‡∏°‡∏±‡∏ô‡πÄ‡∏õ‡πá‡∏ô BKK Time
                // ‡∏à‡∏∂‡∏á‡πÄ‡∏û‡∏¥‡πà‡∏° offset ‡∏Ç‡∏≠‡∏á BKK (7 ‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á) ‡πÑ‡∏õ‡∏ó‡∏µ‡πà timestamp ‡∏Ç‡∏≠‡∏á‡∏°‡∏±‡∏ô‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á
                dateObj = new Date(rawDate.getTime() + bkkOffsetMs);
            } else if (typeof rawDate === 'number') {
                // ‡∏´‡∏≤‡∏Å‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç‡∏à‡∏≤‡∏Å Excel (serial date)
                const parsed = XLSX.SSF.parse_date_code(rawDate);
                // XLSX.SSF.parse_date_code ‡∏à‡∏∞‡∏Ñ‡∏∑‡∏ô‡∏Ñ‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô y, m, d, H, M, S ‡∏ó‡∏µ‡πà "‡πÄ‡∏õ‡πá‡∏ô‡∏Å‡∏•‡∏≤‡∏á" (‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏ö‡∏≠‡∏Å‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô UTC ‡∏´‡∏£‡∏∑‡∏≠ Local)
                // ‡πÄ‡∏£‡∏≤‡∏à‡∏∞‡∏ñ‡∏∑‡∏≠‡∏ß‡πà‡∏≤‡∏Ñ‡πà‡∏≤‡πÄ‡∏´‡∏•‡πà‡∏≤‡∏ô‡∏µ‡πâ‡∏Ñ‡∏∑‡∏≠ BKK Time ‡πÅ‡∏•‡∏∞‡∏™‡∏£‡πâ‡∏≤‡∏á Date.UTC() ‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á
                // ‡∏ó‡∏≥‡πÉ‡∏´‡πâ UTC components ‡∏Ç‡∏≠‡∏á dateObj ‡πÅ‡∏ó‡∏ô BKK Time ‡∏ó‡∏±‡∏ô‡∏ó‡∏µ
                dateObj = new Date(Date.UTC(parsed.y, parsed.m - 1, parsed.d, parsed.H, parsed.M, parsed.S));
            } else if (typeof rawDate === 'string') {
                // ‡∏´‡∏≤‡∏Å‡πÄ‡∏õ‡πá‡∏ô String
                const match = rawDate.match(/(\d{1,2})\/(\d{1,2})\/(\d{4})\s*(\d{1,2}):(\d{2}):(\d{2})|(\d{4})-(\d{1,2})-(\d{1,2})T(\d{1,2}):(\d{2}):(\d{2})/);
                if (match) {
                    let year, month, day, hour, minute, second;
                    if (match[1]) { // DD/MM/YYYY HH:mm:ss format
                        [, day, month, year, hour, minute, second] = match;
                        year = parseInt(year) > 2500 ? parseInt(year) - 543 : parseInt(year); // Convert Buddhist year to AD
                    } else if (match[7]) { // YYYY-MM-DDTHH:mm:ss format
                        [, , , , , , year, month, day, hour, minute, second] = match;
                    }
                    // ‡∏ñ‡∏∑‡∏≠‡∏ß‡πà‡∏≤ string components ‡πÄ‡∏´‡∏•‡πà‡∏≤‡∏ô‡∏µ‡πâ‡∏Ñ‡∏∑‡∏≠ BKK Time ‡πÅ‡∏•‡∏∞‡∏™‡∏£‡πâ‡∏≤‡∏á Date.UTC() ‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á
                    dateObj = new Date(Date.UTC(parseInt(year), parseInt(month) - 1, parseInt(day), parseInt(hour), parseInt(minute), parseInt(second)));
                } else {
                    // ‡∏Å‡∏£‡∏ì‡∏µ string format ‡∏≠‡∏∑‡πà‡∏ô‡πÜ (‡∏≠‡∏≤‡∏à‡πÄ‡∏õ‡πá‡∏ô ISO 8601 ‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏°‡∏µ Z ‡∏´‡∏£‡∏∑‡∏≠ Time Zone offset)
                    // ‡∏•‡∏≠‡∏á‡πÉ‡∏´‡πâ Date constructor ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ ‡∏ã‡∏∂‡πà‡∏á‡∏°‡∏±‡∏Å‡∏à‡∏∞‡∏ï‡∏µ‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏õ‡πá‡∏ô Local Time ‡∏Ç‡∏≠‡∏á‡∏£‡∏∞‡∏ö‡∏ö
                    let tempDate = new Date(rawDate);
                    if (!isNaN(tempDate.getTime())) { // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ parse ‡πÑ‡∏î‡πâ‡∏à‡∏£‡∏¥‡∏á
                        // ‡πÄ‡∏û‡∏¥‡πà‡∏° offset ‡∏Ç‡∏≠‡∏á BKK (7 ‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á) ‡πÑ‡∏õ‡∏ó‡∏µ‡πà timestamp ‡∏Ç‡∏≠‡∏á‡∏°‡∏±‡∏ô‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á
                        dateObj = new Date(tempDate.getTime() + bkkOffsetMs);
                    } else {
                        return null; // parse ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ
                    }
                }
            } else {
                return null; // ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏ó‡∏µ‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö
            }

            return isNaN(dateObj.getTime()) ? null : dateObj;
        }
        // ******************************************************************************

        function collectHolidays() {
            holidays.clear();
            const allHolidayVars = [
                typeof holiday_2022 !== 'undefined' ? holiday_2022 : null,
                typeof holiday_2023 !== 'undefined' ? holiday_2023 : null,
                typeof holiday_2024 !== 'undefined' ? holiday_2024 : null,
                typeof holiday_2025 !== 'undefined' ? holiday_2025 : null
            ];
            allHolidayVars.forEach(data => {
                if (!data || !data.data) return;
                data.data.forEach(entry => {
                    if (entry.tou === 1 && entry.holiday) {
                        const [d, m, byear] = entry.holiday.split('/');
                        const year = parseInt(byear) - 543;

                        // Create a Date object representing the holiday at midnight in BKK timezone (UTC components match BKK)
                        const bkkHolidayMidnight = getBKKMidnightUTCAdjusted(year, parseInt(m) - 1, parseInt(d));

                        // Store its ISO string (which will correctly be YYYY-MM-DD from UTC components matching BKK)
                        const isoDate = bkkHolidayMidnight.toISOString().split('T')[0];
                        holidays.add(isoDate);
                    }
                });
            });
        }

        function isHoliday(date) {
            // date is a UTC-adjusted Date object (its UTC components reflect BKK time)
            let checkDate = new Date(date.getTime()); // Create a copy to avoid modifying original

            const bkkComponents = getBKKTimeComponents(checkDate); // Get BKK components from the UTC-adjusted date
            let hour = bkkComponents.hour;
            let min = bkkComponents.minute;

            if (hour === 0 && min < 15) {
                // If the BKK time is between 00:00 and 00:14,
                // adjust the date backwards by one BKK day (by adjusting UTC components).
                checkDate.setUTCHours(checkDate.getUTCHours() - 24);
            }

            // Convert to YYYY-MM-DD for holiday set lookup
            const finalBkkComponents = getBKKTimeComponents(checkDate);
            const iso = finalBkkComponents.year + '-' +
                String(finalBkkComponents.month + 1).padStart(2, '0') + '-' +
                String(finalBkkComponents.day).padStart(2, '0');
            return holidays.has(iso);
        }

        function getRate(date) {
            // date is a UTC-adjusted Date object (its UTC components reflect BKK time)
            let checkDate = new Date(date.getTime()); // Create a copy to avoid modifying original

            const bkkComponents = getBKKTimeComponents(checkDate); // Get BKK components from the UTC-adjusted date
            let hour = bkkComponents.hour;
            let min = bkkComponents.minute;

            // If time is 00:00 to 00:14, consider it part of the previous day
            if (hour === 0 && min < 15) {
                // Adjust the date backwards by one BKK day for rate calculation
                checkDate.setUTCHours(checkDate.getUTCHours() - 24);
                // Re-calculate hour/min from the adjusted date for rate logic
                const adjustedBkkComponents = getBKKTimeComponents(checkDate);
                hour = adjustedBkkComponents.hour;
                min = adjustedBkkComponents.minute;
            }

            const day = getBKKTimeComponents(checkDate).dayOfWeek; // Get BKK day of week (0=‡∏≠‡∏≤‡∏ó‡∏¥‡∏ï‡∏¢‡πå, 6=‡πÄ‡∏™‡∏≤‡∏£‡πå)
            if (isHoliday(date) || day === 0 || day === 6) {
                return 'Holiday';
            }

            const totalMin = hour * 60 + min;
            const peakStart = 9 * 60 + 15; // 09:15
            const peakEnd = 22 * 60; // 22:00

            if (totalMin >= peakStart && totalMin <= peakEnd) {
                return 'Peak';
            } else {
                return 'Off-peak';
            }
        }

        // Helper function to get the number of days in a month
        // month is 1-indexed (1=Jan, 12=Dec)
        function getDaysInMonth(year, month) {
            // month + 1 as new Date(year, month, 0) gives last day of previous month for 0-indexed month
            // So, new Date(year, month, 0) will give the last day of the 'month' parameter
            return new Date(Date.UTC(year, month, 0)).getUTCDate();
        }


        // Modified getReadingDay to calculate based on days in month
        function getReadingDay(year, month, arType) { // month is 1-indexed here (1-12)
            const numDaysInMonth = getDaysInMonth(year, month); // Get days for the given month

            if (arType === 'AR1') {
                // If the month has 31 days -> 31 - 10 = 21
                // If the month has 30 days -> 30 - 10 = 20
                // If the month has 28 days (Feb) -> 28 - 10 = 18
                // If the month has 29 days (Leap Feb) -> 29 - 10 = 19
                return numDaysInMonth - 10;
            } else if (arType === 'AR6') {
                // If the month has 31 days -> 31 - 2 = 29
                // If the month has 30 days -> 30 - 2 = 28
                // If the month has 28 days (Feb) -> 28 - 2 = 26
                // If the month has 29 days (Leap Feb) -> 29 - 2 = 27
                return numDaysInMonth - 2;
            } else if (arType === 'HA1') {
                return 1; // Fixed to 1st of the month
            }
            console.error(`[getReadingDay] Unknown AR Type: ${arType}`);
            return -1; // Should not happen
        }

        function isInBillingPeriod(dateObject, arType, selectedMonth, selectedYear) {
            // dateObject is `roundedDateObjectUTC`, which has its UTC components
            // already adjusted to represent BKK time.

            let billingPeriodStartDate, billingPeriodEndDate;

            if (arType === 'HA1') {
                // For HA1, billing period is from 00:15 of the 1st of selectedMonth
                // to 00:00 of the 1st of the NEXT month.

                billingPeriodStartDate = getBKKMidnightUTCAdjusted(selectedYear, selectedMonth - 1, 1); // 1st of selected month
                billingPeriodStartDate.setMinutes(billingPeriodStartDate.getMinutes() + 15);

                let nextMonth = selectedMonth + 1;
                let nextMonthYear = selectedYear;
                if (nextMonth > 12) {
                    nextMonth = 1;
                    nextMonthYear++;
                }
                billingPeriodEndDate = getBKKMidnightUTCAdjusted(nextMonthYear, nextMonth - 1, 1); // 1st of next month

            } else {
                // Existing logic for AR1 and AR6
                // Determine the month and year for the *previous* reading
                let prevReadingMonth = selectedMonth - 1; // 1-indexed month
                let prevReadingYear = selectedYear;
                if (prevReadingMonth === 0) { // If current month is January, previous is December of last year
                    prevReadingMonth = 12;
                    prevReadingYear--;
                }

                // Determine the reading day for the previous month based on its number of days
                const prevReadingDay = getReadingDay(prevReadingYear, prevReadingMonth, arType);
                if (prevReadingDay === -1) {
                    console.warn(`[isInBillingPeriod] Could not determine prevReadingDay for ${prevReadingYear}-${prevReadingMonth}`);
                    return false;
                }

                // Calculate the start date of the billing period
                // It's the previous month's reading date at 00:15:00 BKK (UTC components match BKK)
                billingPeriodStartDate = getBKKMidnightUTCAdjusted(prevReadingYear, prevReadingMonth - 1, prevReadingDay); // monthIndex is 0-indexed for getBKKMidnightUTCAdjusted
                billingPeriodStartDate.setMinutes(billingPeriodStartDate.getMinutes() + 15);


                // Determine the reading day for the *current* billing month based on its number of days
                const currentReadingDay = getReadingDay(selectedYear, selectedMonth, arType);
                if (currentReadingDay === -1) {
                    console.warn(`[isInBillingPeriod] Could not determine currentReadingDay for ${selectedYear}-${selectedMonth}`);
                    return false;
                }

                // Calculate the end date of the billing period
                // It's the current month's reading date at 00:00:00 BKK (of the *next* day) (UTC components match BKK)
                thisMonthReadingDate = getBKKMidnightUTCAdjusted(selectedYear, selectedMonth - 1, currentReadingDay); // monthIndex is 0-indexed
                billingPeriodEndDate = new Date(thisMonthReadingDate.getTime()); // Copy the date
                billingPeriodEndDate.setUTCHours(0); // Set to midnight of the reading day itself
                billingPeriodEndDate.setUTCMinutes(0);
                billingPeriodEndDate.setUTCSeconds(0);
                // The current logic of checking <= dateObject.getTime() for end date automatically includes
                // data up to 24:00:00 of the reading day (which is 00:00:00 of the next day)
                // So, if reading day is 21st, data up to 21st 24:00 (i.e., 22nd 00:00) is included.
                // This seems consistent with the original intent.
            }

            // LOG: Check calculated startDate and endDate.
            // console.log(`[isInBillingPeriod] Comparing: Date: ${dateObject.toISOString()} vs Start: ${billingPeriodStartDate.toISOString()} End: ${billingPeriodEndDate.toISOString()}`);

            // CHANGE: Changed from < to <= to include the exact 00:00:00 of the next day.
            // For HA1, this means data up to 00:00:00 of the 1st of the next month (exclusive of 00:15)
            // For AR1/AR6, data up to 00:00:00 of the day *after* the reading day is included
            return dateObject.getTime() >= billingPeriodStartDate.getTime() && dateObject.getTime() <= billingPeriodEndDate.getTime();
        }

        function sortTable(columnIndex) {
            if (!isProcessed) return;

            if (sortState.columnIndex === columnIndex) {
                sortState.direction = sortState.direction === 'asc' ? 'desc' : 'asc';
            } else {
                sortState.columnIndex = columnIndex;
                if (columnIndex === 0) { // Datetime
                    sortState.direction = 'asc';
                } else if (columnIndex === 1) { // Rate
                    sortState.direction = 'asc';
                } else { // Numeric columns
                    sortState.direction = 'desc';
                }
            }

            updateDisplay(); // Re-render the detailed table after sorting
        }

        function customRound(value, decimalPlaces) {
            const factor = Math.pow(10, decimalPlaces);
            return Math.round(value * factor) / factor;
        }

        // Renamed and modified function to populate only Month and Year
        function populateMonthYearSelector() {
            const selector = document.getElementById('monthYearSelector');
            selector.innerHTML = ''; // Clear existing options

            const monthNames = ["‡∏°‡∏Å‡∏£‡∏≤‡∏Ñ‡∏°", "‡∏Å‡∏∏‡∏°‡∏†‡∏≤‡∏û‡∏±‡∏ô‡∏ò‡πå", "‡∏°‡∏µ‡∏ô‡∏≤‡∏Ñ‡∏°", "‡πÄ‡∏°‡∏©‡∏≤‡∏¢‡∏ô", "‡∏û‡∏§‡∏©‡∏†‡∏≤‡∏Ñ‡∏°", "‡∏°‡∏¥‡∏ñ‡∏∏‡∏ô‡∏≤‡∏¢‡∏ô", "‡∏Å‡∏£‡∏Å‡∏é‡∏≤‡∏Ñ‡∏°", "‡∏™‡∏¥‡∏á‡∏´‡∏≤‡∏Ñ‡∏°", "‡∏Å‡∏±‡∏ô‡∏¢‡∏≤‡∏¢‡∏ô", "‡∏ï‡∏∏‡∏•‡∏≤‡∏Ñ‡∏°", "‡∏û‡∏§‡∏®‡∏à‡∏¥‡∏Å‡∏≤‡∏¢‡∏ô", "‡∏ò‡∏±‡∏ô‡∏ß‡∏≤‡∏Ñ‡∏°"];

            // Collect unique year-month combinations from globalResults
            const uniqueMonthYears = new Set(); // Stores as "YYYY-MM" (e.g., "2024-05")
            globalResults.forEach(r => {
                const {
                    year,
                    month
                } = getBKKTimeComponents(r.dateObject); // month is 0-indexed
                uniqueMonthYears.add(`${year}-${(month + 1).toString().padStart(2, '0')}`); // Store as YYYY-MM
            });

            // Sort unique periods chronologically
            const sortedUniqueMonthYears = Array.from(uniqueMonthYears).sort();

            // Add 'All Data' option
            const allOption = document.createElement('option');
            allOption.value = 'all';
            allOption.textContent = '‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î';
            selector.appendChild(allOption);

            // Add options for each unique month and year
            sortedUniqueMonthYears.forEach(periodStr => {
                const [yearStr, monthStr] = periodStr.split('-');
                const year = parseInt(yearStr);
                const month = parseInt(monthStr); // 1-indexed month

                const option = document.createElement('option');
                option.value = `${year}-${month.toString().padStart(2, '0')}`; // Value as "YYYY-MM"
                option.textContent = `${monthNames[month - 1]} ${year + 543}`; // Display as Thai month and Buddhist year
                selector.appendChild(option);
            });

            // Set the default selected month to the latest month available
            if (sortedUniqueMonthYears.length > 0) {
                selector.value = sortedUniqueMonthYears[sortedUniqueMonthYears.length - 1];
            }
        }


        // Helper function to calculate billing period start and end dates
        function getBillingPeriodDates(selectedYear, selectedMonth, arType) {
            let billingPeriodStartDate, billingPeriodEndDate;

            if (arType === 'HA1') {
                // HA1: From 00:15 of the 1st of selectedMonth to 00:00 of the 1st of the NEXT month.
                billingPeriodStartDate = getBKKMidnightUTCAdjusted(selectedYear, selectedMonth - 1, 1); // 1st of selected month
                billingPeriodStartDate.setMinutes(billingPeriodStartDate.getMinutes() + 15);

                let nextMonth = selectedMonth + 1;
                let nextMonthYear = selectedYear;
                if (nextMonth > 12) {
                    nextMonth = 1;
                    nextMonthYear++;
                }
                billingPeriodEndDate = getBKKMidnightUTCAdjusted(nextMonthYear, nextMonth - 1, 1); // 1st of next month

            } else {
                // Existing logic for AR1 and AR6
                // Determine the month and year for the *previous* reading
                let prevReadingMonth = selectedMonth - 1; // 1-indexed month
                let prevReadingYear = selectedYear;
                if (prevReadingMonth === 0) { // If current month is January, previous is December of last year
                    prevReadingMonth = 12;
                    prevReadingYear--;
                }

                // Determine the reading day for the previous month based on its number of days
                const prevReadingDay = getReadingDay(prevReadingYear, prevReadingMonth, arType);
                if (prevReadingDay === -1) {
                    console.error(`[getBillingPeriodDates] Failed to get previous reading day for ${prevReadingYear}-${prevReadingMonth}`);
                    return {
                        startDate: null,
                        endDate: null
                    };
                }

                // Calculate the start date of the billing period
                // It's the previous month's reading date at 00:15:00 BKK (UTC components match BKK)
                billingPeriodStartDate = getBKKMidnightUTCAdjusted(prevReadingYear, prevReadingMonth - 1, prevReadingDay); // monthIndex is 0-indexed for getBKKMidnightUTCAdjusted
                billingPeriodStartDate.setMinutes(billingPeriodStartDate.getMinutes() + 15);


                // Determine the reading day for the *current* billing month based on its number of days
                const currentReadingDay = getReadingDay(selectedYear, selectedMonth, arType);
                if (currentReadingDay === -1) {
                    console.error(`[getBillingPeriodDates] Could not determine currentReadingDay for ${selectedYear}-${selectedMonth}`);
                    return {
                        startDate: null,
                        endDate: null
                    };
                }

                // Calculate the end date of the billing period
                // It's the current month's reading date at 00:00:00 BKK (of the *next* day) (UTC components match BKK)
                thisMonthReadingDate = getBKKMidnightUTCAdjusted(selectedYear, selectedMonth - 1, currentReadingDay); // monthIndex is 0-indexed
                billingPeriodEndDate = new Date(thisMonthReadingDate.getTime()); // Copy the date
                billingPeriodEndDate.setUTCHours(0); // Set to midnight of the reading day itself
                billingPeriodEndDate.setUTCMinutes(0);
                billingPeriodEndDate.setUTCSeconds(0);
            }

            return {
                startDate: billingPeriodStartDate,
                endDate: billingPeriodEndDate
            };
        }


        function renderMonthlySummaryTable() {
            if (!isProcessed || Object.keys(monthlySummaries).length === 0) {
                return ''; // Don't render if no data or not processed
            }

            let monthlyTableHtml = `
                <div class="summary-section">
                <h2 class="section-title">‡∏™‡∏£‡∏∏‡∏õ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏û‡∏•‡∏±‡∏á‡∏á‡∏≤‡∏ô‡∏£‡∏≤‡∏¢‡πÄ‡∏î‡∏∑‡∏≠‡∏ô</h2>
                <div class="monthly-summary-table-container">
                <table>
                    <thead>
                        <tr>
                            <th>‡πÄ‡∏î‡∏∑‡∏≠‡∏ô/‡∏õ‡∏µ</th>
                            <th>kWh (‡∏£‡∏ß‡∏°)</th>
                            <th>kWh (Peak)</th>
                            <th>kWh (Off-Peak)</th>
                            <th>kWh (Holiday)</th>
                            <th>kVarh (‡∏£‡∏ß‡∏°‡∏ó‡∏±‡πâ‡∏á‡∏™‡∏≤‡∏°‡πÄ‡∏£‡∏ó)</th>
                            <th>kW Max(Peak)</th>
                            <th>kW Max(Off-Peak)</th>
                            <th>kW Max(Holiday)</th>
                            <th>kVar Max(‡∏£‡∏ß‡∏°‡∏ó‡∏∏‡∏Å‡πÄ‡∏£‡∏ó)</th>
                            <th>‡πÄ‡∏ß‡∏•‡∏≤ kW (peak) ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î</th>
                            <th>‡πÄ‡∏ß‡∏•‡∏≤ kW (Off-Peak) ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î</th>
                            <th>‡πÄ‡∏ß‡∏•‡∏≤ kW (Holiday) ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            const monthNames = ["‡∏°.‡∏Ñ.", "‡∏Å.‡∏û.", "‡∏°‡∏µ.‡∏Ñ.", "‡πÄ‡∏°.‡∏¢.", "‡∏û.‡∏Ñ.", "‡∏°‡∏¥.‡∏¢.", "‡∏Å.‡∏Ñ.", "‡∏™.‡∏Ñ.", "‡∏Å.‡∏¢.", "‡∏ï.‡∏Ñ.", "‡∏û.‡∏¢.", "‡∏ò.‡∏Ñ."];
            const sortedMonthKeys = Object.keys(monthlySummaries).sort();

            const applyMultiplierCheckbox = document.getElementById('applyMultiplier');
            const applyMultiplierToSummary = applyMultiplierCheckbox ? applyMultiplierCheckbox.checked : false;
            const currentMultiplierForSummary = applyMultiplierToSummary ? multiplier : 1;


            sortedMonthKeys.forEach(monthKey => {
                const [yearStr, monthStr] = monthKey.split('-');
                const year = parseInt(yearStr);
                const monthIndex = parseInt(monthStr) - 1; // 0-indexed month

                const currentMonthSummary = monthlySummaries[monthKey]; // RAW kWh, kVarh sums
                const currentMonthMax = monthlyMaxValues[monthKey];   // RAW Max kW, kVar values

                // Apply multiplier at display time
                const displayTotalWhMonth = (currentMonthSummary['Peak'].wh + currentMonthSummary['Off-peak'].wh + currentMonthSummary['Holiday'].wh) * currentMultiplierForSummary;
                const displayTotalVarhMonth = (currentMonthSummary['Peak'].varh + currentMonthSummary['Off-peak'].varh + currentMonthSummary['Holiday'].varh) * currentMultiplierForSummary;

                const displayPeakWh = currentMonthSummary['Peak'].wh * currentMultiplierForSummary;
                const displayOffPeakWh = currentMonthSummary['Off-peak'].wh * currentMultiplierForSummary;
                const displayHolidayWh = currentMonthSummary['Holiday'].wh * currentMultiplierForSummary;

                const displayPeakKw = currentMonthMax['Peak'].wh * currentMultiplierForSummary;
                const displayOffPeakKw = currentMonthMax['Off-peak'].wh * currentMultiplierForSummary;
                const displayHolidayKw = currentMonthMax['Holiday'].wh * currentMultiplierForSummary;

                // Find overall max RAW kVar for the month across all rates
                let rawMaxKvarMonthOverall = 0;
                ['Peak', 'Off-peak', 'Holiday'].forEach(rate => {
                    if (currentMonthMax[rate].varh > rawMaxKvarMonthOverall) {
                        rawMaxKvarMonthOverall = currentMonthMax[rate].varh;
                    }
                });
                const displayMaxKvarMonthOverall = rawMaxKvarMonthOverall * currentMultiplierForSummary;


                monthlyTableHtml += `
                    <tr>
                        <td>${monthNames[monthIndex]} ${year + 543}</td>
                        <td>${displayTotalWhMonth.toFixed(2)}</td>
                        <td>${displayPeakWh.toFixed(2)}</td>
                        <td>${displayOffPeakWh.toFixed(2)}</td>
                        <td>${displayHolidayWh.toFixed(2)}</td>
                        <td>${displayTotalVarhMonth.toFixed(2)}</td>
                        <td>${displayPeakKw.toFixed(3)}</td>
                        <td>${displayOffPeakKw.toFixed(3)}</td>
                        <td>${displayHolidayKw.toFixed(3)}</td>
                        <td>${displayMaxKvarMonthOverall.toFixed(3)}</td>
                        <td><small>${currentMonthMax['Peak'].wh_datetime || 'N/A'}</small></td>
                        <td><small>${currentMonthMax['Off-peak'].wh_datetime || 'N/A'}</small></td>
                        <td><small>${currentMonthMax['Holiday'].wh_datetime || 'N/A'}</small></td>
                    </tr>
                `;
            });

            monthlyTableHtml += `
                    </tbody>
                </table>
                </div>
                </div>
            `;
            return monthlyTableHtml;
        }


        // Modified renderResults to accept selectedMonthYear and selectedArType
        // Renamed to renderResultsAsHtml to return HTML string
        function renderResultsAsHtml(unitType, selectedMonthYear, selectedArType) {
            if (!isProcessed) return ''; // Return empty string if not processed

            let whUnit, varhUnit;
            const applyMultiplier = document.getElementById('applyMultiplier').checked;
            const currentMultiplier = applyMultiplier ? multiplier : 1;

            let whCalculation, varhCalculation;
            let decimalPlacesForSummary; // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡∏£‡∏∏‡∏õ‡∏Ñ‡πà‡∏≤ kW/kVar ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î ‡πÅ‡∏•‡∏∞ kWh/kVarh ‡∏£‡∏ß‡∏°
            const decimalPlacesForKwKvarTable = 6; // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö kW/kVar ‡πÉ‡∏ô‡∏ï‡∏≤‡∏£‡∏≤‡∏á 6 ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á

            if (unitType === 'kw_kvar') {
                whUnit = 'kW';
                varhUnit = 'kVar';
                decimalPlacesForSummary = 3; // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡∏£‡∏∏‡∏õ kW/kVar ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î ‡∏¢‡∏±‡∏á‡∏Ñ‡∏á 3 ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á

                whCalculation = (wh_val) => {
                    let baseKw = (parseFloat(wh_val) * 4 / 1000);
                    if (applyMultiplier) {
                        return baseKw * currentMultiplier;
                    }
                    return baseKw;
                };
                varhCalculation = (varh_val) => {
                    let baseKvar = (parseFloat(varh_val) * 4 / 1000);
                    if (applyMultiplier) {
                        return baseKvar * currentMultiplier;
                    }
                    return baseKvar;
                };
            } else { // kWh, kVarh
                whUnit = 'kWh';
                varhUnit = 'kVarh';
                decimalPlacesForSummary = 2; // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö kWh/kVarh ‡∏£‡∏ß‡∏° ‡∏¢‡∏±‡∏á‡∏Ñ‡∏á 2 ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á

                whCalculation = (wh_val) => {
                    const raw = (parseFloat(wh_val) / 1000);
                    const valueToRound = raw * currentMultiplier;
                    return parseFloat((valueToRound + Number.EPSILON).toFixed(decimalPlacesForSummary));
                };

                varhCalculation = (varh_val) => {
                    const raw = (parseFloat(varh_val) / 1000);
                    const valueToRound = raw * currentMultiplier;
                    return parseFloat((valueToRound + Number.EPSILON).toFixed(decimalPlacesForSummary));
                };
            }

            let tableRowsHtml = '';

            // --- START: New variables to track MAX RAW values and their datetimes ---
            // These will ONLY store the raw WH/VARHIMP Total values
            let maxRawWhValues = {
                'Peak': { value: 0, datetime: '' },
                'Off-peak': { value: 0, datetime: '' },
                'Holiday': { value: 0, datetime: '' }
            };
            let maxRawVarhValues = {
                'Peak': { value: 0, datetime: '', },
                'Off-peak': { value: 0, datetime: '' },
                'Holiday': { value: 0, datetime: '' }
            };
            let overallMaxRawWh = { value: 0, datetime: '' };
            let overallMaxRawVarh = { value: 0, datetime: '' };
            // --- END: New variables to track MAX RAW values and their datetimes ---


            // New summary variables for total consumption (these accumulate already processed values)
            let totalWhConsumption = {
                'Peak': 0,
                'Off-peak': 0,
                'Holiday': 0
            };
            let totalVarhConsumption = {
                'Peak': 0,
                'Off-peak': 0,
                'Holiday': 0
            };

            let filteredResults = [];
            if (selectedMonthYear === 'all') { // If "All Data" is selected for month/year
                filteredResults = [...globalResults];
            } else {
                const [yearStr, monthStr] = selectedMonthYear.split('-');
                const selectedMonthInt = parseInt(monthStr); // 1-indexed
                const selectedYearInt = parseInt(yearStr); // AD year

                filteredResults = globalResults.filter(r => {
                    // Filter by selected AR Type explicitly and by selected Month/Year
                    const isWithinBillingPeriod = isInBillingPeriod(r.dateObject, selectedArType, selectedMonthInt, selectedYearInt);
                    return isWithinBillingPeriod;
                });
            }

            // Apply sorting to filteredResults
            const dataToRender = [...filteredResults]; // Clone for sorting
            if (sortState.columnIndex !== null) {
                const directionModifier = sortState.direction === 'asc' ? 1 : -1;
                const selectedUnit = document.getElementById('unitSelector').value;
                const applyMultiplierForSort = document.getElementById('applyMultiplier').checked;
                const currentMultiplierForSort = applyMultiplierForSort ? multiplier : 1;

                let whUnitConverterForSort, varhUnitConverterForSort;
                if (selectedUnit === 'kw_kvar') {
                    // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£ Sort kW/kVar ‡πÄ‡∏£‡∏≤‡∏¢‡∏±‡∏á‡∏Ñ‡∏á‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏Ñ‡∏ß‡∏≤‡∏°‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î (‡πÑ‡∏°‡πà‡∏õ‡∏±‡∏î‡∏ó‡∏¥‡πâ‡∏á) ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á
                    // ‡∏à‡∏∞‡πÉ‡∏ä‡πâ‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏õ‡∏±‡∏î‡∏ó‡∏®‡∏ô‡∏¥‡∏¢‡∏° ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏•‡∏≥‡∏î‡∏±‡∏ö‡πÅ‡∏°‡πà‡∏ô‡∏¢‡∏≥
                    whUnitConverterForSort = (wh_val) => {
                        let baseKw = (parseFloat(wh_val) * 4 / 1000);
                        if (applyMultiplierForSort) return baseKw * currentMultiplierForSort;
                        return baseKw;
                    };
                    varhUnitConverterForSort = (varh_val) => {
                        let baseKvar = (parseFloat(varh_val) * 4 / 1000);
                        if (applyMultiplierForSort) return baseKvar * currentMultiplierForSort;
                        return baseKvar;
                    };
                } else { // kWh/kVarh ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Sort ‡πÉ‡∏´‡πâ‡∏õ‡∏±‡∏î‡∏ï‡∏≤‡∏° decimalPlacesForSummary
                    whUnitConverterForSort = (wh_val) => {
                        const raw = (parseFloat(wh_val) / 1000);
                        const valueToRound = raw * currentMultiplierForSort;
                        return parseFloat((valueToRound + Number.EPSILON).toFixed(decimalPlacesForSummary));
                    };
                    varhUnitConverterForSort = (varh_val) => {
                        const raw = (parseFloat(varh_val) / 1000);
                        const valueToRound = raw * currentMultiplierForSort;
                        return parseFloat((valueToRound + Number.EPSILON).toFixed(decimalPlacesForSummary));
                    };
                }

                dataToRender.sort((a, b) => {
                    let valA, valB;
                    switch (sortState.columnIndex) {
                        case 0: // Datetime
                            valA = a.dateObject.getTime();
                            valB = b.dateObject.getTime();
                            break;
                        case 1: // Rate
                            valA = getRate(a.dateObject);
                            valB = getRate(b.dateObject);
                            const rateOrder = {
                                'Holiday': 1,
                                'Off-peak': 2,
                                'Peak': 3
                            };
                            return (rateOrder[valA] - rateOrder[valB]) * directionModifier;
                        case 2: // Wh/kW
                            valA = whUnitConverterForSort(a.originalWhValue);
                            valB = whUnitConverterForSort(b.originalWhValue);
                            break;
                        case 3: // VARh/kVar
                            valA = varhUnitConverterForSort(a.originalVarhValue);
                            valB = varhUnitConverterForSort(b.originalVarhValue);
                            break;
                        default:
                            return 0;
                    }

                    if (typeof valA === 'string') {
                        return valA.localeCompare(valB) * directionModifier;
                    } else {
                        return (valA - valB) * directionModifier;
                    }
                });
            }

            dataToRender.forEach(r => {
                const rawWh = r.originalWhValue || 0; // Use rawWh directly for max comparison
                const rawVarh = r.originalVarhValue || 0; // Use rawVarh directly for max comparison

                const rate = getRate(r.dateObject);

                // --- START: Update MAX RAW values (STRICTLY RAW) ---
                if (unitType === 'kw_kvar') { // Only track RAW max if we are in kW/kVar display mode
                    // rawWh and rawVarh here are the actual raw values from the Excel, BEFORE any unit conversion or multiplier.
                    // This is essential for accurately finding the "peak" in the raw data,
                    // and then applying conversion/multiplier for display.
                    if (rawWh * 4 > maxRawWhValues[rate].value * 4) { // Compare actual power (kW equivalent)
                        maxRawWhValues[rate].value = rawWh;
                        maxRawWhValues[rate].datetime = r.datetime;
                    }
                    if (rawVarh * 4 > maxRawVarhValues[rate].value * 4) { // Compare actual reactive power (kVar equivalent)
                        maxRawVarhValues[rate].value = rawVarh;
                        maxRawVarhValues[rate].datetime = r.datetime;
                    }

                    if (rawWh * 4 > overallMaxRawWh.value * 4) {
                        overallMaxRawWh.value = rawWh;
                        overallMaxRawWh.datetime = r.datetime;
                    }
                    if (rawVarh * 4 > overallMaxRawVarh.value * 4) {
                        overallMaxRawVarh.value = rawVarh;
                        overallMaxRawVarh.datetime = r.datetime;
                    }
                }
                // --- END: Update MAX RAW values ---


                // Calculate currentWh and currentVarh for individual table display
                const currentWh = whCalculation(rawWh); // Pass rawWh to calculation
                const currentVarh = varhCalculation(rawVarh); // Pass rawVarh to calculation

                // --- HERE IS THE KEY CHANGE FOR TABLE DISPLAY ---
                let displayWhInTable, displayVarhInTable;
                if (unitType === 'kw_kvar') {
                    // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö kW/kVar ‡πÉ‡∏ô‡∏ï‡∏≤‡∏£‡∏≤‡∏á ‡πÉ‡∏´‡πâ‡∏õ‡∏±‡∏î‡πÄ‡∏õ‡πá‡∏ô 6 ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á
                    displayWhInTable = currentWh.toFixed(decimalPlacesForKwKvarTable);
                    displayVarhInTable = currentVarh.toFixed(decimalPlacesForKwKvarTable);
                } else {
                    // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö kWh/kVarh ‡πÉ‡∏ô‡∏ï‡∏≤‡∏£‡∏≤‡∏á ‡∏¢‡∏±‡∏á‡∏Ñ‡∏á‡∏õ‡∏±‡∏î‡∏ï‡∏≤‡∏° decimalPlacesForSummary (‡∏ã‡∏∂‡πà‡∏á‡∏Ñ‡∏∑‡∏≠ 2)
                    displayWhInTable = currentWh.toFixed(decimalPlacesForSummary);
                    displayVarhInTable = currentVarh.toFixed(decimalPlacesForSummary);

                    // Update total consumption (these are already calculated with multiplier if checked)
                    totalWhConsumption[rate] += currentWh;
                    totalVarhConsumption[rate] += currentVarh;
                }


                let displayDatetime = r.datetime; // This is already formatted from process()
                const cls = rate.toLowerCase().replace('-', '');
                tableRowsHtml += `<tr class="${cls}">
            <td>${displayDatetime}</td><td>${rate}</td>
            <td>${displayWhInTable}</td><td>${displayVarhInTable}</td>
        </tr>`;
            });

            let mainSummaryHtml = '';

            // Start of Rate Summary Container
            mainSummaryHtml += '<div class="rate-summary-container">';

            // Summary box based on unitType
            if (unitType === 'kw_kvar') {
                // --- START: Calculate final kW/kVar for display using max RAW values ---
                // ONLY HERE DO WE APPLY whCalculation/varhCalculation TO THE MAX RAW VALUES
                // ‡πÅ‡∏•‡∏∞‡∏õ‡∏±‡∏î‡∏ó‡∏®‡∏ô‡∏¥‡∏¢‡∏°‡∏ï‡∏≤‡∏° decimalPlacesForSummary (‡∏ã‡∏∂‡πà‡∏á‡∏Ñ‡∏∑‡∏≠ 3)
                const displayOverallMaxKw = whCalculation(overallMaxRawWh.value).toFixed(decimalPlacesForSummary);
                const displayOverallMaxKvar = varhCalculation(overallMaxRawVarh.value).toFixed(decimalPlacesForSummary);

                const displayPeakMaxKw = whCalculation(maxRawWhValues['Peak'].value).toFixed(decimalPlacesForSummary);
                const displayPeakMaxKvar = varhCalculation(maxRawVarhValues['Peak'].value).toFixed(decimalPlacesForSummary);

                const displayOffPeakMaxKw = whCalculation(maxRawWhValues['Off-peak'].value).toFixed(decimalPlacesForSummary);
                const displayOffPeakMaxKvar = varhCalculation(maxRawVarhValues['Off-peak'].value).toFixed(decimalPlacesForSummary);

                const displayHolidayMaxKw = whCalculation(maxRawWhValues['Holiday'].value).toFixed(decimalPlacesForSummary);
                const displayHolidayMaxKvar = varhCalculation(maxRawVarhValues['Holiday'].value).toFixed(decimalPlacesForSummary);
                // --- END: Calculate final kW/kVar for display using max RAW values ---


                mainSummaryHtml += `
            <div class="summary-box overall-max-summary">
                <h3>kW/kVar ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î‡∏£‡∏ß‡∏°‡∏ó‡∏∏‡∏Å‡πÄ‡∏£‡∏ó</h3>
                <p>kW: <strong>${displayOverallMaxKw} ${whUnit}</strong><br>
                <small>‡πÄ‡∏°‡∏∑‡πà‡∏≠: ${overallMaxRawWh.datetime || 'N/A'}</small></p>
                <p>kVar: <strong>${displayOverallMaxKvar} ${varhUnit}</strong><br>
                <small>‡πÄ‡∏°‡∏∑‡πà‡∏≠: ${overallMaxRawVarh.datetime || 'N/A'}</small></p>
            </div>
            <div class="summary-box max-kw-peak-summary">
                <h3>kW/kVar ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î (Peak)</h3>
                <p>kW: <strong>${displayPeakMaxKw} ${whUnit}</strong><br>
                <small>‡πÄ‡∏°‡∏∑‡πà‡∏≠: ${maxRawWhValues['Peak'].datetime || 'N/A'}</small></p>
                <p>kVar: <strong>${displayPeakMaxKvar} ${varhUnit}</strong><br>
                <small>‡πÄ‡∏°‡∏∑‡πà‡∏≠: ${maxRawVarhValues['Peak'].datetime || 'N/A'}</small></p>
            </div>
            <div class="summary-box max-kw-off-peak-summary">
                <h3>kW/kVar ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î (Off-peak)</h3>
                <p>kW: <strong>${displayOffPeakMaxKw} ${whUnit}</strong><br>
                <small>‡πÄ‡∏°‡∏∑‡πà‡∏≠: ${maxRawWhValues['Off-peak'].datetime || 'N/A'}</small></p>
                <p>kVar: <strong>${displayOffPeakMaxKvar} ${varhUnit}</strong><br>
                <small>‡πÄ‡∏°‡∏∑‡πà‡∏≠: ${maxRawVarhValues['Off-peak'].datetime || 'N/A'}</small></p>
            </div>
            <div class="summary-box max-kw-holiday-summary">
                <h3>kW/kVar ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î (Holiday)</h3>
                <p>kW: <strong>${displayHolidayMaxKw} ${whUnit}</strong><br>
                <small>‡πÄ‡∏°‡∏∑‡πà‡∏≠: ${maxRawWhValues['Holiday'].datetime || 'N/A'}</small></p>
                <p>kVar: <strong>${displayHolidayMaxKvar} ${varhUnit}</strong><br>
                <small>‡πÄ‡∏°‡∏∑‡πà‡∏≠: ${maxRawVarhValues['Holiday'].datetime || 'N/A'}</small></p>
            </div>
        `;
            } else { // If unitType is kWh/kVarh, show total consumption summaries
                mainSummaryHtml += `
            <div class="summary-box consumption-summary">
                <h3>‡∏™‡∏£‡∏∏‡∏õ‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏û‡∏•‡∏±‡∏á‡∏á‡∏≤‡∏ô (‡∏£‡∏ß‡∏°)</h3>
                <p>‡∏£‡∏ß‡∏° Peak: <strong>${totalWhConsumption['Peak'].toFixed(decimalPlacesForSummary)} ${whUnit}</strong>, <strong>${totalVarhConsumption['Peak'].toFixed(decimalPlacesForSummary)} ${varhUnit}</strong></p>
                <p>‡∏£‡∏ß‡∏° Off-peak: <strong>${totalWhConsumption['Off-peak'].toFixed(decimalPlacesForSummary)} ${whUnit}</strong>, <strong>${totalVarhConsumption['Off-peak'].toFixed(decimalPlacesForSummary)} ${varhUnit}</strong></p>
                <p>‡∏£‡∏ß‡∏° Holiday: <strong>${totalWhConsumption['Holiday'].toFixed(decimalPlacesForSummary)} ${whUnit}</strong>, <strong>${totalVarhConsumption['Holiday'].toFixed(decimalPlacesForSummary)} ${varhUnit}</strong></p>
                <p class="total-overall">‡∏£‡∏ß‡∏°‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î: <strong>${(totalWhConsumption['Peak'] + totalWhConsumption['Off-peak'] + totalWhConsumption['Holiday']).toFixed(decimalPlacesForSummary)} ${whUnit}</strong>, <strong>${(totalVarhConsumption['Peak'] + totalVarhConsumption['Off-peak'] + totalVarhConsumption['Holiday']).toFixed(decimalPlacesForSummary)} ${varhUnit}</strong></p>
            </div>
        `;
            }

            mainSummaryHtml += '</div>'; // End of Rate Summary Container

            const headers = [{
                title: '‡∏ß‡∏±‡∏ô‡πÄ‡∏ß‡∏•‡∏≤',
                index: 0
            }, {
                title: '‡πÄ‡∏£‡∏ó',
                index: 1
            }, {
                title: whUnit,
                index: 2
            }, {
                title: varhUnit,
                index: 3
            }];

            const headerHtml = headers.map(h => {
                const isActiveSort = sortState.columnIndex !== null && sortState.columnIndex === h.index;
                const sortClass = isActiveSort ? `active-sort ${sortState.direction}` : '';
                return `<th class="sortable ${sortClass}" onclick="sortTable(${h.index})" data-column-index="${h.index}">
                        ${h.title} <span class="sort-indicator"></span>
                    </th>`;
            }).join('');

            let tableHtml = `<h2 class="section-title">‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏£‡∏≤‡∏¢ 15 ‡∏ô‡∏≤‡∏ó‡∏µ</h2><table><tr>${headerHtml}</tr>${tableRowsHtml}</table>`;

            // Returning the HTML string directly
            return mainSummaryHtml + tableHtml;
        }


        async function process() {
            // *** ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏• ***
            if (isProcessed) {
                console.log("File already processed. Skipping re-processing.");
                // ‡∏Ñ‡∏∏‡∏ì‡∏≠‡∏≤‡∏à‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà ‡πÄ‡∏ä‡πà‡∏ô alert("‡πÑ‡∏ü‡∏•‡πå‡πÑ‡∏î‡πâ‡∏ñ‡∏π‡∏Å‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÑ‡∏õ‡πÅ‡∏•‡πâ‡∏ß")
                return;
            }
            // **********************************

            collectHolidays();
            const file = excelFileInput.files[0];
            if (!file) {
                alert("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏ü‡∏•‡πå Excel ‡∏´‡∏£‡∏∑‡∏≠‡∏•‡∏≤‡∏Å‡πÑ‡∏ü‡∏•‡πå‡∏°‡∏≤‡∏ß‡∏≤‡∏á‡∏Å‡πà‡∏≠‡∏ô‡∏Ñ‡∏£‡∏±‡∏ö/‡∏Ñ‡πà‡∏∞");
                return;
            }

            dropArea.innerHTML = `<span class="icon" style="color: #28a745;">‚úÖ</span><p>‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å: <strong>${file.name}</strong></p><p>‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•...</p>`;
            document.getElementById('output').innerHTML = '<p>‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÑ‡∏ü‡∏•‡πå...</p>';


            const reader = new FileReader();
            reader.onload = function (e) {
                const data = new Uint8Array(e.target.result);
                const wb = XLSX.read(data, {
                    type: 'array',
                    cellDates: true
                });
                const sheet = wb.Sheets[wb.SheetNames[0]];

                // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå Excel
                // ‡∏≠‡πà‡∏≤‡∏ô header row ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏£‡∏∞‡∏ö‡∏∏‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏Ç‡∏≠‡∏á‡πÑ‡∏ü‡∏•‡πå
                // ‡∏™‡∏°‡∏°‡∏ï‡∏¥‡∏ß‡πà‡∏≤ header ‡∏≠‡∏¢‡∏π‡πà‡∏ó‡∏µ‡πà‡πÅ‡∏ñ‡∏ß‡πÅ‡∏£‡∏Å (index 0) ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÑ‡∏ü‡∏•‡πå 3 ‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå
                // ‡πÅ‡∏•‡∏∞‡∏≠‡∏¢‡∏π‡πà‡∏ó‡∏µ‡πà‡πÅ‡∏ñ‡∏ß‡∏ó‡∏µ‡πà 3 (index 2) ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÑ‡∏ü‡∏•‡πå‡πÅ‡∏ö‡∏ö‡πÄ‡∏ï‡πá‡∏°
                let startRowForData = 3; // Default for existing structure
                let rawDateCol, whCol, varhCol;
                let isCompactFormat = false;

                // Attempt to read headers from row 1 (0-indexed) for the compact format
                const headerRowCompact = XLSX.utils.sheet_to_json(sheet, { header: 1, range: 'A1:C1' })[0];
                console.log("Header row for compact check:", headerRowCompact);

                if (headerRowCompact &&
                    headerRowCompact[0] === 'DATE_M' &&
                    headerRowCompact[1] === 'WH' &&
                    headerRowCompact[2] === 'VARHIMP Total') {

                    console.log("Detected compact format (3 columns).");
                    isCompactFormat = true;
                    startRowForData = 1; // Data starts from row 2 (index 1) for compact format
                    rawDateCol = 0; // Column A
                    whCol = 1;      // Column B
                    varhCol = 2;    // Column C

                    // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÑ‡∏ü‡∏•‡πå 3 ‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå ‡∏à‡∏∞‡πÑ‡∏°‡πà‡∏°‡∏µ meterNumber ‡πÅ‡∏•‡∏∞ multiplier ‡πÉ‡∏ô‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡πÄ‡∏î‡∏¥‡∏°
                    // ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô N/A ‡∏´‡∏£‡∏∑‡∏≠ 0 ‡πÑ‡∏õ‡∏Å‡πà‡∏≠‡∏ô ‡∏´‡∏£‡∏∑‡∏≠‡∏≠‡∏≤‡∏à‡∏à‡∏∞‡∏ï‡πâ‡∏≠‡∏á‡∏´‡∏≤‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡πÉ‡∏´‡∏°‡πà‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ô‡∏µ‡πâ
                    meterNumber = 'N/A (Compact File)';
                    multiplier = 1; // ‡∏´‡∏£‡∏∑‡∏≠‡∏Ñ‡πà‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏≠‡∏∑‡πà‡∏ô‡πÜ ‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÑ‡∏ü‡∏•‡πå‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏ô‡∏µ‡πâ
                } else {
                    console.log("Detected standard format.");
                    isCompactFormat = false;
                    startRowForData = 3; // Data starts from row 4 (index 3) for standard format
                    rawDateCol = 2;  // Column C
                    whCol = 26;      // Column AA
                    varhCol = 34;    // Column AI

                    if (sheet['A4'] && sheet['A4'].v !== undefined) {
                        meterNumber = sheet['A4'].v.toString();
                    } else {
                        meterNumber = 'N/A';
                    }

                    const e4 = parseFloat(sheet['E4'] ? sheet['E4'].v : 0);
                    const f4 = parseFloat(sheet['F4'] ? sheet['F4'].v : 0);
                    const g4 = parseFloat(sheet['G4'] ? sheet['G4'].v : 0);
                    const h4 = parseFloat(sheet['H4'] ? sheet['H4'].v : 0);

                    if (f4 !== 0 && h4 !== 0) {
                        multiplier = (e4 / f4) * (g4 / h4);
                    } else {
                        multiplier = 0;
                    }
                }


                const rows = XLSX.utils.sheet_to_json(sheet, {
                    header: 1
                });

                globalResults = [];
                isProcessed = false; // *** ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Å‡πà‡∏≠‡∏ô‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏´‡∏°‡πà ***
                monthlySummaries = {}; // Reset monthly summaries when a new file is processed
                monthlyMaxValues = {}; // Reset monthly max values as well


                for (let i = startRowForData; i < rows.length; i++) {
                    const rawDate = rows[i][rawDateCol];
                    const originalWhValue = parseFloat(rows[i][whCol]) || 0;
                    const originalVarhValue = parseFloat(rows[i][varhCol]) || 0;

                    if (!rawDate || isNaN(originalWhValue) || isNaN(originalVarhValue)) continue;

                    // *** ‡πÉ‡∏ä‡πâ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô helper ‡πÉ‡∏´‡∏°‡πà‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÅ‡∏õ‡∏•‡∏á‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏à‡∏≤‡∏Å Excel ***
                    let dateObjectBKK = convertExcelDateToBKKUTCAdjusted(rawDate);
                    if (!dateObjectBKK) continue; // ‡∏ñ‡πâ‡∏≤‡πÅ‡∏õ‡∏•‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ ‡πÉ‡∏´‡πâ‡∏Ç‡πâ‡∏≤‡∏° row ‡∏ô‡∏µ‡πâ‡πÑ‡∏õ

                    // Rounding to nearest 15-minute interval for dateObjectBKK (‡∏ã‡∏∂‡πà‡∏á‡∏ï‡∏≠‡∏ô‡∏ô‡∏µ‡πâ‡∏ñ‡∏π‡∏Å‡∏õ‡∏£‡∏±‡∏ö‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡πá‡∏ô UTC-adjusted BKK ‡πÅ‡∏•‡πâ‡∏ß)
                    const totalMinutesFromBKKMidnight = dateObjectBKK.getUTCHours() * 60 + dateObjectBKK.getUTCMinutes() + dateObjectBKK.getUTCSeconds() / 60;
                    const roundedTotalMinutesBKK = Math.round(totalMinutesFromBKKMidnight / 15) * 15;

                    // Create the final roundedDateObjectUTC with the correct BKK time in its UTC components
                    const roundedDateObjectUTC = new Date(Date.UTC(
                        dateObjectBKK.getUTCFullYear(),
                        dateObjectBKK.getUTCMonth(),
                        dateObjectBKK.getUTCDate(),
                        0, // Start from midnight BKK (which is now in UTC components)
                        roundedTotalMinutesBKK,
                        0, 0
                    ));
                    // No additional setUTCHours adjustment needed here as the previous steps ensured
                    // that roundedDateObjectUTC has its UTC components representing the desired BKK time.

                    const displayBkkComponents = getBKKTimeComponents(roundedDateObjectUTC);
                    const formattedDatetime = `${displayBkkComponents.year}/${(displayBkkComponents.month + 1).toString().padStart(2, '0')}/${displayBkkComponents.day.toString().padStart(2, '0')} ${displayBkkComponents.hour.toString().padStart(2, '0')}:${displayBkkComponents.minute.toString().padStart(2, '0')}:00`;

                    globalResults.push({
                        datetime: formattedDatetime,
                        originalWhValue: originalWhValue,
                        originalVarhValue: originalVarhValue,
                        dateObject: roundedDateObjectUTC // This is the UTC-adjusted BKK time
                    });

                    // --- START: NEW MONTHLY SUMMARY CALCULATION (STORE RAW VALUES) ---
                    const monthKey = `${displayBkkComponents.year}-${(displayBkkComponents.month + 1).toString().padStart(2, '0')}`;
                    const rate = getRate(roundedDateObjectUTC); // Use the rounded date object for rate

                    // Initialize structures for this month if they don't exist
                    if (!monthlySummaries[monthKey]) {
                        monthlySummaries[monthKey] = {
                            'Peak': { wh: 0, varh: 0 },
                            'Off-peak': { wh: 0, varh: 0 },
                            'Holiday': { wh: 0, varh: 0 }
                        };
                    }
                    if (!monthlyMaxValues[monthKey]) {
                        monthlyMaxValues[monthKey] = {
                            'Peak': { wh: 0, varh: 0, wh_datetime: '', varh_datetime: '' },
                            'Off-peak': { wh: 0, varh: 0, wh_datetime: '', varh_datetime: '' },
                            'Holiday': { wh: 0, varh: 0, wh_datetime: '', varh_datetime: '' }
                        };
                    }

                    // Accumulate RAW kWh and kVarh totals
                    monthlySummaries[monthKey][rate].wh += (originalWhValue / 1000); // Store raw kWh
                    monthlySummaries[monthKey][rate].varh += (originalVarhValue / 1000); // Store raw kVarh

                    // Update max RAW kW and kVar values for the rate
                    const kW_raw = (originalWhValue * 4 / 1000); // kW is derived by multiplying by 4 (since it's a 15-min interval)
                    const kVar_raw = (originalVarhValue * 4 / 1000); // kVar is derived by multiplying by 4 (since it's a 15-min interval)

                    if (kW_raw > monthlyMaxValues[monthKey][rate].wh) {
                        monthlyMaxValues[monthKey][rate].wh = kW_raw;
                        monthlyMaxValues[monthKey][rate].wh_datetime = formattedDatetime;
                    }
                    if (kVar_raw > monthlyMaxValues[monthKey][rate].varh) {
                        monthlyMaxValues[monthKey][rate].varh = kVar_raw;
                        monthlyMaxValues[monthKey][rate].varh_datetime = formattedDatetime;
                    }
                    // --- END: NEW MONTHLY SUMMARY CALCULATION ---
                }

                isProcessed = true; // ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô true ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô
                sortState.columnIndex = null;
                sortState.direction = 'asc';

                populateMonthYearSelector(); // Populate the Month/Year selector
                updateDisplay(); // Initial display
            };
            reader.readAsArrayBuffer(file);
        }

        function updateDisplay() {
            if (!isProcessed) {
                return;
            }
            const selectedMonthYear = document.getElementById('monthYearSelector').value;
            const selectedArType = document.getElementById('arTypeSelector').value;
            const selectedUnit = document.getElementById('unitSelector').value;

            console.log(`[updateDisplay] User selected Month/Year: ${selectedMonthYear}, AR Type: ${selectedArType}`);

            const outputDiv = document.getElementById('output');
            outputDiv.innerHTML = ''; // Clear previous content

            // Render monthly summary table first
            outputDiv.innerHTML += renderMonthlySummaryTable(); // Append the monthly summary

            // Create a wrapper for the summary boxes to make layout easier
            const summaryBoxWrapper = document.createElement('div');
            summaryBoxWrapper.className = 'summary-box-wrapper';

            // Add Meter Info
            const formattedMultiplier = multiplier.toLocaleString('en-US', {
                minimumFractionDigits: 4,
                maximumFractionDigits: 4
            });
            const meterInfoHtml = `
                <div class="summary-box meter-info">
                    <h3>‡∏™‡∏£‡∏∏‡∏õ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏°‡∏¥‡πÄ‡∏ï‡∏≠‡∏£‡πå‡πÅ‡∏•‡∏∞‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏û‡∏•‡∏±‡∏á‡∏á‡∏≤‡∏ô</h3>
                    <p>‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏•‡∏Ç‡∏°‡∏¥‡πÄ‡∏ï‡∏≠‡∏£‡πå: <strong>${meterNumber || 'N/A'}</strong></p>
                    <p>‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡∏±‡∏ß‡∏Ñ‡∏π‡∏ì: <strong>${formattedMultiplier}</strong></p>
                </div>`;
            summaryBoxWrapper.innerHTML += meterInfoHtml;

            // Add Billing Period Info
            const billingPeriodInfoDiv = document.createElement('div');
            billingPeriodInfoDiv.className = 'summary-box billing-period-info';

            if (selectedMonthYear !== 'all') {
                const [yearStr, monthStr] = selectedMonthYear.split('-');
                const selectedMonthInt = parseInt(monthStr); // 1-indexed
                const selectedYearInt = parseInt(yearStr); // AD year

                const {
                    startDate,
                    endDate
                } = getBillingPeriodDates(selectedYearInt, selectedMonthInt, selectedArType);

                if (startDate && endDate) {
                    const formatDateTime = (dateObj) => {
                        const bkkComponents = {
                            year: dateObj.getUTCFullYear(),
                            month: dateObj.getUTCMonth(),
                            day: dateObj.getUTCDate(),
                            hour: dateObj.getUTCHours(),
                            minute: dateObj.getUTCMinutes()
                        };
                        return `${bkkComponents.day.toString().padStart(2, '0')}/${(bkkComponents.month + 1).toString().padStart(2, '0')}/${bkkComponents.year + 543} ${bkkComponents.hour.toString().padStart(2, '0')}:${bkkComponents.minute.toString().padStart(2, '0')}:00`;
                    };

                    billingPeriodInfoDiv.innerHTML = `
                        <h3>‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡∏ö‡∏¥‡∏•‡∏•‡∏¥‡πà‡∏á</h3>
                        <p>‡∏ï‡∏±‡πâ‡∏á‡πÅ‡∏ï‡πà: <strong>${formatDateTime(startDate)}</strong></p>
                        <p>‡∏ñ‡∏∂‡∏á: <strong>${formatDateTime(endDate)}</strong></p>
                    `;
                } else {
                    console.warn("[updateDisplay] Could not calculate billing period dates for display.");
                    billingPeriodInfoDiv.innerHTML = `
                        <h3>‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡∏ö‡∏¥‡∏•‡∏•‡∏¥‡πà‡∏á</h3>
                        <p>‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡∏ö‡∏¥‡∏•‡∏•‡∏¥‡πà‡∏á‡πÑ‡∏î‡πâ</p>
                    `;
                }
            } else {
                billingPeriodInfoDiv.innerHTML = `
                    <h3>‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡∏ö‡∏¥‡∏•‡∏•‡∏¥‡πà‡∏á</h3>
                    <p>‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏ó‡∏µ‡πà‡∏°‡∏µ‡πÉ‡∏ô‡πÑ‡∏ü‡∏•‡πå</p>
                `;
            }
            summaryBoxWrapper.appendChild(billingPeriodInfoDiv);


            // Append the summary box wrapper to the outputDiv
            outputDiv.appendChild(summaryBoxWrapper);


            // Render the detailed results (rate summary and 15-min table)
            outputDiv.innerHTML += renderResultsAsHtml(selectedUnit, selectedMonthYear, selectedArType);

            updateExportButtonVisibility(); // Ensure the export button is visible after rendering
        }

        // Modified Export to Excel Function
        function exportTableToExcel() {
            if (!isProcessed) {
                alert("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå Excel ‡∏Å‡πà‡∏≠‡∏ô‡∏ó‡∏≥‡∏Å‡∏≤‡∏£‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å");
                return;
            }

            const unitType = document.getElementById('unitSelector').value;
            const applyMultiplier = document.getElementById('applyMultiplier').checked;
            const currentMultiplier = applyMultiplier ? multiplier : 1;
            const selectedMonthYear = document.getElementById('monthYearSelector').value;
            const selectedArType = document.getElementById('arTypeSelector').value;


            let whUnit, varhUnit;
            let whCalculation, varhCalculation;
            let decimalPlaces;

            if (unitType === 'kw_kvar') {
                whUnit = 'kW';
                varhUnit = 'kVar';
                decimalPlaces = 6; // Keep 6 decimal places for kW/kVar export for precision

                whCalculation = (wh_val) => {
                    let baseKw = (parseFloat(wh_val) * 4 / 1000);
                    if (applyMultiplier) {
                        return baseKw * currentMultiplier;
                    }
                    return baseKw;
                };
                varhCalculation = (varh_val) => {
                    let baseKvar = (parseFloat(varh_val) * 4 / 1000);
                    if (applyMultiplier) {
                        return baseKvar * currentMultiplier;
                    }
                    return baseKvar;
                };
            } else { // kWh, kVarh
                whUnit = 'kWh';
                varhUnit = 'kVarh';
                decimalPlaces = 2; // Keep 2 decimal places for kWh/kVarh export

                const roundToDecimal = (value, decimals) => {
                    const factor = Math.pow(10, decimals);
                    return Math.round(value * factor) / factor;
                };

                whCalculation = (wh_val) => {
                    const raw = (parseFloat(wh_val) / 1000);
                    return roundToDecimal(raw * currentMultiplier, decimalPlaces);
                };

                varhCalculation = (varh_val) => {
                    const raw = (parseFloat(varh_val) / 1000);
                    return roundToDecimal(raw * currentMultiplier, decimalPlaces);
                };
            }

            const dataToExport = [];

            // Add header row
            dataToExport.push(['‡∏ß‡∏±‡∏ô‡πÄ‡∏ß‡∏•‡∏≤', '‡πÄ‡∏£‡∏ó', whUnit, varhUnit]);

            let dataForExport = [];
            if (selectedMonthYear === 'all') {
                dataForExport = [...globalResults];
            } else {
                const [yearStr, monthStr] = selectedMonthYear.split('-');
                const selectedMonthInt = parseInt(monthStr); // 1-indexed
                const selectedYearInt = parseInt(yearStr); // AD year

                dataForExport = globalResults.filter(r => {
                    return isInBillingPeriod(r.dateObject, selectedArType, selectedMonthInt, selectedYearInt);
                });
            }

            // Apply sorting if a sort state is active (same as renderResults)
            if (sortState.columnIndex !== null) {
                const directionModifier = sortState.direction === 'asc' ? 1 : -1;
                const selectedUnit = document.getElementById('unitSelector').value;
                const applyMultiplierForSort = document.getElementById('applyMultiplier').checked;
                const currentMultiplierForSort = applyMultiplierForSort ? multiplier : 1;

                let whUnitConverterForSort, varhUnitConverterForSort;
                if (selectedUnit === 'kw_kvar') {
                    whUnitConverterForSort = (wh) => (parseFloat(wh) * 4 / 1000) * currentMultiplierForSort; // Precise for sorting
                    varhUnitConverterForSort = (varh) => (parseFloat(varh) * 4 / 1000) * currentMultiplierForSort; // Precise for sorting
                } else {
                    whUnitConverterForSort = (wh) => (parseFloat(wh) / 1000) * currentMultiplierForSort;
                    varhUnitConverterForSort = (varh) => (parseFloat(varh) / 1000) * currentMultiplierForSort;
                }

                dataForExport.sort((a, b) => { // Sort dataForExport, not filteredResults
                    let valA, valB;
                    switch (sortState.columnIndex) {
                        case 0: // Datetime
                            valA = a.dateObject.getTime();
                            valB = b.dateObject.getTime();
                            break;
                        case 1: // Rate
                            valA = getRate(a.dateObject);
                            valB = getRate(b.dateObject);
                            const rateOrder = {
                                'Holiday': 1,
                                'Off-peak': 2,
                                'Peak': 3
                            };
                            return (rateOrder[valA] - rateOrder[valB]) * directionModifier;
                        case 2: // Wh/kW
                            valA = whUnitConverterForSort(a.originalWhValue);
                            valB = whUnitConverterForSort(b.originalWhValue);
                            break;
                        case 3: // VARh/kVar
                            valA = varhUnitConverterForSort(a.originalVarhValue);
                            valB = varhUnitConverterForSort(b.originalVarhValue);
                            break;
                        default:
                            return 0;
                    }

                    if (typeof valA === 'string') {
                        return valA.localeCompare(valB) * directionModifier;
                    } else {
                        return (valA - valB) * directionModifier;
                    }
                });
            }

            // Add data rows
            dataForExport.forEach(r => {
                // Add this check to ensure 'r' and 'r.dateObject' are valid
                if (!r || !r.dateObject) {
                    console.error("Skipping malformed data row during export:", r);
                    return; // Skip this iteration if the data is not as expected
                }

                const wh = r.originalWhValue || 0;
                const varh = r.originalVarhValue || 0;

                const currentWh = whCalculation(wh);
                const currentVarh = varhCalculation(varh);

                const rate = getRate(r.dateObject);

                dataToExport.push([
                    r.datetime,
                    rate,
                    currentWh.toFixed(decimalPlaces), // Apply decimal places for export
                    currentVarh.toFixed(decimalPlaces) // Apply decimal places for export
                ]);
            });

            const ws = XLSX.utils.aoa_to_sheet(dataToExport);
            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, "Electric Rates Filtered");

            const filename = `Electric_Rates_${selectedMonthYear}_${selectedArType}_${new Date().toISOString().slice(0, 10)}.xlsx`;

            XLSX.writeFile(wb, filename);
        }

        document.getElementById('exportExcel').addEventListener('click', exportTableToExcel);

        // Utility function to toggle export button visibility (could be expanded)
        function updateExportButtonVisibility() {
            const exportButton = document.getElementById('exportExcel');
            if (isProcessed && globalResults.length > 0) {
                exportButton.style.display = 'block';
            } else {
                exportButton.style.display = 'none';
            }
        }
        document.addEventListener('DOMContentLoaded', updateExportButtonVisibility); // Call on initial load
    </script>
</body>

</html>
<!DOCTYPE html>
<html lang="th">

<head>
    <meta charset="UTF-8">
    <title>‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏£‡∏ó‡πÑ‡∏ü‡∏ü‡πâ‡∏≤</title>
    <link rel="stylesheet" href="style.css">
    <link rel="icon" type="image/png" href="favicon.png">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
    <script src="./holiday_results/holiday_2022.js"></script>
    <script src="./holiday_results/holiday_2023.js"></script>
    <script src="./holiday_results/holiday_2024.js"></script>
    <script src="./holiday_results/holiday_2025.js"></script>
</head>

<body>
    <div class="container">
        <h1>‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏£‡∏ó‡πÑ‡∏ü‡∏ü‡πâ‡∏≤‡∏à‡∏≤‡∏Å‡πÑ‡∏ü‡∏•‡πå Excel</h1>

        <div id="dropArea" class="drop-area">
            <span class="icon">üìÑ</span>
            <p>‡∏•‡∏≤‡∏Å‡πÑ‡∏ü‡∏•‡πå Excel (.xlsx, .xls) ‡∏°‡∏≤‡∏ß‡∏≤‡∏á‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà</p>
            <p>‡∏´‡∏£‡∏∑‡∏≠‡∏Ñ‡∏•‡∏¥‡∏Å‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏ü‡∏•‡πå</p>
            <input type="file" id="excelFile" accept=".xlsx, .xls">
        </div>

        <div class="controls">
            <div class="control-group">
                <label for="monthYearSelector">‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÄ‡∏î‡∏∑‡∏≠‡∏ô:</label>
                <div class="select-wrapper">
                    <select id="monthYearSelector" onchange="updateDisplay()">
                    </select>
                </div>
            </div>

            <div class="control-group">
                <label for="arTypeSelector">‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó Portion:</label>
                <div class="select-wrapper">
                    <select id="arTypeSelector" onchange="updateDisplay()">
                        <option value="AR1">AR1</option>
                        <option value="AR6">AR6</option>
                        <option value="HA1">HA1</option>
                    </select>
                </div>
            </div>

            <div class="control-group">
                <label for="unitSelector">‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏´‡∏ô‡πà‡∏ß‡∏¢:</label>
                <div class="select-wrapper">
                    <select id="unitSelector" onchange="updateDisplay()">
                        <option value="kwh_kvarh">kWh, kVarh</option>
                        <option value="kw_kvar">kW, kVar</option>
                        <option value="voltage_abc">Voltage A, B, C (V)</option>
                        <option value="current_abc">Current A, B, C (A)</option>
                    </select>
                </div>
            </div>

            <div class="control-group">
                <label for="dataTypeSelector">Import/Export:</label>
                <div class="select-wrapper">
                    <select id="dataTypeSelector" onchange="updateDisplay()">
                        <option value="wh_import">Import</option>
                        <option value="wh_export">Export</option>
                    </select>
                </div>
            </div>

            <div class="control-group checkbox-group">
                <input type="checkbox" id="applyMultiplier" onchange="updateDisplay()">
                <label for="applyMultiplier" class="custom-checkbox">
                    ‡∏Ñ‡∏π‡∏ì‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏î‡πâ‡∏ß‡∏¢‡∏ï‡∏±‡∏ß‡∏Ñ‡∏π‡∏ì
                    <span class="icon-checked">‚úî</span> <span class="icon-unchecked"></span> </label>
            </div>

            <div class="control-group">
                <button id="exportExcel" class="button">Export Data to Excel</button>
            </div>
        </div>

        <div id="detail-chart-container" class="large-chart-container" style="margin-top: 20px;">
            <canvas id="detailLineChart"></canvas>
        </div>

        <div id="output" class="output-section"></div>
    </div>
    <script>
        const holidays = new Set();
        let globalResults = []; // Stores all raw data from the Excel file
        let isProcessed = false; // Status if file is processed
        let meterNumber = '';

        // monthlySummaries and monthlyMaxValues will now store the data for the CURRENTLY DISPLAYED summary data (all months)
        let monthlySummaries = {};
        let monthlyMaxValues = {};

        let sortState = {
            columnIndex: null,
            direction: 'asc'
        };

        const dropArea = document.getElementById('dropArea');
        const excelFileInput = document.getElementById('excelFile');

        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropArea.addEventListener(eventName, preventDefaults, false);
            document.body.addEventListener(eventName, preventDefaults, false);
        });

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        ['dragenter', 'dragover'].forEach(eventName => {
            dropArea.addEventListener(eventName, () => dropArea.classList.add('drag-over'), false);
        });

        ['dragleave', 'drop'].forEach(eventName => {
            dropArea.addEventListener(eventName, () => dropArea.classList.remove('drag-over'), false);
        });

        dropArea.addEventListener('drop', handleDrop, false);

        function handleDrop(e) {
            const dt = e.dataTransfer;
            const files = dt.files;

            if (files.length > 0) {
                // Reset isProcessed when a new file is dropped
                isProcessed = false;
                excelFileInput.files = files;
                process();
            }
        }

        dropArea.addEventListener('click', () => {
            excelFileInput.click();
        });

        excelFileInput.addEventListener('change', () => {
            if (excelFileInput.files.length > 0) {
                // Reset isProcessed when a new file is selected
                isProcessed = false;
                process();
            }
        });

        // Helper function to extract BKK time components from a UTC-adjusted Date object.
        function getBKKTimeComponents(utcDateObj) {
            return {
                hour: utcDateObj.getUTCHours(),
                minute: utcDateObj.getUTCMinutes(),
                second: utcDateObj.getUTCSeconds(),
                day: utcDateObj.getUTCDate(),
                month: utcDateObj.getUTCMonth(), // 0-indexed
                year: utcDateObj.getUTCFullYear(),
                dayOfWeek: utcDateObj.getUTCDay() // BKK day of week (0=Sun, 6=Sat)
            };
        }

        // Helper function to get a Date object representing midnight of a calendar day in BKK timezone.
        // The returned Date object's UTC components will *directly* represent BKK midnight.
        function getBKKMidnightUTCAdjusted(year, monthIndex, day) { // monthIndex is 0-indexed
            // Create a Date object where its UTC components directly represent BKK midnight for the given day.
            const d = new Date(Date.UTC(year, monthIndex, day, 0, 0, 0));
            return d;
        }

        // ******** ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏õ‡∏•‡∏á Excel Date ‡πÄ‡∏õ‡πá‡∏ô BKK Time ‡πÉ‡∏ô‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö UTC-adjusted (‡∏à‡∏∏‡∏î‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏ó‡∏µ‡πà‡∏õ‡∏£‡∏±‡∏ö) ********
        function convertExcelDateToBKKUTCAdjusted(rawDate) {
            let dateObj;
            const bkkOffsetMs = 7 * 60 * 60 * 1000; // 7 hours in milliseconds

            if (rawDate instanceof Date) {
                dateObj = new Date(rawDate.getTime() + bkkOffsetMs);
            } else if (typeof rawDate === 'number') {
                const parsed = XLSX.SSF.parse_date_code(rawDate);
                dateObj = new Date(Date.UTC(parsed.y, parsed.m - 1, parsed.d, parsed.H, parsed.M, parsed.S));
            } else if (typeof rawDate === 'string') {
                const match = rawDate.match(/(\d{1,2})\/(\d{1,2})\/(\d{4})\s*(\d{1,2}):(\d{2}):(\d{2})|(\d{4})-(\d{1,2})-(\d{1,2})T(\d{1,2}):(\d{2}):(\d{2})/);
                if (match) {
                    let year, month, day, hour, minute, second;
                    if (match[1]) { // DD/MM/YYYY HH:mm:ss format
                        [, day, month, year, hour, minute, second] = match;
                        year = parseInt(year) > 2500 ? parseInt(year) - 543 : parseInt(year); // Convert Buddhist year to AD
                    } else if (match[7]) { //YYYY-MM-DDTHH:mm:ss format
                        [, , , , , , year, month, day, hour, minute, second] = match;
                    }
                    dateObj = new Date(Date.UTC(parseInt(year), parseInt(month) - 1, parseInt(day), parseInt(hour), parseInt(minute), parseInt(second)));
                } else {
                    let tempDate = new Date(rawDate);
                    if (!isNaN(tempDate.getTime())) {
                        dateObj = new Date(tempDate.getTime() + bkkOffsetMs);
                    } else {
                        return null;
                    }
                }
            } else {
                return null;
            }

            return isNaN(dateObj.getTime()) ? null : dateObj;
        }
        // ******************************************************************************

        function collectHolidays() {
            holidays.clear();
            const allHolidayVars = [
                typeof holiday_2022 !== 'undefined' ? holiday_2022 : null,
                typeof holiday_2023 !== 'undefined' ? holiday_2023 : null,
                typeof holiday_2024 !== 'undefined' ? holiday_2024 : null,
                typeof holiday_2025 !== 'undefined' ? holiday_2025 : null
            ];
            allHolidayVars.forEach(data => {
                if (!data || !data.data) return;
                data.data.forEach(entry => {
                    if (entry.tou === 1 && entry.holiday) {
                        const [d, m, byear] = entry.holiday.split('/');
                        const year = parseInt(byear) - 543;

                        const bkkHolidayMidnight = getBKKMidnightUTCAdjusted(year, parseInt(m) - 1, parseInt(d));

                        const isoDate = bkkHolidayMidnight.toISOString().split('T')[0];
                        holidays.add(isoDate);
                    }
                });
            });
        }

        function isHoliday(date) {
            let checkDate = new Date(date.getTime());

            const bkkComponents = getBKKTimeComponents(checkDate);
            let hour = bkkComponents.hour;
            let min = bkkComponents.minute;

            if (hour === 0 && min < 15) {
                checkDate.setUTCHours(checkDate.getUTCHours() - 24);
            }

            const finalBkkComponents = getBKKTimeComponents(checkDate);
            const iso = finalBkkComponents.year + '-' +
                String(finalBkkComponents.month + 1).padStart(2, '0') + '-' +
                String(finalBkkComponents.day).padStart(2, '0');
            return holidays.has(iso);
        }

        function getRate(date) {
            let checkDate = new Date(date.getTime());

            const bkkComponents = getBKKTimeComponents(checkDate);
            let hour = bkkComponents.hour;
            let min = bkkComponents.minute;

            if (hour === 0 && min < 15) {
                checkDate.setUTCHours(checkDate.getUTCHours() - 24);
                const adjustedBkkComponents = getBKKTimeComponents(checkDate);
                hour = adjustedBkkComponents.hour;
                min = adjustedBkkComponents.minute;
            }

            const day = getBKKTimeComponents(checkDate).dayOfWeek;
            if (isHoliday(date) || day === 0 || day === 6) {
                return 'Holiday';
            }

            const totalMin = hour * 60 + min;
            const peakStart = 9 * 60 + 15; // 09:15
            const peakEnd = 22 * 60; // 22:00

            if (totalMin >= peakStart && totalMin <= peakEnd) {
                return 'Peak';
            } else {
                return 'Off-peak';
            }
        }

        function getDaysInMonth(year, month) {
            return new Date(Date.UTC(year, month, 0)).getUTCDate();
        }

        function getReadingDay(year, month, arType) { // month is 1-indexed here (1-12)
            const numDaysInMonth = getDaysInMonth(year, month);

            if (arType === 'AR1') {
                return numDaysInMonth - 10;
            } else if (arType === 'AR6') {
                return numDaysInMonth - 2;
            } else if (arType === 'HA1') {
                return 1;
            }
            console.error(`[getReadingDay] Unknown AR Type: ${arType}`);
            return -1;
        }

        function isInBillingPeriod(dateObject, arType, targetMonth, targetYear) {
            let billingPeriodStartDate, billingPeriodEndDate;

            if (arType === 'HA1') {
                billingPeriodStartDate = getBKKMidnightUTCAdjusted(targetYear, targetMonth - 1, 1);
                billingPeriodStartDate.setMinutes(billingPeriodStartDate.getMinutes() + 15);

                let nextMonth = targetMonth + 1;
                let nextMonthYear = targetYear;
                if (nextMonth > 12) {
                    nextMonth = 1;
                    nextMonthYear++;
                }
                billingPeriodEndDate = getBKKMidnightUTCAdjusted(nextMonthYear, nextMonth - 1, 1);

            } else {
                let prevReadingMonth = targetMonth - 1;
                let prevReadingYear = targetYear;
                if (prevReadingMonth === 0) {
                    prevReadingMonth = 12;
                    prevReadingYear--;
                }

                const prevReadingDay = getReadingDay(prevReadingYear, prevReadingMonth, arType);
                if (prevReadingDay === -1) {
                    return false;
                }

                billingPeriodStartDate = getBKKMidnightUTCAdjusted(prevReadingYear, prevReadingMonth - 1, prevReadingDay);
                billingPeriodStartDate.setMinutes(billingPeriodStartDate.getMinutes() + 15);

                const currentReadingDay = getReadingDay(targetYear, targetMonth, arType);
                if (currentReadingDay === -1) {
                    return false;
                }

                let thisMonthReadingDate = getBKKMidnightUTCAdjusted(targetYear, targetMonth - 1, currentReadingDay);
                billingPeriodEndDate = new Date(thisMonthReadingDate.getTime());
                billingPeriodEndDate.setUTCHours(0);
                billingPeriodEndDate.setUTCMinutes(0);
                billingPeriodEndDate.setUTCSeconds(0);
            }
            // console.log(`Checking date: ${dateObject.toISOString()} against period: ${billingPeriodStartDate.toISOString()} to ${billingPeriodEndDate.toISOString()}`);
            return dateObject.getTime() >= billingPeriodStartDate.getTime() && dateObject.getTime() <= billingPeriodEndDate.getTime();
        }

        function sortTable(columnIndex) {
            if (!isProcessed) return;

            if (sortState.columnIndex === columnIndex) {
                sortState.direction = sortState.direction === 'asc' ? 'desc' : 'asc';
            } else {
                sortState.columnIndex = columnIndex;
                if (columnIndex === 0) { // Datetime
                    sortState.direction = 'asc';
                } else if (columnIndex === 1) { // Rate
                    sortState.direction = 'asc';
                } else { // Numeric columns
                    sortState.direction = 'desc';
                }
            }

            updateDisplay(); // Re-render the detailed table after sorting
        }

        function customRound(value, decimalPlaces) {
            const factor = Math.pow(10, decimalPlaces);
            return Math.round(value * factor) / factor;
        }

        function populateMonthYearSelector() {
            const selector = document.getElementById('monthYearSelector');
            selector.innerHTML = '';

            const monthNames = ["‡∏°‡∏Å‡∏£‡∏≤‡∏Ñ‡∏°", "‡∏Å‡∏∏‡∏°‡∏†‡∏≤‡∏û‡∏±‡∏ô‡∏ò‡πå", "‡∏°‡∏µ‡∏ô‡∏≤‡∏Ñ‡∏°", "‡πÄ‡∏°‡∏©‡∏≤‡∏¢‡∏ô", "‡∏û‡∏§‡∏©‡∏†‡∏≤‡∏Ñ‡∏°", "‡∏°‡∏¥‡∏ñ‡∏∏‡∏ô‡∏≤‡∏¢‡∏ô", "‡∏Å‡∏£‡∏Å‡∏é‡∏≤‡∏Ñ‡∏°", "‡∏™‡∏¥‡∏á‡∏´‡∏≤‡∏Ñ‡∏°", "‡∏Å‡∏±‡∏ô‡∏¢‡∏≤‡∏¢‡∏ô", "‡∏ï‡∏∏‡∏•‡∏≤‡∏Ñ‡∏°", "‡∏û‡∏§‡∏®‡∏à‡∏¥‡∏Å‡∏≤‡∏¢‡∏ô", "‡∏ò‡∏±‡∏ô‡∏ß‡∏≤‡∏Ñ‡∏°"];

            const uniqueMonthYears = new Set();
            globalResults.forEach(r => {
                const {
                    year,
                    month
                } = getBKKTimeComponents(r.dateObject);
                uniqueMonthYears.add(`${year}-${(month + 1).toString().padStart(2, '0')}`);
            });

            const sortedUniqueMonthYears = Array.from(uniqueMonthYears).sort();

            const allOption = document.createElement('option');
            allOption.value = 'all';
            allOption.textContent = '‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î';
            selector.appendChild(allOption);

            sortedUniqueMonthYears.forEach(periodStr => {
                const [yearStr, monthStr] = periodStr.split('-');
                const year = parseInt(yearStr);
                const month = parseInt(monthStr);

                const option = document.createElement('option');
                option.value = `${year}-${month.toString().padStart(2, '0')}`;
                option.textContent = `${monthNames[month - 1]} ${year + 543}`;
                selector.appendChild(option);
            });

            if (sortedUniqueMonthYears.length > 0) {
                // Set default to the latest month available
                selector.value = sortedUniqueMonthYears[sortedUniqueMonthYears.length - 1];
            }
        }

        function getBillingPeriodDates(selectedYear, selectedMonth, arType) {
            let billingPeriodStartDate, billingPeriodEndDate;

            if (arType === 'HA1') {
                billingPeriodStartDate = getBKKMidnightUTCAdjusted(selectedYear, selectedMonth - 1, 1);
                billingPeriodStartDate.setMinutes(billingPeriodStartDate.getMinutes() + 15);

                let nextMonth = selectedMonth + 1;
                let nextMonthYear = selectedYear;
                if (nextMonth > 12) {
                    nextMonth = 1;
                    nextMonthYear++;
                }
                billingPeriodEndDate = getBKKMidnightUTCAdjusted(nextMonthYear, nextMonth - 1, 1);

            } else {
                let prevReadingMonth = selectedMonth - 1;
                let prevReadingYear = selectedYear;
                if (prevReadingMonth === 0) {
                    prevReadingMonth = 12;
                    prevReadingYear--;
                }

                const prevReadingDay = getReadingDay(prevReadingYear, prevReadingMonth, arType);
                if (prevReadingDay === -1) {
                    console.error(`[getBillingPeriodDates] Failed to get previous reading day for ${prevReadingYear}-${prevReadingMonth}`);
                    return {
                        startDate: null,
                        endDate: null
                    };
                }

                billingPeriodStartDate = getBKKMidnightUTCAdjusted(prevReadingYear, prevReadingMonth - 1, prevReadingDay);
                billingPeriodStartDate.setMinutes(billingPeriodStartDate.getMinutes() + 15);


                const currentReadingDay = getReadingDay(selectedYear, selectedMonth, arType);
                if (currentReadingDay === -1) {
                    console.error(`[getBillingPeriodDates] Could not determine currentReadingDay for ${selectedYear}-${selectedMonth}`);
                    return {
                        startDate: null,
                        endDate: null
                    };
                }

                let thisMonthReadingDate = getBKKMidnightUTCAdjusted(selectedYear, selectedMonth - 1, currentReadingDay);
                billingPeriodEndDate = new Date(thisMonthReadingDate.getTime());
                billingPeriodEndDate.setUTCHours(0);
                billingPeriodEndDate.setUTCMinutes(0);
                billingPeriodEndDate.setUTCSeconds(0);
            }

            return {
                startDate: billingPeriodStartDate,
                endDate: billingPeriodEndDate
            };
        }


        function calculateAllMonthsSummariesAndMaxes(selectedArType, selectedDataType) {
            const calculatedMonthlySummaries = {};
            const calculatedMonthlyMaxValues = {};

            const applyMultiplierForSummaryCalculation = document.getElementById('applyMultiplier').checked;

            const decimalPlacesForKwSummary = 3;

            // First, determine all unique billing months present in the data for the selected AR type
            const uniqueBillingMonthYears = new Set();
            globalResults.forEach(r => {
                const bkkComponents = getBKKTimeComponents(r.dateObject);
                const calendarMonthKey = `${bkkComponents.year}-${(bkkComponents.month + 1).toString().padStart(2, '0')}`;
                uniqueBillingMonthYears.add(calendarMonthKey);
            });

            Array.from(uniqueBillingMonthYears).sort().forEach(monthKey => {
                const [yearStr, monthStr] = monthKey.split('-');
                const targetYear = parseInt(yearStr);
                const targetMonth = parseInt(monthStr);

                const { startDate, endDate } = getBillingPeriodDates(targetYear, targetMonth, selectedArType);

                if (!startDate || !endDate) {
                    return;
                }

                calculatedMonthlySummaries[monthKey] = {
                    'Peak': { wh: 0, varh: 0 },
                    'Off-peak': { wh: 0, varh: 0 },
                    'Holiday': { wh: 0, varh: 0 }
                };
                calculatedMonthlyMaxValues[monthKey] = {
                    'Peak': { wh: 0, varh: 0, wh_datetime: '', varh_datetime: '' },
                    'Off-peak': { wh: 0, varh: 0, wh_datetime: '', varh_datetime: '' },
                    'Holiday': { wh: 0, varh: 0, wh_datetime: '', varh_datetime: '' }
                };

                globalResults.forEach(r => {
                    const dateObjectBKK = r.dateObject;
                    if (dateObjectBKK.getTime() >= startDate.getTime() && dateObjectBKK.getTime() <= endDate.getTime()) {
                        const originalWhValue = selectedDataType === 'wh_import' ? r.originalWhImportValue : r.originalWhExportValue;
                        const originalVarhValue = r.originalVarhValue || 0;
                        const rate = getRate(dateObjectBKK);
                        const currentMultiplierForSummaryCalculation = applyMultiplierForSummaryCalculation ? r.rowMultiplier : 1;

                        const wh_sum_value = (originalWhValue * currentMultiplierForSummaryCalculation);
                        const varh_sum_value = (originalVarhValue * currentMultiplierForSummaryCalculation);

                        calculatedMonthlySummaries[monthKey][rate].wh += wh_sum_value;
                        calculatedMonthlySummaries[monthKey][rate].varh += varh_sum_value;

                        // Calculation for kW Max and kVar Max
                        const kW_calculated_base = customRound((Math.round(originalWhValue * 4) * currentMultiplierForSummaryCalculation / 1000), decimalPlacesForKwSummary);
                        const kVar_calculated_base = customRound((Math.round(originalVarhValue * 4) * currentMultiplierForSummaryCalculation / 1000), decimalPlacesForKwSummary);

                        if (kW_calculated_base > calculatedMonthlyMaxValues[monthKey][rate].wh ||
                            (kW_calculated_base === calculatedMonthlyMaxValues[monthKey][rate].wh &&
                                new Date(r.datetime) < new Date(calculatedMonthlyMaxValues[monthKey][rate].wh_datetime))) {
                            calculatedMonthlyMaxValues[monthKey][rate].wh = kW_calculated_base;
                            calculatedMonthlyMaxValues[monthKey][rate].wh_datetime = r.datetime;
                        }
                        if (kVar_calculated_base > calculatedMonthlyMaxValues[monthKey][rate].varh ||
                            (kVar_calculated_base === calculatedMonthlyMaxValues[monthKey][rate].varh &&
                                new Date(r.datetime) < new Date(calculatedMonthlyMaxValues[monthKey][rate].varh_datetime))) {
                            calculatedMonthlyMaxValues[monthKey][rate].varh = kVar_calculated_base;
                            calculatedMonthlyMaxValues[monthKey][rate].varh_datetime = r.datetime;
                        }
                    }
                });
            });

            return { monthlySummaries: calculatedMonthlySummaries, monthlyMaxValues: calculatedMonthlyMaxValues };
        }


        let monthlyCurrentPage = 1;
        const monthlyItemsPerPage = 7; // ‡πÅ‡∏™‡∏î‡∏á 12 ‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏ï‡πà‡∏≠‡∏´‡∏ô‡πâ‡∏≤ (‡∏õ‡∏£‡∏±‡∏ö‡πÑ‡∏î‡πâ)

        function renderMonthlySummaryTable(monthlySummariesToRender, monthlyMaxValuesToRender, selectedDataType) {
            if (!isProcessed || Object.keys(monthlySummariesToRender).length === 0) {
                return `
            <div class="summary-section">
                <h2 class="section-title">‡∏™‡∏£‡∏∏‡∏õ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏û‡∏•‡∏±‡∏á‡∏á‡∏≤‡∏ô‡∏£‡∏≤‡∏¢‡πÄ‡∏î‡∏∑‡∏≠‡∏ô</h2>
                <p>‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏û‡∏•‡∏±‡∏á‡∏á‡∏≤‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó AR ‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å</p>
            </div>
        `;
            }

            const wh_unit = selectedDataType === 'wh_import' ? 'kWh (Import)' : 'kWh (Export)';

            const monthNames = ["‡∏°.‡∏Ñ.", "‡∏Å.‡∏û.", "‡∏°‡∏µ.‡∏Ñ.", "‡πÄ‡∏°.‡∏¢.", "‡∏û.‡∏Ñ.", "‡∏°‡∏¥.‡∏¢.", "‡∏Å.‡∏Ñ.", "‡∏™.‡∏Ñ.", "‡∏Å.‡∏¢.", "‡∏ï.‡∏Ñ.", "‡∏û.‡∏¢.", "‡∏ò.‡∏Ñ."];
            const sortedMonthKeys = Object.keys(monthlySummariesToRender).sort((a, b) => {
                const [yearA, monthA] = a.split('-').map(Number);
                const [yearB, monthB] = b.split('-').map(Number);
                if (yearA !== yearB) return yearA - yearB;
                return monthA - monthB;
            });

            const totalPages = Math.ceil(sortedMonthKeys.length / monthlyItemsPerPage);
            if (monthlyCurrentPage > totalPages) monthlyCurrentPage = totalPages;

            const startIndex = (monthlyCurrentPage - 1) * monthlyItemsPerPage;
            const endIndex = startIndex + monthlyItemsPerPage;
            const monthKeysToShow = sortedMonthKeys.slice(startIndex, endIndex);

            let monthlyTableHtml = `
        <div class="summary-section">
        <h2 class="section-title">‡∏™‡∏£‡∏∏‡∏õ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏û‡∏•‡∏±‡∏á‡∏á‡∏≤‡∏ô‡∏£‡∏≤‡∏¢‡πÄ‡∏î‡∏∑‡∏≠‡∏ô</h2>
        <div class="monthly-summary-table-container">
        <table>
            <thead>
                <tr>
                    <th>‡πÄ‡∏î‡∏∑‡∏≠‡∏ô/‡∏õ‡∏µ</th>
                    <th>${wh_unit} (‡∏£‡∏ß‡∏°)</th>
                    <th>${wh_unit} (Peak)</th>
                    <th>${wh_unit} (Off-Peak)</th>
                    <th>${wh_unit} (Holiday)</th>
                    <th>kW Max(Peak)</th>
                    <th>kW Max(Off-Peak)</th>
                    <th>kW Max(Holiday)</th>
                    <th>kVar Max(‡∏£‡∏ß‡∏°‡∏ó‡∏∏‡∏Å‡πÄ‡∏£‡∏ó)</th>
                    <th>‡πÄ‡∏ß‡∏•‡∏≤ kW (peak) ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î</th>
                    <th>‡πÄ‡∏ß‡∏•‡∏≤ kW (Off-Peak) ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î</th>
                    <th>‡πÄ‡∏ß‡∏•‡∏≤ kW (Holiday) ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î</th>
                </tr>
            </thead>
            <tbody>
    `;

            const decimalPlacesForKwhSummary = 2;
            const decimalPlacesForKwSummary = 3;

            monthKeysToShow.forEach(monthKey => {
                const [yearStr, monthStr] = monthKey.split('-');
                const year = parseInt(yearStr);
                const monthIndex = parseInt(monthStr) - 1;

                const currentMonthSummary = monthlySummariesToRender[monthKey];
                const currentMonthMax = monthlyMaxValuesToRender[monthKey];

                const displayTotalWhMonth = customRound(((currentMonthSummary['Peak'].wh + currentMonthSummary['Off-peak'].wh + currentMonthSummary['Holiday'].wh) / 1000), decimalPlacesForKwhSummary);

                const displayPeakWh = customRound((currentMonthSummary['Peak'].wh / 1000), decimalPlacesForKwhSummary);
                const displayOffPeakWh = customRound((currentMonthSummary['Off-peak'].wh / 1000), decimalPlacesForKwhSummary);
                const displayHolidayWh = customRound((currentMonthSummary['Holiday'].wh / 1000), decimalPlacesForKwhSummary);

                const displayPeakKw = customRound(currentMonthMax['Peak'].wh, decimalPlacesForKwSummary);
                const displayOffPeakKw = customRound(currentMonthMax['Off-peak'].wh, decimalPlacesForKwSummary);
                const displayHolidayKw = customRound(currentMonthMax['Holiday'].wh, decimalPlacesForKwSummary);

                let baseMaxKvarMonthOverall = 0;
                ['Peak', 'Off-peak', 'Holiday'].forEach(rate => {
                    if (currentMonthMax[rate].varh > baseMaxKvarMonthOverall) {
                        baseMaxKvarMonthOverall = currentMonthMax[rate].varh;
                    }
                });
                const displayMaxKvarMonthOverall = customRound(baseMaxKvarMonthOverall, decimalPlacesForKwSummary);

                monthlyTableHtml += `
            <tr>
                <td>${monthNames[monthIndex]} ${year + 543}</td>
                <td>${displayTotalWhMonth.toFixed(decimalPlacesForKwhSummary)}</td>
                <td>${displayPeakWh.toFixed(decimalPlacesForKwhSummary)}</td>
                <td>${displayOffPeakWh.toFixed(decimalPlacesForKwhSummary)}</td>
                <td>${displayHolidayWh.toFixed(decimalPlacesForKwhSummary)}</td>
                <td>${displayPeakKw.toFixed(decimalPlacesForKwSummary)}</td>
                <td>${displayOffPeakKw.toFixed(decimalPlacesForKwSummary)}</td>
                <td>${displayHolidayKw.toFixed(decimalPlacesForKwSummary)}</td>
                <td>${displayMaxKvarMonthOverall.toFixed(decimalPlacesForKwSummary)}</td>
                <td><small>${currentMonthMax['Peak'].wh_datetime || 'N/A'}</small></td>
                <td><small>${currentMonthMax['Off-peak'].wh_datetime || 'N/A'}</small></td>
                <td><small>${currentMonthMax['Holiday'].wh_datetime || 'N/A'}</small></td>
            </tr>
        `;
            });

            monthlyTableHtml += `
            </tbody>
        </table>
        </div>
    `;

            monthlyTableHtml += `
    <div class="pagination-controls">
        <button onclick="changeMonthlyPage(-1)" ${monthlyCurrentPage === 1 ? 'disabled' : ''}>&lt;</button>
        <span>‡∏´‡∏ô‡πâ‡∏≤ ${monthlyCurrentPage} / ${totalPages}</span>
        <button onclick="changeMonthlyPage(1)" ${monthlyCurrentPage === totalPages ? 'disabled' : ''}>&gt;</button>
    </div>
    </div>
`;

            return monthlyTableHtml;
        }

        function changeMonthlyPage(direction) {
            monthlyCurrentPage += direction;
            updateDisplay(); // re-render ‡πÉ‡∏´‡∏°‡πà
        }


        function renderResultsAsHtml(unitType, selectedMonthYear, selectedArType, selectedDataType) {
            if (!isProcessed) return '';

            let whUnit, varhUnit;
            const applyMultiplier = document.getElementById('applyMultiplier').checked;

            let whCalculation, varhCalculation;
            let decimalPlacesForSummary;
            let decimalPlacesForTable;

            if (unitType === 'kw_kvar') {
                whUnit = 'kW';
                varhUnit = 'kVar';
                decimalPlacesForSummary = 3;
                decimalPlacesForTable = 3;

                whCalculation = (wh_val_raw, currentMultiplier) => {
                    const roundedWhTimesFour = Math.round(parseFloat(wh_val_raw) * 4);
                    return customRound((roundedWhTimesFour * currentMultiplier / 1000), decimalPlacesForTable);
                };
                varhCalculation = (varh_val_raw, currentMultiplier) => {
                    const roundedVarhTimesFour = Math.round(parseFloat(varh_val_raw) * 4);
                    return customRound((roundedVarhTimesFour * currentMultiplier / 1000), decimalPlacesForTable);
                };
            } else {
                whUnit = selectedDataType === 'wh_import' ? 'Wh Import' : 'Wh Export';
                varhUnit = 'Varh';
                decimalPlacesForSummary = 2;
                decimalPlacesForTable = 5;

                whCalculation = (wh_val_raw, currentMultiplier) => {
                    return customRound((parseFloat(wh_val_raw) * currentMultiplier), decimalPlacesForTable);
                };

                varhCalculation = (varh_val_raw, currentMultiplier) => {
                    return customRound((parseFloat(varh_val_raw) * currentMultiplier), decimalPlacesForTable);
                };
            }

            let tableRowsHtml = '';

            let overallMaxBaseKwCalculated = { value: 0, datetime: '' };
            let overallMaxBaseKvarCalculated = { value: 0, datetime: '' };

            let filteredResults = [];
            if (selectedMonthYear === 'all') {
                filteredResults = [...globalResults];
            } else {
                const [yearStr, monthStr] = selectedMonthYear.split('-');
                const selectedMonthInt = parseInt(monthStr);
                const selectedYearInt = parseInt(yearStr);

                filteredResults = globalResults.filter(r => {
                    const isWithinBillingPeriod = isInBillingPeriod(r.dateObject, selectedArType, selectedMonthInt, selectedYearInt);
                    return isWithinBillingPeriod;
                });
            }

            const dataToRender = [...filteredResults];
            if (sortState.columnIndex !== null) {
                const directionModifier = sortState.direction === 'asc' ? 1 : -1;
                const selectedUnit = document.getElementById('unitSelector').value;
                const applyMultiplierForSort = document.getElementById('applyMultiplier').checked;

                let whUnitConverterForSort, varhUnitConverterForSort;
                if (selectedUnit === 'kw_kvar') {
                    whUnitConverterForSort = (wh_val, mult) => (Math.round(parseFloat(wh_val) * 4) / 1000) * mult;
                    varhUnitConverterForSort = (varh_val, mult) => (Math.round(parseFloat(varh_val) * 4) / 1000) * mult;
                } else {
                    whUnitConverterForSort = (wh_val, mult) => (parseFloat(wh_val) * mult);
                    varhUnitConverterForSort = (varh_val, mult) => (parseFloat(varh_val) * mult);
                }

                dataToRender.sort((a, b) => {
                    let valA, valB;
                    const multA = applyMultiplierForSort ? a.rowMultiplier : 1;
                    const multB = applyMultiplierForSort ? b.rowMultiplier : 1;
                    let wh_val_A = selectedDataType === 'wh_import' ? a.originalWhImportValue : a.originalWhExportValue;
                    let wh_val_B = selectedDataType === 'wh_import' ? b.originalWhImportValue : b.originalWhExportValue;

                    switch (sortState.columnIndex) {
                        case 0:
                            valA = a.dateObject.getTime();
                            valB = b.dateObject.getTime();
                            break;
                        case 1:
                            valA = getRate(a.dateObject);
                            valB = getRate(b.dateObject);
                            const rateOrder = {
                                'Holiday': 1,
                                'Off-peak': 2,
                                'Peak': 3
                            };
                            return (rateOrder[valA] - rateOrder[valB]) * directionModifier;
                        case 2:
                            valA = whUnitConverterForSort(wh_val_A, multA);
                            valB = whUnitConverterForSort(wh_val_B, multB);
                            break;
                        case 3:
                            valA = varhUnitConverterForSort(a.originalVarhValue, multA);
                            valB = varhUnitConverterForSort(b.originalVarhValue, multB);
                            break;
                        case 4:
                            valA = a.rowMultiplier;
                            valB = b.rowMultiplier;
                            break;
                        default:
                            return 0;
                    }

                    if (typeof valA === 'string') {
                        return valA.localeCompare(valB) * directionModifier;
                    } else {
                        return (valA - valB) * directionModifier;
                    }
                });
            }

            let peakMaxKwAll, offPeakMaxKwAll, holidayMaxKwAll;
            let peakMaxKvarAll, offPeakMaxKvarAll, holidayMaxKvarAll;

            if (selectedMonthYear === 'all') {
                const maxes = {
                    'Peak': { wh: 0, varh: 0, wh_datetime: '', varh_datetime: '' },
                    'Off-peak': { wh: 0, varh: 0, wh_datetime: '', varh_datetime: '' },
                    'Holiday': { wh: 0, varh: 0, wh_datetime: '', varh_datetime: '' }
                };

                dataToRender.forEach(r => {
                    const rawWh = selectedDataType === 'wh_import' ? r.originalWhImportValue : r.originalWhExportValue;
                    const rawVarh = r.originalVarhValue || 0;
                    const currentMultiplier = applyMultiplier ? r.rowMultiplier : 1;
                    const rate = getRate(r.dateObject);

                    const kW_calculated = customRound((Math.round(rawWh * 4) * currentMultiplier / 1000), 3);
                    const kVar_calculated = customRound((Math.round(rawVarh * 4) * currentMultiplier / 1000), 3);

                    if (kW_calculated > maxes[rate].wh) {
                        maxes[rate].wh = kW_calculated;
                        maxes[rate].wh_datetime = r.datetime;
                    }
                    if (kVar_calculated > maxes[rate].varh) {
                        maxes[rate].varh = kVar_calculated;
                        maxes[rate].varh_datetime = r.datetime;
                    }
                });

                peakMaxKwAll = maxes['Peak'].wh;
                offPeakMaxKwAll = maxes['Off-peak'].wh;
                holidayMaxKwAll = maxes['Holiday'].wh;
                peakMaxKvarAll = maxes['Peak'].varh;
                offPeakMaxKvarAll = maxes['Off-peak'].varh;
                holidayMaxKvarAll = maxes['Holiday'].varh;
            }


            dataToRender.forEach(r => {
                const rawWh = selectedDataType === 'wh_import' ? r.originalWhImportValue : r.originalWhExportValue;
                const rawVarh = r.originalVarhValue || 0;
                const currentMultiplier = applyMultiplier ? r.rowMultiplier : 1;

                if (unitType === 'kw_kvar') {
                    const currentCalculatedKwBase = (Math.round(rawWh * 4) / 1000) * currentMultiplier;
                    const currentCalculatedKvarBase = (Math.round(rawVarh * 4) / 1000) * currentMultiplier;

                    if (currentCalculatedKwBase > overallMaxBaseKwCalculated.value ||
                        (currentCalculatedKwBase === overallMaxBaseKwCalculated.value &&
                            new Date(r.datetime) < new Date(overallMaxBaseKwCalculated.datetime))) {
                        overallMaxBaseKwCalculated.value = currentCalculatedKwBase;
                        overallMaxBaseKwCalculated.datetime = r.datetime;
                    }

                    if (currentCalculatedKvarBase > overallMaxBaseKvarCalculated.value ||
                        (currentCalculatedKvarBase === overallMaxBaseKvarCalculated.value &&
                            new Date(r.datetime) < new Date(overallMaxBaseKvarCalculated.datetime))) {
                        overallMaxBaseKvarCalculated.value = currentCalculatedKvarBase;
                        overallMaxBaseKvarCalculated.datetime = r.datetime;
                    }
                }

                const currentWh = whCalculation(rawWh, currentMultiplier);
                const currentVarh = varhCalculation(rawVarh, currentMultiplier);

                let displayWhInTable, displayVarhInTable;
                displayWhInTable = currentWh.toFixed(decimalPlacesForTable);
                displayVarhInTable = currentVarh.toFixed(decimalPlacesForTable);

                let displayDatetime = r.datetime;
                const cls = getRate(r.dateObject).toLowerCase().replace('-', '');
                tableRowsHtml += `<tr class="${cls}">
            <td>${displayDatetime}</td><td>${getRate(r.dateObject)}</td>
            <td>${displayWhInTable}</td><td>${displayVarhInTable}</td>
            <td>${applyMultiplier ? r.rowMultiplier.toFixed(4) : 1}</td>
        </tr>`;
            });


            let mainSummaryHtml = '';

            mainSummaryHtml += '<div class="rate-summary-container">';

            if (unitType === 'kw_kvar') {
                const displayOverallMaxKw = customRound(overallMaxBaseKwCalculated.value, decimalPlacesForSummary);
                const displayOverallMaxKvar = customRound(overallMaxBaseKvarCalculated.value, decimalPlacesForSummary);

                let displayPeakMaxKw, displayOffPeakMaxKw, displayHolidayMaxKw;
                let displayPeakMaxKvar, displayOffPeakMaxKvar, displayHolidayMaxKvar;
                let peakKwDatetime, offPeakKwDatetime, holidayKwDatetime;
                let peakKvarDatetime, offPeakKvarDatetime, holidayKvarDatetime;


                if (selectedMonthYear !== 'all') {
                    const currentMonthMaxData = monthlyMaxValues[selectedMonthYear];
                    displayPeakMaxKw = customRound(currentMonthMaxData['Peak'].wh, decimalPlacesForSummary);
                    displayOffPeakMaxKw = customRound(currentMonthMaxData['Off-peak'].wh, decimalPlacesForSummary);
                    displayHolidayMaxKw = customRound(currentMonthMaxData['Holiday'].wh, decimalPlacesForSummary);
                    displayPeakMaxKvar = customRound(currentMonthMaxData['Peak'].varh, decimalPlacesForSummary);
                    displayOffPeakMaxKvar = customRound(currentMonthMaxData['Off-peak'].varh, decimalPlacesForSummary);
                    displayHolidayMaxKvar = customRound(currentMonthMaxData['Holiday'].varh, decimalPlacesForSummary);
                    peakKwDatetime = currentMonthMaxData['Peak'].wh_datetime;
                    offPeakKwDatetime = currentMonthMaxData['Off-peak'].wh_datetime;
                    holidayKwDatetime = currentMonthMaxData['Holiday'].wh_datetime;
                    peakKvarDatetime = currentMonthMaxData['Peak'].varh_datetime;
                    offPeakKvarDatetime = currentMonthMaxData['Off-peak'].varh_datetime;
                    holidayKvarDatetime = currentMonthMaxData['Holiday'].varh_datetime;
                } else {
                    displayPeakMaxKw = customRound(peakMaxKwAll, decimalPlacesForSummary);
                    displayOffPeakMaxKw = customRound(offPeakMaxKwAll, decimalPlacesForSummary);
                    displayHolidayMaxKw = customRound(holidayMaxKwAll, decimalPlacesForSummary);
                    displayPeakMaxKvar = customRound(peakMaxKvarAll, decimalPlacesForSummary);
                    displayOffPeakMaxKvar = customRound(offPeakMaxKvarAll, decimalPlacesForSummary);
                    displayHolidayMaxKvar = customRound(holidayMaxKvarAll, decimalPlacesForSummary);
                    peakKwDatetime = 'N/A';
                    offPeakKwDatetime = 'N/A';
                    holidayKwDatetime = 'N/A';
                    peakKvarDatetime = 'N/A';
                    offPeakKvarDatetime = 'N/A';
                    holidayKvarDatetime = 'N/A';
                }

                mainSummaryHtml += `
            <div class="summary-box overall-max-summary">
                <h3>kW/kVar ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î‡∏£‡∏ß‡∏°‡∏ó‡∏∏‡∏Å‡πÄ‡∏£‡∏ó</h3>
                <p>kW: <strong>${displayOverallMaxKw.toFixed(decimalPlacesForSummary)} ${whUnit}</strong><br>
                <small>‡πÄ‡∏°‡∏∑‡πà‡∏≠: ${overallMaxBaseKwCalculated.datetime || 'N/A'}</small></p>
                <p>kVar: <strong>${displayOverallMaxKvar.toFixed(decimalPlacesForSummary)} ${varhUnit}</strong><br>
                <small>‡πÄ‡∏°‡∏∑‡πà‡∏≠: ${overallMaxBaseKvarCalculated.datetime || 'N/A'}</small></p>
            </div>
            <div class="summary-box max-kw-peak-summary summary-peak">
                <h3>kW/kVar ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î (Peak)</h3>
                <p>kW: <strong>${displayPeakMaxKw !== 'N/A' ? displayPeakMaxKw.toFixed(decimalPlacesForSummary) : 'N/A'} ${whUnit}</strong><br>
                <small>‡πÄ‡∏°‡∏∑‡πà‡∏≠: ${peakKwDatetime}</small></p>
                <p>kVar: <strong>${displayPeakMaxKvar !== 'N/A' ? displayPeakMaxKvar.toFixed(decimalPlacesForSummary) : 'N/A'} ${varhUnit}</strong><br>
                <small>‡πÄ‡∏°‡∏∑‡πà‡∏≠: ${peakKvarDatetime}</small></p>
            </div>
            <div class="summary-box max-kw-off-peak-summary summary-off-peak">
                <h3>kW/kVar ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î (Off-peak)</h3>
                <p>kW: <strong>${displayOffPeakMaxKw !== 'N/A' ? displayOffPeakMaxKw.toFixed(decimalPlacesForSummary) : 'N/A'} ${whUnit}</strong><br>
                <small>‡πÄ‡∏°‡∏∑‡πà‡∏≠: ${offPeakKwDatetime}</small></p>
                <p>kVar: <strong>${displayOffPeakMaxKvar !== 'N/A' ? displayOffPeakMaxKvar.toFixed(decimalPlacesForSummary) : 'N/A'} ${varhUnit}</strong><br>
                <small>‡πÄ‡∏°‡∏∑‡πà‡∏≠: ${offPeakKvarDatetime}</small></p>
            </div>
            <div class="summary-box max-kw-holiday-summary summary-holiday">
                <h3>kW/kVar ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î (Holiday)</h3>
                <p>kW: <strong>${displayHolidayMaxKw !== 'N/A' ? displayHolidayMaxKw.toFixed(decimalPlacesForSummary) : 'N/A'} ${whUnit}</strong><br>
                <small>‡πÄ‡∏°‡∏∑‡πà‡∏≠: ${holidayKwDatetime}</small></p>
                <p>kVar: <strong>${displayHolidayMaxKvar !== 'N/A' ? displayHolidayMaxKvar.toFixed(decimalPlacesForSummary) : 'N/A'} ${varhUnit}</strong><br>
                <small>‡πÄ‡∏°‡∏∑‡πà‡∏≠: ${holidayKvarDatetime}</small></p>
            </div>
        `;
            }

            mainSummaryHtml += '</div>';

            const headers = [{
                title: '‡∏ß‡∏±‡∏ô‡πÄ‡∏ß‡∏•‡∏≤',
                index: 0
            }, {
                title: '‡πÄ‡∏£‡∏ó',
                index: 1
            }, {
                title: whUnit,
                index: 2
            }, {
                title: varhUnit,
                index: 3
            }, {
                title: '‡∏ï‡∏±‡∏ß‡∏Ñ‡∏π‡∏ì',
                index: 4
            }];

            const headerHtml = headers.map(h => {
                const isActiveSort = sortState.columnIndex !== null && sortState.columnIndex === h.index;
                const sortClass = isActiveSort ? `active-sort ${sortState.direction}` : '';
                return `<th class="sortable ${sortClass}" onclick="sortTable(${h.index})" data-column-index="${h.index}">
                ${h.title} <span class="sort-indicator"></span>
            </th>`;
            }).join('');

            let tableHtml = `<h2 class="section-title">‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏£‡∏≤‡∏¢ 15 ‡∏ô‡∏≤‡∏ó‡∏µ</h2><table><tr>${headerHtml}</tr>${tableRowsHtml}</table>`;

            return mainSummaryHtml + tableHtml;
        }

        async function process() {
            if (isProcessed) {
                console.log("File already processed. Skipping re-processing.");
                return;
            }

            collectHolidays();
            const file = excelFileInput.files[0];
            if (!file) {
                alert("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏ü‡∏•‡πå Excel ‡∏´‡∏£‡∏∑‡∏≠‡∏•‡∏≤‡∏Å‡πÑ‡∏ü‡∏•‡πå‡∏°‡∏≤‡∏ß‡∏≤‡∏á‡∏Å‡πà‡∏≠‡∏ô‡∏Ñ‡∏£‡∏±‡∏ö/‡∏Ñ‡πà‡∏∞");
                return;
            }

            dropArea.innerHTML = `<span class="icon" style="color: #28a745;">‚úÖ</span><p>‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å: <strong>${file.name}</strong></p>`;
            document.getElementById('output').innerHTML = '<p>‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÑ‡∏ü‡∏•‡πå...</p>';


            const reader = new FileReader();
            reader.onload = function (e) {
                const data = new Uint8Array(e.target.result);
                const wb = XLSX.read(data, {
                    type: 'array',
                    cellDates: true
                });
                const sheet = wb.Sheets[wb.SheetNames[0]];

                let startRowForData = 3;
                let rawDateCol, whImportCol, whExportCol, varhCol;
                let isCompactFormat = false;

                // **************************************************
                // ‡∏Å‡∏≥‡∏´‡∏ô‡∏î Index ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Voltage A, B, C (‡πÄ‡∏î‡∏¥‡∏°)
                // ‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå I = Index 8, ‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå J = Index 9, ‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå K = Index 10
                // **************************************************
                const voltageACol = 8;
                const voltageBCol = 9;
                const voltageCCol = 10;
                // **************************************************

                // **************************************************
                // ‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏°: ‡∏Å‡∏≥‡∏´‡∏ô‡∏î Index ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Current A, B, C
                // ‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå L = Index 11, ‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå M = Index 12, ‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå N = Index 13
                // **************************************************
                const currentACol = 11;
                const currentBCol = 12;
                const currentCCol = 13;
                // **************************************************

                const headerRowCompact = XLSX.utils.sheet_to_json(sheet, { header: 1, range: 'A1:C1' })[0];
                // console.log("Header row for compact check:", headerRowCompact); // Commented out for cleaner console

                if (headerRowCompact &&
                    headerRowCompact[0] === 'DATE_M' &&
                    headerRowCompact[1] === 'WH' &&
                    headerRowCompact[2] === 'VARHIMP Total') {

                    console.log("Detected compact format (3 columns).");
                    isCompactFormat = true;
                    startRowForData = 1;
                    rawDateCol = 0;
                    whImportCol = 1;
                    whExportCol = null;
                    varhCol = 2;

                    meterNumber = 'N/A (Compact File)';
                } else {
                    console.log("Detected standard format.");
                    isCompactFormat = false;
                    startRowForData = 3;
                    rawDateCol = 2;
                    whImportCol = 26;
                    whExportCol = 30; // Column AE
                    varhCol = 34;

                    if (sheet['A4'] && sheet['A4'].v !== undefined) {
                        meterNumber = sheet['A4'].v.toString();
                    } else {
                        meterNumber = 'N/A';
                    }
                }


                const rows = XLSX.utils.sheet_to_json(sheet, {
                    header: 1
                });

                globalResults = [];
                isProcessed = false;

                for (let i = startRowForData; i < rows.length; i++) {
                    const rawDate = rows[i][rawDateCol];
                    const originalWhImportValue = parseFloat(rows[i][whImportCol]) || 0;
                    const originalWhExportValue = whExportCol !== null ? parseFloat(rows[i][whExportCol]) || 0 : 0;
                    const originalVarhValue = parseFloat(rows[i][varhCol]) || 0;

                    // **************************************************
                    // ‡πÇ‡∏Ñ‡πâ‡∏î‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• Voltage (‡πÄ‡∏î‡∏¥‡∏°)
                    // **************************************************
                    let voltageA = 0;
                    let voltageB = 0;
                    let voltageC = 0;

                    // ‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏°: ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• Current
                    let currentA = 0;
                    let currentB = 0;
                    let currentC = 0;

                    if (!isCompactFormat) {
                        voltageA = parseFloat(rows[i][voltageACol]) || 0; // ‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå I
                        voltageB = parseFloat(rows[i][voltageBCol]) || 0; // ‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå J
                        voltageC = parseFloat(rows[i][voltageCCol]) || 0; // ‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå K

                        // ‚úÖ ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• Current ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏õ‡πá‡∏ô Standard Format
                        currentA = parseFloat(rows[i][currentACol]) || 0; // ‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå L (Index 11)
                        currentB = parseFloat(rows[i][currentBCol]) || 0; // ‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå M (Index 12)
                        currentC = parseFloat(rows[i][currentCCol]) || 0; // ‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå N (Index 13)
                    }
                    // **************************************************

                    if (!rawDate || (isNaN(originalWhImportValue) && isNaN(originalWhExportValue)) || isNaN(originalVarhValue)) continue;

                    let dateObjectBKK = convertExcelDateToBKKUTCAdjusted(rawDate);
                    if (!dateObjectBKK) continue;

                    // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÇ‡∏Ñ‡πâ‡∏î‡∏™‡πà‡∏ß‡∏ô‡∏ô‡∏µ‡πâ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏ï‡∏±‡∏ß‡∏Ñ‡∏π‡∏ì‡∏Ç‡∏≠‡∏á‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏ö‡∏£‡∏£‡∏ó‡∏±‡∏î
                    let rowMultiplier = 0;
                    if (!isCompactFormat) {
                        const e_val = parseFloat(rows[i][4]) || 0; // Column E (index 4)
                        const f_val = parseFloat(rows[i][5]) || 0; // Column F (index 5)
                        const g_val = parseFloat(rows[i][6]) || 0; // Column G (index 6)
                        const h_val = parseFloat(rows[i][7]) || 0; // Column H (index 7)

                        if (f_val !== 0 && h_val !== 0) {
                            rowMultiplier = (e_val / f_val) * (g_val / h_val);
                        }
                    } else {
                        rowMultiplier = 1; // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÑ‡∏ü‡∏•‡πå‡πÅ‡∏ö‡∏ö compact
                    }

                    const totalMinutesFromBKKMidnight = dateObjectBKK.getUTCHours() * 60 + dateObjectBKK.getUTCMinutes() + dateObjectBKK.getUTCSeconds() / 60;
                    const roundedTotalMinutesBKK = Math.round(totalMinutesFromBKKMidnight / 15) * 15;

                    const roundedDateObjectUTC = new Date(Date.UTC(
                        dateObjectBKK.getUTCFullYear(),
                        dateObjectBKK.getUTCMonth(),
                        dateObjectBKK.getUTCDate(),
                        0,
                        roundedTotalMinutesBKK,
                        0, 0
                    ));

                    const displayBkkComponents = getBKKTimeComponents(roundedDateObjectUTC);
                    const formattedDatetime = `${displayBkkComponents.year}/${(displayBkkComponents.month + 1).toString().padStart(2, '0')}/${displayBkkComponents.day.toString().padStart(2, '0')} ${displayBkkComponents.hour.toString().padStart(2, '0')}:${displayBkkComponents.minute.toString().padStart(2, '0')}:00`;

                    globalResults.push({
                        datetime: formattedDatetime,
                        originalWhImportValue: originalWhImportValue,
                        originalWhExportValue: originalWhExportValue,
                        originalVarhValue: originalVarhValue,
                        dateObject: roundedDateObjectUTC,
                        rowMultiplier: rowMultiplier,

                        // ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• Voltage (‡πÄ‡∏î‡∏¥‡∏°)
                        voltage_a: voltageA,
                        voltage_b: voltageB,
                        voltage_c: voltageC,

                        // **************************************************
                        // ‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏°: ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• Current ‡πÄ‡∏Ç‡πâ‡∏≤‡πÑ‡∏õ‡πÉ‡∏ô globalResults
                        // **************************************************
                        current_a: currentA,
                        current_b: currentB,
                        current_c: currentC
                        // **************************************************
                    });
                }

                isProcessed = true;
                sortState.columnIndex = null;
                sortState.direction = 'asc';

                populateMonthYearSelector();
                updateDisplay();
            };
            reader.readAsArrayBuffer(file);
        }

        // ‡∏õ‡∏£‡∏∞‡∏Å‡∏≤‡∏®‡πÉ‡∏ô‡∏™‡πà‡∏ß‡∏ô‡∏ö‡∏ô‡∏Ç‡∏≠‡∏á <script> ‡∏Å‡πà‡∏≠‡∏ô‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏≠‡∏∑‡πà‡∏ô ‡πÜ
        let monthlyIntervalDataForExport = {};



        function updateDisplay() {
            // ‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏±‡πà‡∏ô‡πÉ‡∏à‡∏ß‡πà‡∏≤ isProcessed ‡∏ñ‡∏π‡∏Å‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô true ‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÑ‡∏ü‡∏•‡πå‡πÅ‡∏•‡πâ‡∏ß
            if (!isProcessed) {
                return;
            }

            const selectedMonthYear = document.getElementById('monthYearSelector').value;
            const selectedArType = document.getElementById('arTypeSelector').value;
            const selectedUnit = document.getElementById('unitSelector').value;
            const selectedDataType = document.getElementById('dataTypeSelector').value;
            const applyMultiplier = document.getElementById('applyMultiplier').checked; // ‡∏î‡∏∂‡∏á‡∏Ñ‡πà‡∏≤‡∏ï‡∏±‡∏ß‡∏Ñ‡∏π‡∏ì

            console.log(`[updateDisplay] User selected Month/Year: ${selectedMonthYear}, AR Type: ${selectedArType}, Data Type: ${selectedDataType}`);

            const outputDiv = document.getElementById('output');
            outputDiv.innerHTML = ''; // ‡∏•‡πâ‡∏≤‡∏á‡πÄ‡∏ô‡∏∑‡πâ‡∏≠‡∏´‡∏≤‡πÄ‡∏Å‡πà‡∏≤‡πÉ‡∏ô outputDiv

            // ‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏±‡πà‡∏ô‡πÉ‡∏à‡∏ß‡πà‡∏≤ calculateAllMonthsSummariesAndMaxes ‡πÄ‡∏õ‡πá‡∏ô‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÑ‡∏î‡πâ
            const { monthlySummaries: calculatedMonthlySummaries, monthlyMaxValues: calculatedMonthlyMaxValues } =
                calculateAllMonthsSummariesAndMaxes(selectedArType, selectedDataType);

            // ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏Ñ‡πà‡∏≤‡πÉ‡∏´‡πâ‡∏Å‡∏±‡∏ö Global Variables (‡∏ñ‡πâ‡∏≤‡∏°‡∏µ)
            monthlySummaries = calculatedMonthlySummaries;
            monthlyMaxValues = calculatedMonthlyMaxValues;

            // ‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏™‡∏£‡∏∏‡∏õ‡∏£‡∏≤‡∏¢‡πÄ‡∏î‡∏∑‡∏≠‡∏ô (‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏±‡πà‡∏ô‡πÉ‡∏à‡∏ß‡πà‡∏≤ renderMonthlySummaryTable ‡πÄ‡∏õ‡πá‡∏ô‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÑ‡∏î‡πâ)
            outputDiv.innerHTML += renderMonthlySummaryTable(monthlySummaries, monthlyMaxValues, selectedDataType);

            const summaryBoxWrapper = document.createElement('div');
            summaryBoxWrapper.className = 'summary-box-wrapper column-layout';

            // -----------------------------------------------------
            // ‡∏™‡πà‡∏ß‡∏ô‡∏ó‡∏µ‡πà 1: Meter Info ‡πÅ‡∏•‡∏∞ Multiplier Ranges
            // -----------------------------------------------------
            let multiplierInfoHtml = '<p>‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡∏±‡∏ß‡∏Ñ‡∏π‡∏ì: <strong>N/A</strong></p>';
            if (globalResults.length > 0) {
                const multiplierRanges = {};
                globalResults.forEach(r => {
                    const multiplier = r.rowMultiplier.toFixed(4);
                    const datetime = r.datetime;
                    if (!multiplierRanges[multiplier]) {
                        multiplierRanges[multiplier] = {
                            start: datetime,
                            end: datetime
                        };
                    } else {
                        const currentDt = new Date(datetime);
                        if (currentDt < new Date(multiplierRanges[multiplier].start)) {
                            multiplierRanges[multiplier].start = datetime;
                        }
                        if (currentDt > new Date(multiplierRanges[multiplier].end)) {
                            multiplierRanges[multiplier].end = datetime;
                        }
                    }
                });

                if (Object.keys(multiplierRanges).length > 0) {
                    let rangesHtml = '<ul class="multiplier-list">';
                    for (const mult in multiplierRanges) {
                        if (multiplierRanges.hasOwnProperty(mult)) {
                            const range = multiplierRanges[mult];
                            rangesHtml += `<li><strong>‡∏ï‡∏±‡∏ß‡∏Ñ‡∏π‡∏ì ${mult}</strong><br>‡∏ï‡∏±‡πâ‡∏á‡πÅ‡∏ï‡πà ${range.start}<br>‡∏ñ‡∏∂‡∏á ${range.end}</li>`;
                        }
                    }
                    rangesHtml += '</ul>';
                    multiplierInfoHtml = `<div class="multiplier-info">
                <p><strong>‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡∏±‡∏ß‡∏Ñ‡∏π‡∏ì:</strong></p>
                ${rangesHtml}
            </div>`;
                }
            }

            // ‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏±‡πà‡∏ô‡πÉ‡∏à‡∏ß‡πà‡∏≤ meterNumber ‡πÄ‡∏õ‡πá‡∏ô Global Variable
            const meterInfoHtml = `
        <div class="summary-box meter-info">
            <h3>‡∏™‡∏£‡∏∏‡∏õ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏°‡∏¥‡πÄ‡∏ï‡∏≠‡∏£‡πå‡πÅ‡∏•‡∏∞‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏û‡∏•‡∏±‡∏á‡∏á‡∏≤‡∏ô</h3>
            <p>‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏•‡∏Ç‡∏°‡∏¥‡πÄ‡∏ï‡∏≠‡∏£‡πå: <strong>${meterNumber || 'N/A'}</strong></p>
            ${multiplierInfoHtml}
        </div>`;
            summaryBoxWrapper.innerHTML += meterInfoHtml;

            // -----------------------------------------------------
            // ‡∏™‡πà‡∏ß‡∏ô‡∏ó‡∏µ‡πà 2: Interval Check (‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Å‡∏≤‡∏£‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç 31/30 ‡πÅ‡∏•‡∏∞‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞)
            // -----------------------------------------------------

            const billingPeriodInfoDiv = document.createElement('div');
            billingPeriodInfoDiv.className = 'summary-box billing-period-info';
            billingPeriodInfoDiv.innerHTML = '<h3>‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• Interval</h3>';

            const uniqueMonthYears = new Set();
            globalResults.forEach(r => {
                const { year, month } = getBKKTimeComponents(r.dateObject);
                uniqueMonthYears.add(`${year}-${(month + 1).toString().padStart(2, '0')}`);
            });

            const sortedUniqueMonthYears = Array.from(uniqueMonthYears).sort();
            const monthNames = ["‡∏°‡∏Å‡∏£‡∏≤‡∏Ñ‡∏°", "‡∏Å‡∏∏‡∏°‡∏†‡∏≤‡∏û‡∏±‡∏ô‡∏ò‡πå", "‡∏°‡∏µ‡∏ô‡∏≤‡∏Ñ‡∏°", "‡πÄ‡∏°‡∏©‡∏≤‡∏¢‡∏ô", "‡∏û‡∏§‡∏©‡∏†‡∏≤‡∏Ñ‡∏°", "‡∏°‡∏¥‡∏ñ‡∏∏‡∏ô‡∏≤‡∏¢‡∏ô", "‡∏Å‡∏£‡∏Å‡∏é‡∏≤‡∏Ñ‡∏°", "‡∏™‡∏¥‡∏á‡∏´‡∏≤‡∏Ñ‡∏°", "‡∏Å‡∏±‡∏ô‡∏¢‡∏≤‡∏¢‡∏ô", "‡∏ï‡∏∏‡∏•‡∏≤‡∏Ñ‡∏°", "‡∏û‡∏§‡∏®‡∏à‡∏¥‡∏Å‡∏≤‡∏¢‡∏ô", "‡∏ò‡∏±‡∏ô‡∏ß‡∏≤‡∏Ñ‡∏°"];

            const newMonthlyIntervalDataForExport = {};

            if (sortedUniqueMonthYears.length > 0) {
                let intervalListHtml = '<ul class="interval-list">';

                sortedUniqueMonthYears.forEach(monthKey => {
                    const [yearStr, monthStr] = monthKey.split('-');
                    const selectedMonthInt = parseInt(monthStr); // 1-12
                    const selectedYearInt = parseInt(yearStr);
                    const monthName = monthNames[selectedMonthInt - 1];

                    // --- BILLING PERIOD CALCULATION ---
                    const numDaysInMonth = getDaysInMonth(selectedYearInt, selectedMonthInt);

                    const { startDate, endDate } = getBillingPeriodDates(selectedYearInt, selectedMonthInt, selectedArType);

                    let expectedIntervalsInBillingPeriod = 0;
                    let expectedDaysInBillingPeriod = 0;
                    let billingPeriodLabel = `${numDaysInMonth} ‡∏ß‡∏±‡∏ô‡πÉ‡∏ô‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏õ‡∏è‡∏¥‡∏ó‡∏¥‡∏ô`;

                    if (startDate && endDate) {
                        const totalIntervalsMs = endDate.getTime() - startDate.getTime();
                        expectedIntervalsInBillingPeriod = Math.round(totalIntervalsMs / 900000);
                        expectedDaysInBillingPeriod = Math.round(totalIntervalsMs / 86400000);

                        const startBkk = getBKKTimeComponents(startDate);
                        const endBkk = getBKKTimeComponents(endDate);

                        billingPeriodLabel = `${expectedDaysInBillingPeriod} ‡∏ß‡∏±‡∏ô‡πÉ‡∏ô‡∏£‡∏≠‡∏ö‡∏ö‡∏¥‡∏• (‡∏≠‡πà‡∏≤‡∏ô‡∏à‡∏≤‡∏Å ${startBkk.day}/${startBkk.month + 1}/${startBkk.year + 543} ‡∏ñ‡∏∂‡∏á ${endBkk.day}/${endBkk.month + 1}/${endBkk.year + 543})`;
                    } else {
                        expectedDaysInBillingPeriod = numDaysInMonth;
                        expectedIntervalsInBillingPeriod = numDaysInMonth * 96;
                    }
                    // --- END BILLING PERIOD CALCULATION ---

                    // ** ‡∏ô‡∏±‡∏ö Actual Interval ‡πÅ‡∏•‡∏∞ Day Count **
                    let actualIntervals = 0;
                    const daysWithData = new Set();

                    globalResults.forEach(r => {
                        if (startDate && endDate && r.dateObject.getTime() >= startDate.getTime() && r.dateObject.getTime() <= endDate.getTime()) {
                            actualIntervals++;

                            const bkkComponents = getBKKTimeComponents(r.dateObject);
                            const dateKey = `${bkkComponents.year}-${(bkkComponents.month + 1).toString().padStart(2, '0')}-${bkkComponents.day.toString().padStart(2, '0')}`;
                            daysWithData.add(dateKey);
                        }
                    });

                    const actualDayCount = daysWithData.size; // ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏£‡∏¥‡∏á

                    // ** ‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏Ç‡∏≠‡∏á Day Count ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÑ‡∏°‡πà‡πÉ‡∏´‡πâ‡∏ï‡∏±‡∏ß‡πÄ‡∏®‡∏©‡πÄ‡∏Å‡∏¥‡∏ô‡∏ï‡∏±‡∏ß‡∏™‡πà‡∏ß‡∏ô **
                    const displayedDayCount = Math.min(actualDayCount, expectedDaysInBillingPeriod);

                    // ** Display logic update **
                    const intervalRatio = (expectedIntervalsInBillingPeriod > 0) ? actualIntervals / expectedIntervalsInBillingPeriod : 0;
                    const intervalRatioPercent = customRound(intervalRatio * 100, 2);

                    let dayCountWarning = '';
                    

                    // 2. ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÅ‡∏•‡∏∞‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡∏´‡∏•‡∏±‡∏Å (‡∏£‡∏ß‡∏°‡∏Å‡∏≤‡∏£‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏ï‡∏≤‡∏°‡∏Ñ‡∏≥‡∏Ç‡∏≠‡∏Ç‡∏≠‡∏á‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ: ‡πÑ‡∏°‡πà‡πÅ‡∏™‡∏î‡∏á ‚úÖ ‡πÄ‡∏°‡∏∑‡πà‡∏≠ Day Count ‡πÄ‡∏Å‡∏¥‡∏ô)
                    let statusClass = 'complete';
                    let statusText = '‚úÖ';

                    if (actualIntervals < expectedIntervalsInBillingPeriod) {
                        // ‡∏Å‡∏£‡∏ì‡∏µ‡∏ó‡∏µ‡πà 1: Interval ‡∏Ç‡∏≤‡∏î (‡∏°‡∏µ ‚ö†Ô∏è)
                        statusClass = 'warning';
                        statusText = '‚ö†Ô∏è';
                    } else if (actualDayCount > expectedDaysInBillingPeriod) {
                        // ‡∏Å‡∏£‡∏ì‡∏µ‡∏ó‡∏µ‡πà 2: Interval ‡∏Ñ‡∏£‡∏ö ‡πÅ‡∏ï‡πà Day Count ‡πÄ‡∏Å‡∏¥‡∏ô
                        // ‡∏•‡∏ö ‚úÖ ‡∏ï‡∏≤‡∏°‡∏Ñ‡∏≥‡∏Ç‡∏≠‡∏Ç‡∏≠‡∏á‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ ‡πÇ‡∏î‡∏¢‡∏Å‡∏≥‡∏´‡∏ô‡∏î statusText ‡πÄ‡∏õ‡πá‡∏ô‡∏™‡∏ï‡∏£‡∏¥‡∏á‡∏ß‡πà‡∏≤‡∏á
                        statusClass = 'anomaly';
                        statusText = '';
                    }

                    // ** ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏Ñ‡πà‡∏≤‡πÉ‡∏´‡πâ‡∏Å‡∏±‡∏ö Object ‡∏ä‡∏±‡πà‡∏ß‡∏Ñ‡∏£‡∏≤‡∏ß **
                    newMonthlyIntervalDataForExport[monthKey] = {
                        interval: `${actualIntervals}/${expectedIntervalsInBillingPeriod}`,
                        dayCount: `${displayedDayCount}/${expectedDaysInBillingPeriod}`,
                        dayDifference: actualDayCount - expectedDaysInBillingPeriod,
                        intervalRatioPercent: intervalRatioPercent.toFixed(2),
                        expectedDays: expectedDaysInBillingPeriod
                    };

                    intervalListHtml += `
                <li class="${statusClass}">
                    <strong>‡πÄ‡∏î‡∏∑‡∏≠‡∏ô ${monthName} ${selectedYearInt + 543}:</strong>
                    <span class="count">${actualIntervals} / ${expectedIntervalsInBillingPeriod} Interval</span>
                    <span class="count">(${displayedDayCount} / ${expectedDaysInBillingPeriod} ‡∏ß‡∏±‡∏ô)${dayCountWarning}</span>
                    <span class="status">${statusText}</span>
                </li>
            `;
                });

                intervalListHtml += '</ul>';
                billingPeriodInfoDiv.innerHTML += intervalListHtml;

                monthlyIntervalDataForExport = newMonthlyIntervalDataForExport;
            } else {
                billingPeriodInfoDiv.innerHTML += `<p>‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• Interval ‡πÉ‡∏ô‡πÑ‡∏ü‡∏•‡πå</p>`;
                monthlyIntervalDataForExport = {};
            }
            summaryBoxWrapper.appendChild(billingPeriodInfoDiv);


            // -----------------------------------------------------
            // ‡∏™‡πà‡∏ß‡∏ô‡∏ó‡∏µ‡πà 3: Consumption Summary (‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á)
            // -----------------------------------------------------
            const consumptionSummaryDiv = document.createElement('div');
            consumptionSummaryDiv.className = 'summary-box consumption-summary';
            let displayPeakWh = 0, displayPeakVarh = 0;
            let displayOffPeakWh = 0, displayOffPeakVarh = 0;
            let displayHolidayWh = 0, displayHolidayVarh = 0;
            let displayTotalWh = 0, displayTotalVarh = 0;
            const decimalPlacesForSummary = 2;

            if (selectedMonthYear !== 'all' && monthlySummaries[selectedMonthYear]) {
                const selectedMonthSummary = monthlySummaries[selectedMonthYear];
                displayPeakWh = selectedMonthSummary['Peak'].wh / 1000;
                displayPeakVarh = selectedMonthSummary['Peak'].varh / 1000;
                displayOffPeakWh = selectedMonthSummary['Off-peak'].wh / 1000;
                displayOffPeakVarh = selectedMonthSummary['Off-peak'].varh / 1000;
                displayHolidayWh = selectedMonthSummary['Holiday'].wh / 1000;
                displayHolidayVarh = selectedMonthSummary['Holiday'].varh / 1000;

                displayTotalWh = displayPeakWh + displayOffPeakWh + displayHolidayWh;
                displayTotalVarh = displayPeakVarh + displayOffPeakVarh + displayHolidayVarh;
            } else if (selectedMonthYear === 'all') {
                for (const monthKey in monthlySummaries) {
                    if (monthlySummaries.hasOwnProperty(monthKey)) {
                        const monthSummary = monthlySummaries[monthKey];
                        displayPeakWh += monthSummary['Peak'].wh / 1000;
                        displayPeakVarh += monthSummary['Peak'].varh / 1000;
                        displayOffPeakWh += monthSummary['Off-peak'].wh / 1000;
                        displayOffPeakVarh += monthSummary['Off-peak'].varh / 1000;
                        displayHolidayWh += monthSummary['Holiday'].wh / 1000;
                        displayHolidayVarh += monthSummary['Holiday'].varh / 1000;
                    }
                }
                displayTotalWh = displayPeakWh + displayOffPeakWh + displayHolidayWh;
                displayTotalVarh = displayPeakVarh + displayOffPeakVarh + displayHolidayVarh;
            }

            const whTitle = selectedDataType === 'wh_import' ? 'kWh (Import)' : 'kWh (Export)';

            consumptionSummaryDiv.innerHTML = `
        <h3>‡∏™‡∏£‡∏∏‡∏õ‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏û‡∏•‡∏±‡∏á‡∏á‡∏≤‡∏ô (‡∏£‡∏ß‡∏°)</h3>
        <div class="summary-list">
            <div class="summary-list-item peak-row">
                <span class="rate-label">‡∏£‡∏ß‡∏° Peak:</span>
                <span class="value-label"><strong>${displayPeakWh.toFixed(decimalPlacesForSummary)} kWh</strong>, <strong>${displayPeakVarh.toFixed(decimalPlacesForSummary)} kVarh</strong></span>
            </div>
            <div class="summary-list-item off-peak-row">
                <span class="rate-label">‡∏£‡∏ß‡∏° Off-peak:</span>
                <span class="value-label"><strong>${displayOffPeakWh.toFixed(decimalPlacesForSummary)} kWh</strong>, <strong>${displayOffPeakVarh.toFixed(decimalPlacesForSummary)} kVarh</strong></span>
            </div>
            <div class="summary-list-item holiday-row">
                <span class="rate-label">‡∏£‡∏ß‡∏° Holiday:</span>
                <span class="value-label"><strong>${displayHolidayWh.toFixed(decimalPlacesForSummary)} kWh</strong>, <strong>${displayHolidayVarh.toFixed(decimalPlacesForSummary)} kVarh</strong></span>
            </div>
            <div class="summary-list-item total-row">
                <span class="rate-label">‡∏£‡∏ß‡∏°‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î:</span>
                <span class="value-label"><strong>${displayTotalWh.toFixed(decimalPlacesForSummary)} kWh</strong>, <strong>${displayTotalVarh.toFixed(decimalPlacesForSummary)} kVarh</strong></span>
            </div>
        </div>
    `;

            summaryBoxWrapper.appendChild(consumptionSummaryDiv);

            outputDiv.appendChild(summaryBoxWrapper);

            // ‡πÅ‡∏™‡∏î‡∏á‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î 15 ‡∏ô‡∏≤‡∏ó‡∏µ
            outputDiv.innerHTML += renderResultsAsHtml(selectedUnit, selectedMonthYear, selectedArType, selectedDataType, applyMultiplier);

            updateExportButtonVisibility();

            // ‡∏ß‡∏≤‡∏î‡∏Å‡∏£‡∏≤‡∏ü 
            updateCharts();
        }

        // *****************************************************************
        // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£ Global ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏Å‡πá‡∏ö Instance ‡∏Ç‡∏≠‡∏á Chart.js
        // ****************************************************************

        let detailChartInstance = null;

        // *****************************************************************
        // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô updateCharts() ‡∏â‡∏ö‡∏±‡∏ö‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡πÉ‡∏´‡πâ‡∏Å‡∏£‡∏≤‡∏ü Voltage ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏ó‡∏µ‡πà 0
        // *****************************************************************
        function updateCharts() {
            // 1. ‡∏î‡∏∂‡∏á‡∏Ñ‡πà‡∏≤‡∏à‡∏≤‡∏Å‡∏ï‡∏±‡∏ß‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
            const selectedMonthYear = document.getElementById('monthYearSelector').value;
            const selectedDataType = document.getElementById('dataTypeSelector').value;
            const selectedArType = document.getElementById('arTypeSelector').value;
            const selectedUnit = document.getElementById('unitSelector').value;
            const applyMultiplier = document.getElementById('applyMultiplier').checked;

            // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô (‡∏™‡∏°‡∏°‡∏ï‡∏¥‡∏ß‡πà‡∏≤ isProcessed ‡πÅ‡∏•‡∏∞ monthlySummaries ‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà)
            if (!isProcessed || Object.keys(monthlySummaries).length === 0) {
                const detailChartContainer = document.getElementById('detail-chart-container');
                if (detailChartContainer) detailChartContainer.style.display = 'none';
                return;
            }

            const detailChartElement = document.getElementById('detailLineChart');
            const detailChartContainer = document.getElementById('detail-chart-container');
            if (!detailChartElement) return;
            const ctxDetail = detailChartElement.getContext('2d');

            if (detailChartInstance) detailChartInstance.destroy();

            // 2. ‡∏Å‡∏£‡∏≠‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡∏≤‡∏°‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å
            if (selectedMonthYear === 'all') {
                detailChartContainer.style.display = 'none';
                return;
            }

            const [yearStr, monthStr] = selectedMonthYear.split('-');
            const selectedMonthInt = parseInt(monthStr);
            const selectedYearInt = parseInt(yearStr);

            const filteredResults = globalResults.filter(r => {
                // ‡∏™‡∏°‡∏°‡∏ï‡∏¥‡∏ß‡πà‡∏≤‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô isInBillingPeriod() ‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á
                return isInBillingPeriod(r.dateObject, selectedArType, selectedMonthInt, selectedYearInt);
            });

            if (filteredResults.length === 0) {
                detailChartContainer.style.display = 'none';
                return;
            }

            // 3. ‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÅ‡∏•‡∏∞ Dataset (‡∏£‡∏ß‡∏°‡∏Å‡∏≤‡∏£‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö Voltage ‡πÅ‡∏•‡∏∞ Current)
            const labels = [];
            const dataRates = [];
            let datasets = [];
            let detailChartYAxisLabel = '';
            let detailChartTitle = '';
            let decimalPlacesForDetailChart = 5;
            let calculationFunction = null;
            let chartScales = {};

            const isWhData = selectedDataType.includes('wh');

            // **************************************************
            // START: ‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÅ‡∏•‡∏∞ Dataset ‡∏ï‡∏≤‡∏° Unit Type
            // **************************************************
            if (selectedUnit === 'voltage_abc') {
                // 3.1 ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Voltage A, B, C
                decimalPlacesForDetailChart = 2;
                detailChartYAxisLabel = 'Voltage (V)';
                detailChartTitle = `‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏£‡∏≤‡∏¢ 15 ‡∏ô‡∏≤‡∏ó‡∏µ (Voltage A, B, C) ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö ${document.getElementById('monthYearSelector').options[document.getElementById('monthYearSelector').selectedIndex].text}`;

                // ‡∏ß‡∏ô‡∏•‡∏π‡∏õ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏Å‡πá‡∏ö Labels
                filteredResults.forEach(r => {
                    labels.push(r.datetime.substring(5, 16));
                });

                // ‡∏™‡∏£‡πâ‡∏≤‡∏á Datasets ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Voltage A, B, C
                datasets.push({
                    label: 'Voltage A (V)',
                    data: filteredResults.map(r => r.voltage_a),
                    borderColor: 'rgba(255, 99, 132, 1)',
                    backgroundColor: 'rgba(255, 99, 132, 0.1)',
                    borderWidth: 1.5,
                    pointRadius: 0,
                    yAxisID: 'y'
                });
                datasets.push({
                    label: 'Voltage B (V)',
                    data: filteredResults.map(r => r.voltage_b),
                    borderColor: 'rgba(54, 162, 235, 1)',
                    backgroundColor: 'rgba(54, 162, 235, 0.1)',
                    borderWidth: 1.5,
                    pointRadius: 0,
                    yAxisID: 'y'
                });
                datasets.push({
                    label: 'Voltage C (V)',
                    data: filteredResults.map(r => r.voltage_c),
                    borderColor: 'rgba(75, 192, 192, 1)',
                    backgroundColor: 'rgba(75, 192, 192, 0.1)',
                    borderWidth: 1.5,
                    pointRadius: 0,
                    yAxisID: 'y'
                });

                // ‡∏Å‡∏≥‡∏´‡∏ô‡∏î Scales ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Voltage (‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏ó‡∏µ‡πà 0)
                chartScales = {
                    x: {
                        title: { display: true, text: '‡∏ß‡∏±‡∏ô‡πÄ‡∏ß‡∏•‡∏≤' },
                        ticks: { maxRotation: 90, minRotation: 90, autoSkip: true, maxTicksLimit: 30 }
                    },
                    y: {
                        beginAtZero: true,
                        title: { display: true, text: detailChartYAxisLabel },
                        min: 0,
                        max: 260,
                        ticks: {
                            callback: function (value) {
                                return value.toFixed(decimalPlacesForDetailChart);
                            }
                        }
                    }
                };


            } else if (selectedUnit === 'current_abc') { // ‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏°: ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Current A, B, C

                // 3.2 ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Current A, B, C
                decimalPlacesForDetailChart = 2;
                detailChartYAxisLabel = 'Current (A)';
                detailChartTitle = `‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏£‡∏≤‡∏¢ 15 ‡∏ô‡∏≤‡∏ó‡∏µ (Current A, B, C) ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö ${document.getElementById('monthYearSelector').options[document.getElementById('monthYearSelector').selectedIndex].text}`;

                // ‡∏ß‡∏ô‡∏•‡∏π‡∏õ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏Å‡πá‡∏ö Labels
                filteredResults.forEach(r => {
                    labels.push(r.datetime.substring(5, 16));
                });

                // ‡∏™‡∏£‡πâ‡∏≤‡∏á Datasets ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Current A, B, C
                datasets.push({
                    label: 'Current A (A)',
                    data: filteredResults.map(r => r.current_a),
                    // ‚úÖ ‡πÉ‡∏ä‡πâ‡∏™‡∏µ‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ö Voltage A (Reddish)
                    borderColor: 'rgba(255, 99, 132, 1)',
                    backgroundColor: 'rgba(255, 99, 132, 0.1)',
                    borderWidth: 1.5,
                    pointRadius: 0,
                    yAxisID: 'y'
                });
                datasets.push({
                    label: 'Current B (A)',
                    data: filteredResults.map(r => r.current_b),
                    // ‚úÖ ‡πÉ‡∏ä‡πâ‡∏™‡∏µ‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ö Voltage B (Blue)
                    borderColor: 'rgba(54, 162, 235, 1)',
                    backgroundColor: 'rgba(54, 162, 235, 0.1)',
                    borderWidth: 1.5,
                    pointRadius: 0,
                    yAxisID: 'y'
                });
                datasets.push({
                    label: 'Current C (A)',
                    data: filteredResults.map(r => r.current_c),
                    // ‚úÖ ‡πÉ‡∏ä‡πâ‡∏™‡∏µ‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ö Voltage C (Teal/Cyan)
                    borderColor: 'rgba(75, 192, 192, 1)',
                    backgroundColor: 'rgba(75, 192, 192, 0.1)',
                    borderWidth: 1.5,
                    pointRadius: 0,
                    yAxisID: 'y'
                });

                // ‡∏Å‡∏≥‡∏´‡∏ô‡∏î Scales ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Current (‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏ó‡∏µ‡πà 0)
                chartScales = {
                    x: {
                        title: { display: true, text: '‡∏ß‡∏±‡∏ô‡πÄ‡∏ß‡∏•‡∏≤' },
                        ticks: { maxRotation: 90, minRotation: 90, autoSkip: true, maxTicksLimit: 30 }
                    },
                    y: {
                        beginAtZero: true,
                        title: { display: true, text: detailChartYAxisLabel },
                        min: 0,
                        ticks: {
                            callback: function (value) {
                                return value.toFixed(decimalPlacesForDetailChart);
                            }
                        }
                    }
                };

            } else {
                // 3.3 ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö kW/kVar ‡∏´‡∏£‡∏∑‡∏≠ kWh/kVarh (‡πÇ‡∏Ñ‡πâ‡∏î‡πÄ‡∏î‡∏¥‡∏°)

                if (selectedUnit === 'kw_kvar') {
                    decimalPlacesForDetailChart = 3;
                    calculationFunction = (raw_val, currentMultiplier) => customRound((raw_val * currentMultiplier * 4) / 1000, decimalPlacesForDetailChart);
                    detailChartYAxisLabel = isWhData
                        ? (selectedDataType === 'wh_import' ? 'kW (Import/Export)' : 'kW (Import/Export)')
                        : (selectedDataType === 'varh_import' ? 'kVAR (Import/Export)' : 'kVAR (Import/Export)');

                } else { // kwh_kvarh
                    decimalPlacesForDetailChart = 5;
                    calculationFunction = (raw_val, currentMultiplier) => customRound((raw_val * currentMultiplier) / 1000, decimalPlacesForDetailChart);
                    detailChartYAxisLabel = isWhData
                        ? (selectedDataType === 'wh_import' ? 'kWh (Import/Export)' : 'kWh (Import/Export)')
                        : (selectedDataType === 'varh_import' ? 'kVARh (Import/Export)' : 'kVARh (Import/Export)');
                }

                detailChartTitle = `‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏£‡∏≤‡∏¢ 15 ‡∏ô‡∏≤‡∏ó‡∏µ (${detailChartYAxisLabel}) ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö ${document.getElementById('monthYearSelector').options[document.getElementById('monthYearSelector').selectedIndex].text}`;

                const dataSingle = [];
                filteredResults.forEach(r => {
                    const rawValue = isWhData
                        ? (selectedDataType === 'wh_import' ? r.originalWhImportValue : r.originalWhExportValue)
                        : r.originalVarhValue || 0;

                    const currentMultiplier = applyMultiplier ? r.rowMultiplier : 1;
                    labels.push(r.datetime.substring(5, 16));

                    let value = calculationFunction(rawValue, currentMultiplier);

                    // ** ‡πÄ‡∏Å‡πá‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• Rate **
                    const rate = getRate(r.dateObject); // ‡∏™‡∏°‡∏°‡∏ï‡∏¥‡∏ß‡πà‡∏≤‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ô‡∏µ‡πâ‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà
                    dataRates.push(rate);
                    dataSingle.push(value);
                });

                // ‡∏™‡∏£‡πâ‡∏≤‡∏á Dataset ‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö kW/kWh
                datasets.push({
                    label: detailChartYAxisLabel,
                    data: dataSingle,
                    borderColor: 'rgba(54, 162, 235, 1)',
                    backgroundColor: 'rgba(54, 162, 235, 0.2)',
                    pointRadius: 0,
                    pointHitRadius: 0,
                    borderWidth: 1.5,
                    tension: 0.2,
                    spanGaps: true
                });

                // ‡∏Å‡∏≥‡∏´‡∏ô‡∏î Scales ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö kW/kWh
                chartScales = {
                    x: {
                        title: { display: true, text: '‡∏ß‡∏±‡∏ô‡πÄ‡∏ß‡∏•‡∏≤' },
                        ticks: { maxRotation: 90, minRotation: 90, autoSkip: true, maxTicksLimit: 30 }
                    },
                    y: {
                        beginAtZero: true,
                        title: { display: true, text: detailChartYAxisLabel },
                        ticks: {
                            callback: function (value) {
                                return value.toFixed(decimalPlacesForDetailChart);
                            }
                        }
                    }
                };
            }
            // **************************************************
            // END: ‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÅ‡∏•‡∏∞ Dataset ‡∏ï‡∏≤‡∏° Unit Type
            // **************************************************

            // 4. ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Å‡∏£‡∏≤‡∏ü‡πÄ‡∏™‡πâ‡∏ô‡πÉ‡∏´‡∏°‡πà
            detailChartInstance = new Chart(ctxDetail, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: { display: true, text: detailChartTitle, font: { size: 16 } },
                        // ‚úÖ ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: ‡πÅ‡∏™‡∏î‡∏á Legend ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏•‡∏∑‡∏≠‡∏Å Voltage ‡∏´‡∏£‡∏∑‡∏≠ Current
                        legend: { display: selectedUnit === 'voltage_abc' || selectedUnit === 'current_abc' },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                footer: function (tooltipItems) {
                                    // ‚úÖ ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: ‡πÑ‡∏°‡πà‡πÅ‡∏™‡∏î‡∏á Rate ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏õ‡πá‡∏ô Voltage ‡∏´‡∏£‡∏∑‡∏≠ Current
                                    if (selectedUnit === 'voltage_abc' || selectedUnit === 'current_abc') return '';
                                    const dataIndex = tooltipItems[0].dataIndex;
                                    const rate = dataRates[dataIndex] || '‡πÑ‡∏°‡πà‡∏ó‡∏£‡∏≤‡∏ö‡πÄ‡∏£‡∏ó';
                                    return `‡πÄ‡∏£‡∏ó: ${rate}`;
                                },
                                label: function (context) {
                                    let valueLabel = context.dataset.label || '';
                                    if (context.parsed.y !== null) {
                                        const displayValue = context.parsed.y;
                                        valueLabel = `${valueLabel}: ${displayValue.toLocaleString('en-US', { minimumFractionDigits: decimalPlacesForDetailChart, maximumFractionDigits: decimalPlacesForDetailChart })}`;
                                    }
                                    return valueLabel;
                                }
                            }
                        },
                        zoom: {
                            pan: { enabled: true, mode: 'x' },
                            zoom: {
                                wheel: { enabled: true },
                                pinch: { enabled: true },
                                mode: 'x'
                            }
                        }
                    },
                    scales: chartScales // ‡πÉ‡∏ä‡πâ Scales ‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÑ‡∏ß‡πâ‡∏î‡πâ‡∏≤‡∏ô‡∏ö‡∏ô
                }
            });

            detailChartContainer.style.display = 'block';
        }

        function exportTableToExcel() {
            if (!isProcessed) {
                alert("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå Excel ‡∏Å‡πà‡∏≠‡∏ô‡∏ó‡∏≥‡∏Å‡∏≤‡∏£‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å");
                return;
            }

            const unitType = document.getElementById('unitSelector').value;
            const applyMultiplier = document.getElementById('applyMultiplier').checked;
            const selectedDataType = document.getElementById('dataTypeSelector').value;

            let whUnit, varhUnit;
            let whCalculation, varhCalculation;
            let decimalPlaces;

            if (unitType === 'kw_kvar') {
                whUnit = 'kW';
                varhUnit = 'kVar';
                decimalPlaces = 3;
                whCalculation = (wh_val_raw, mult) => {
                    const roundedWhTimesFour = Math.round(parseFloat(wh_val_raw) * 4);
                    return customRound((roundedWhTimesFour * mult / 1000), decimalPlaces);
                };
                varhCalculation = (varh_val_raw, mult) => {
                    const roundedVarhTimesFour = Math.round(parseFloat(varh_val_raw) * 4);
                    return customRound((roundedVarhTimesFour * mult / 1000), decimalPlaces);
                };
            } else {
                whUnit = selectedDataType === 'wh_import' ? 'Wh Import' : 'Wh Export';
                varhUnit = 'Varh';
                decimalPlaces = 5;
                whCalculation = (wh_val_raw, mult) => {
                    return customRound((parseFloat(wh_val_raw) * mult), decimalPlaces);
                };
                varhCalculation = (varh_val_raw, mult) => {
                    return customRound((parseFloat(varh_val_raw) * mult), decimalPlaces);
                };
            }

            //---------------------------------------
            // SHEET 2: Electric Rates Filtered (Detailed Data) 
            // *‡∏•‡∏ö‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå Voltage ‡πÅ‡∏•‡∏∞ Current ‡∏≠‡∏≠‡∏Å‡∏ï‡∏≤‡∏°‡∏Ñ‡∏≥‡∏Ç‡∏≠*
            //---------------------------------------
            const detailedHeader = [
                '‡∏ß‡∏±‡∏ô‡πÄ‡∏ß‡∏•‡∏≤ (BKK)',
                '‡πÄ‡∏£‡∏ó',
                whUnit,
                varhUnit,
                'Multiplier'
            ];

            const dataToExport = [detailedHeader];
            const dataForExport = [...globalResults];

            // Check if the detailed data table was sorted before export, and apply the same sorting logic
            if (sortState.columnIndex !== null) {
                const directionModifier = sortState.direction === 'asc' ? 1 : -1;
                const selectedUnit = document.getElementById('unitSelector').value;
                const applyMultiplierForSort = document.getElementById('applyMultiplier').checked;

                let whUnitConverterForSort, varhUnitConverterForSort;
                if (selectedUnit === 'kw_kvar') {
                    whUnitConverterForSort = (wh_val, mult) => (Math.round(parseFloat(wh_val) * 4) / 1000) * mult;
                    varhUnitConverterForSort = (varh_val, mult) => (Math.round(parseFloat(varh_val) * 4) / 1000) * mult;
                } else {
                    whUnitConverterForSort = (wh_val, mult) => parseFloat(wh_val) * mult;
                    varhUnitConverterForSort = (varh_val, mult) => parseFloat(varh_val) * mult;
                }

                dataForExport.sort((a, b) => {
                    let valA, valB;
                    const multA = applyMultiplierForSort ? a.rowMultiplier : 1;
                    const multB = applyMultiplierForSort ? b.rowMultiplier : 1;
                    let wh_val_A = selectedDataType === 'wh_import' ? a.originalWhImportValue : a.originalWhExportValue;
                    let wh_val_B = selectedDataType === 'wh_import' ? b.originalWhImportValue : b.originalWhExportValue;

                    switch (sortState.columnIndex) {
                        case 0:
                            valA = a.dateObject.getTime();
                            valB = b.dateObject.getTime();
                            break;
                        case 1:
                            valA = getRate(a.dateObject);
                            valB = getRate(b.dateObject);
                            const rateOrder = { Holiday: 1, 'Off-peak': 2, Peak: 3 };
                            return (rateOrder[valA] - rateOrder[valB]) * directionModifier;
                        case 2:
                            valA = whUnitConverterForSort(wh_val_A, multA);
                            valB = whUnitConverterForSort(wh_val_B, multB);
                            break;
                        case 3:
                            valA = varhUnitConverterForSort(a.originalVarhValue, multA);
                            valB = varhUnitConverterForSort(b.originalVarhValue, multB);
                            break;
                        case 4:
                            valA = a.rowMultiplier;
                            valB = b.rowMultiplier;
                            break;
                        default:
                            return 0;
                    }
                    if (typeof valA === 'string') {
                        return valA.localeCompare(valB) * directionModifier;
                    } else {
                        return (valA - valB) * directionModifier;
                    }
                });
            }

            dataForExport.forEach(r => {
                const currentMultiplier = applyMultiplier ? r.rowMultiplier : 1;
                const wh_val_raw = selectedDataType === 'wh_import' ? r.originalWhImportValue : r.originalWhExportValue;

                dataToExport.push([
                    r.datetime,
                    getRate(r.dateObject),
                    whCalculation(wh_val_raw, currentMultiplier),
                    varhCalculation(r.originalVarhValue, currentMultiplier),
                    currentMultiplier
                ]);
            });

            //---------------------------------------
            // SHEET 1: TOU (Monthly Summary Data)
            //---------------------------------------
            const selectedArType = document.getElementById('arTypeSelector').value;
            // ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏™‡∏£‡∏∏‡∏õ
            const { monthlySummaries, monthlyMaxValues } = calculateAllMonthsSummariesAndMaxes(selectedArType, selectedDataType);

            const wh_unit_kwh = selectedDataType === 'wh_import' ? 'kWh (Import)' : 'kWh (Export)';

            // ** Header ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ä‡∏µ‡∏ó TOU - ‡πÄ‡∏û‡∏¥‡πà‡∏° Interval ‡πÅ‡∏•‡∏∞ Day Count **
            const touHeader = [
                '‡πÄ‡∏î‡∏∑‡∏≠‡∏ô/‡∏õ‡∏µ',
                'Interval (‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• / ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î)', // Column B
                'Day Count (‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• / ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î)', // Column C
                `${wh_unit_kwh} (‡∏£‡∏ß‡∏°)`,
                `${wh_unit_kwh} (Peak)`,
                `${wh_unit_kwh} (Off-Peak)`,
                `${wh_unit_kwh} (Holiday)`,
                'kW Max (Peak)',
                'kW Max (Off-Peak)',
                'kW Max (Holiday)',
                'kVar Max (‡∏£‡∏ß‡∏°‡∏ó‡∏∏‡∏Å‡πÄ‡∏£‡∏ó)',
                '‡πÄ‡∏ß‡∏•‡∏≤ kW (peak) ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î',
                '‡πÄ‡∏ß‡∏•‡∏≤ kW (Off-Peak) ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î',
                '‡πÄ‡∏ß‡∏•‡∏≤ kW (Holiday) ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î'
            ];

            const touData = [touHeader];
            const monthNames = ["‡∏°.‡∏Ñ.", "‡∏Å.‡∏û.", "‡∏°‡∏µ.‡∏Ñ.", "‡πÄ‡∏°.‡∏¢.", "‡∏û.‡∏Ñ.", "‡∏°‡∏¥.‡∏¢.", "‡∏Å.‡∏Ñ.", "‡∏™.‡∏Ñ.", "‡∏Å.‡∏¢.", "‡∏ï.‡∏Ñ.", "‡∏û.‡∏¢.", "‡∏ò.‡∏Ñ."];
            const sortedMonthKeys = Object.keys(monthlySummaries).sort();

            // ** ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• Interval ‡∏à‡∏≤‡∏Å Global Variable ‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏Ñ‡πà‡∏≤‡πÇ‡∏î‡∏¢ updatedisplay **
            const monthIntervalData = monthlyIntervalDataForExport || {};


            sortedMonthKeys.forEach(monthKey => {
                const [yearStr, monthStr] = monthKey.split('-');
                const year = parseInt(yearStr);
                const monthIndex = parseInt(monthStr) - 1;

                const currentMonthSummary = monthlySummaries[monthKey];
                const currentMonthMax = monthlyMaxValues[monthKey];

                // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• Interval ‡πÅ‡∏•‡∏∞ Day Count ‡∏ï‡∏≤‡∏° Key (YYYY-MM)
                // ‡∏´‡∏≤‡∏Å‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô monthlyIntervalDataForExport ‡∏à‡∏∞‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏Ñ‡πà‡∏≤‡∏ß‡πà‡∏≤‡∏á
                const intervalData = monthIntervalData[monthKey] || { interval: '', dayCount: '' };

                // Total kWh/kVarh Sum
                const totalWh = currentMonthSummary['Peak'].wh + currentMonthSummary['Off-peak'].wh + currentMonthSummary['Holiday'].wh;
                const peakWh = currentMonthSummary['Peak'].wh;
                const offPeakWh = currentMonthSummary['Off-peak'].wh;
                const holidayWh = currentMonthSummary['Holiday'].wh;

                // Max kVar (overall max from all rates)
                let maxVarhOverall = 0;
                ['Peak', 'Off-peak', 'Holiday'].forEach(rate => {
                    if (currentMonthMax[rate].varh > maxVarhOverall) {
                        maxVarhOverall = currentMonthMax[rate].varh;
                    }
                });

                // ** Push data row to TOU sheet - ‡πÉ‡∏™‡πà Interval ‡πÅ‡∏•‡∏∞ Day Count ‡πÉ‡∏ô‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå B, C **
                touData.push([
                    `${monthNames[monthIndex]} ${year + 543}`, // Column A
                    intervalData.interval,                     // Column B: Interval
                    intervalData.dayCount,                     // Column C: Day Count
                    (totalWh / 1000).toFixed(2), // Total kWh (Column D)
                    (peakWh / 1000).toFixed(2),
                    (offPeakWh / 1000).toFixed(2),
                    (holidayWh / 1000).toFixed(2),
                    currentMonthMax['Peak'].wh.toFixed(3),
                    currentMonthMax['Off-peak'].wh.toFixed(3),
                    currentMonthMax['Holiday'].wh.toFixed(3),
                    maxVarhOverall.toFixed(3),
                    currentMonthMax['Peak'].wh_datetime,
                    currentMonthMax['Off-peak'].wh_datetime,
                    currentMonthMax['Holiday'].wh_datetime
                ]);
            });

            // workbook
            const wb = XLSX.utils.book_new();
            const wsTOU = XLSX.utils.aoa_to_sheet(touData);
            XLSX.utils.book_append_sheet(wb, wsTOU, "TOU");

            const ws = XLSX.utils.aoa_to_sheet(dataToExport);
            XLSX.utils.book_append_sheet(wb, ws, "Electric Rates Filtered");

            const now = new Date();
            const filename = `${meterNumber || "N_A"}_${now.getDate()}-${now.getMonth() +
                1}-${now.getFullYear()}_${now.getHours()}${now.getMinutes()}${now.getSeconds()}.xlsx`;

            XLSX.writeFile(wb, filename);
        }


        document.getElementById('exportExcel').addEventListener('click', exportTableToExcel);

        function updateExportButtonVisibility() {
            const exportButton = document.getElementById('exportExcel');
            if (isProcessed && globalResults.length > 0) {
                exportButton.style.display = 'block';
            } else {
                exportButton.style.display = 'none';
            }
        }
        document.addEventListener('DOMContentLoaded', updateExportButtonVisibility);


    </script>
</body>

</html>
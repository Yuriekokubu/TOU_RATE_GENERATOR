<!DOCTYPE html>
<html lang="th">

<head>
    <meta charset="UTF-8">
    <title>‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏£‡∏ó‡πÑ‡∏ü‡∏ü‡πâ‡∏≤ (Neumorphism)</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="./holiday_results/holiday_2022.js"></script>
    <script src="./holiday_results/holiday_2023.js"></script>
    <script src="./holiday_results/holiday_2024.js"></script>
    <script src="./holiday_results/holiday_2025.js"></script>
</head>

<body>
    <div class="container">
        <h1>‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏£‡∏ó‡πÑ‡∏ü‡∏ü‡πâ‡∏≤‡∏à‡∏≤‡∏Å‡πÑ‡∏ü‡∏•‡πå Excel</h1>

        <div id="dropArea" class="drop-area">
            <span class="icon">üìÑ</span>
            <p>‡∏•‡∏≤‡∏Å‡πÑ‡∏ü‡∏•‡πå Excel (.xlsx, .xls) ‡∏°‡∏≤‡∏ß‡∏≤‡∏á‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà</p>
            <p>‡∏´‡∏£‡∏∑‡∏≠‡∏Ñ‡∏•‡∏¥‡∏Å‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏ü‡∏•‡πå</p>
            <input type="file" id="excelFile" accept=".xlsx, .xls">
        </div>

        <div class="controls">
            <div class="control-group">
                <label for="monthYearSelector">‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÄ‡∏î‡∏∑‡∏≠‡∏ô:</label>
                <div class="select-wrapper">
                    <select id="monthYearSelector" onchange="updateDisplay()">
                    </select>
                </div>
            </div>

            <div class="control-group">
                <label for="arTypeSelector">‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó AR:</label>
                <div class="select-wrapper">
                    <select id="arTypeSelector" onchange="updateDisplay()">
                        <option value="AR1">AR1</option>
                        <option value="AR6">AR6</option>
                        <option value="HA1">HA1</option>
                    </select>
                </div>
            </div>

            <div class="control-group">
                <label for="unitSelector">‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏´‡∏ô‡πà‡∏ß‡∏¢:</label>
                <div class="select-wrapper">
                    <select id="unitSelector" onchange="updateDisplay()">
                        <option value="kwh_kvarh">kWh, kVarh</option>
                        <option value="kw_kvar">kW, kVar</option>
                    </select>
                </div>
            </div>

            <div class="control-group checkbox-group">
                <input type="checkbox" id="applyMultiplier" onchange="updateDisplay()">
                <label for="applyMultiplier" class="custom-checkbox">
                    ‡∏Ñ‡∏π‡∏ì‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏î‡πâ‡∏ß‡∏¢‡∏ï‡∏±‡∏ß‡∏Ñ‡∏π‡∏ì
                    <span class="icon-checked">‚úî</span> <span class="icon-unchecked"></span> </label>
            </div>

            <div class="control-group">
                <button id="exportExcel" class="button">Export Data to Excel</button>
            </div>
        </div>

        <div id="output"></div>
    </div>

    <script>
        const holidays = new Set();
        let globalResults = [];
        let isProcessed = false;
        let meterNumber = '';
        let multiplier = 0;

        let sortState = {
            columnIndex: null,
            direction: 'asc'
        };

        const dropArea = document.getElementById('dropArea');
        const excelFileInput = document.getElementById('excelFile');

        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropArea.addEventListener(eventName, preventDefaults, false);
            document.body.addEventListener(eventName, preventDefaults, false);
        });

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        ['dragenter', 'dragover'].forEach(eventName => {
            dropArea.addEventListener(eventName, () => dropArea.classList.add('drag-over'), false);
        });

        ['dragleave', 'drop'].forEach(eventName => {
            dropArea.addEventListener(eventName, () => dropArea.classList.remove('drag-over'), false);
        });

        dropArea.addEventListener('drop', handleDrop, false);

        function handleDrop(e) {
            const dt = e.dataTransfer;
            const files = dt.files;

            if (files.length > 0) {
                excelFileInput.files = files;
                process();
            }
        }

        dropArea.addEventListener('click', () => {
            excelFileInput.click();
        });

        excelFileInput.addEventListener('change', () => {
            if (excelFileInput.files.length > 0) {
                process();
            }
        });

        // Helper function to convert a UTC Date object's components to BKK time components
        // Returns { hour, minute, day, month, year, dayOfWeek } in BKK context
        function getBKKTimeComponents(utcDateObj) {
            const utcHours = utcDateObj.getUTCHours();
            const utcMinutes = utcDateObj.getUTCMinutes();
            const utcSeconds = utcDateObj.getUTCSeconds();
            const utcDay = utcDateObj.getUTCDate();
            const utcMonth = utcDateObj.getUTCMonth();
            const utcYear = utcDateObj.getUTCFullYear();

            // Create a temporary Date object at the exact UTC time, then shift it to BKK
            const tempDate = new Date(Date.UTC(utcYear, utcMonth, utcDay, utcHours, utcMinutes, utcSeconds, 0));
            tempDate.setUTCHours(tempDate.getUTCHours() + 7); // Shift to BKK (GMT+7)

            return {
                hour: tempDate.getUTCHours(), // Now these are BKK hours
                minute: tempDate.getUTCMinutes(),
                second: tempDate.getUTCSeconds(),
                day: tempDate.getUTCDate(),
                month: tempDate.getUTCMonth(),
                year: tempDate.getUTCFullYear(),
                dayOfWeek: tempDate.getUTCDay() // BKK day of week (0=Sun, 6=Sat)
            };
        }

        // Helper function to get a Date object representing midnight of a calendar day in BKK timezone
        // The returned Date object's UTC components will be adjusted to represent BKK midnight.
        function getBKKCalendarDateFromUTC(utcDateObj) {
            const bkkComponents = getBKKTimeComponents(utcDateObj);
            const bkkMidnight = new Date(Date.UTC(bkkComponents.year, bkkComponents.month, bkkComponents.day, 0, 0, 0));
            bkkMidnight.setUTCHours(bkkMidnight.getUTCHours() + 7); // Adjust to GMT+7
            return bkkMidnight;
        }

        function collectHolidays() {
            holidays.clear();
            const allHolidayVars = [
                typeof holiday_2022 !== 'undefined' ? holiday_2022 : null,
                typeof holiday_2023 !== 'undefined' ? holiday_2023 : null,
                typeof holiday_2024 !== 'undefined' ? holiday_2024 : null,
                typeof holiday_2025 !== 'undefined' ? holiday_2025 : null
            ];
            allHolidayVars.forEach(data => {
                if (!data || !data.data) return;
                data.data.forEach(entry => {
                    if (entry.tou === 1 && entry.holiday) {
                        const [d, m, byear] = entry.holiday.split('/');
                        const year = parseInt(byear) - 543;

                        // Create a Date object representing the holiday at midnight in BKK timezone
                        const bkkHolidayMidnight = new Date(Date.UTC(year, parseInt(m) - 1, parseInt(d), 0, 0, 0));
                        bkkHolidayMidnight.setUTCHours(bkkHolidayMidnight.getUTCHours() + 7); // Adjust to GMT+7

                        // Store its ISO string (which will correctly beYYYY-MM-DD for BKK date)
                        const isoDate = bkkHolidayMidnight.toISOString().split('T')[0];
                        holidays.add(isoDate);
                    }
                });
            });
        }

        function isHoliday(date) {
            // date ‡πÄ‡∏õ‡πá‡∏ô JS Date ‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô local time (Asia/Bangkok)
            // ‡∏ñ‡πâ‡∏≤‡πÄ‡∏ß‡∏•‡∏≤ 00:00 ‡∏ñ‡∏∂‡∏á 00:14 ‡πÉ‡∏´‡πâ‡∏ñ‡∏∑‡∏≠‡πÄ‡∏õ‡πá‡∏ô‡∏Ç‡∏≠‡∏á‡∏ß‡∏±‡∏ô‡∏Å‡πà‡∏≠‡∏ô‡∏´‡∏ô‡πâ‡∏≤
            let checkDate = new Date(date);
            let hour = checkDate.getHours();
            let min = checkDate.getMinutes();

            if (hour === 0 && min < 15) {
                checkDate.setDate(checkDate.getDate() - 1);
            }
            // ‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô YYYY-MM-DD
            const iso = checkDate.getFullYear() + '-' +
                String(checkDate.getMonth() + 1).padStart(2, '0') + '-' +
                String(checkDate.getDate()).padStart(2, '0');
            return holidays.has(iso);
        }

        function getRate(date) {
            let checkDate = new Date(date);
            let hour = checkDate.getHours();
            let min = checkDate.getMinutes();

            // ‡∏ñ‡πâ‡∏≤‡πÄ‡∏ß‡∏•‡∏≤ 00:00 ‡∏ñ‡∏∂‡∏á 00:14 ‡πÉ‡∏´‡πâ‡∏ñ‡∏∑‡∏≠‡πÄ‡∏õ‡πá‡∏ô‡∏Ç‡∏≠‡∏á‡∏ß‡∏±‡∏ô‡∏Å‡πà‡∏≠‡∏ô‡∏´‡∏ô‡πâ‡∏≤
            if (hour === 0 && min < 15) {
                checkDate.setDate(checkDate.getDate() - 1);
                hour = 0;
                min = 0;
            }

            const day = checkDate.getDay(); // 0=‡∏≠‡∏≤‡∏ó‡∏¥‡∏ï‡∏¢‡πå, 6=‡πÄ‡∏™‡∏≤‡∏£‡πå
            if (isHoliday(date) || day === 0 || day === 6) {
                return 'Holiday';
            }

            const totalMin = hour * 60 + min;
            const peakStart = 9 * 60 + 15; // 09:15
            const peakEnd = 22 * 60;       // 22:00

            if (totalMin >= peakStart && totalMin <= peakEnd) {
                return 'Peak';
            } else {
                return 'Off-peak';
            }
        }


        // Helper function to get days in a month (1-indexed month)
        function getDaysInMonth(year, month) {
            return new Date(year, month, 0).getDate(); // month is 1-indexed for this constructor use case
        }

        // Helper function to get the actual reading day of a given month (1-indexed) and year
        function getReadingDay(year, month, arType) {
            const daysInMonth = new Date(year, month, 0).getDate();
            if (arType === 'AR1') {
                return daysInMonth - 10;
            } else if (arType === 'AR6') {
                return daysInMonth - 2;
            } else if (arType === 'HA1') {
                return 1;
            }
            return -1; // Should not happen
        }

        // Helper function to get a Date object at 00:00:00 in Bangkok Time, UTC-adjusted
        function getBKKMidnightUTCAdjusted(year, monthIndex, day) { // monthIndex is 0-indexed
            const d = new Date(Date.UTC(year, monthIndex, day, 0, 0, 0));
            d.setUTCHours(d.getUTCHours() + 7); // Adjust to GMT+7 for BKK midnight
            return d;
        }

        function isInBillingPeriod(dateObject, arType, selectedMonth, selectedYear) {
            // selectedMonth is 1-indexed (e.g., 1 for January, 2 for February)

            let billingPeriodStartDate, billingPeriodEndDate;

            // Determine the month and year for the *previous* reading
            let prevReadingMonth = selectedMonth - 1; // 1-indexed month
            let prevReadingYear = selectedYear;
            if (prevReadingMonth === 0) { // If current month is January, previous is December of last year
                prevReadingMonth = 12;
                prevReadingYear--;
            }

            // Determine the reading day for the previous month
            const prevReadingDay = getReadingDay(prevReadingYear, prevReadingMonth, arType);
            if (prevReadingDay === -1) return false;

            // Calculate the start date of the billing period
            // It's the previous month's reading date at 00:15:00 BKK
            billingPeriodStartDate = getBKKMidnightUTCAdjusted(prevReadingYear, prevReadingMonth - 1, prevReadingDay); // monthIndex is 0-indexed for getBKKMidnightUTCAdjusted
            billingPeriodStartDate.setMinutes(billingPeriodStartDate.getMinutes() + 15);


            // Determine the reading day for the *current* billing month
            const currentReadingDay = getReadingDay(selectedYear, selectedMonth, arType);
            if (currentReadingDay === -1) return false;

            // Calculate the end date of the billing period
            // It's the current month's reading date at 00:00:00 BKK (of the *next* day)
            billingPeriodEndDate = getBKKMidnightUTCAdjusted(selectedYear, selectedMonth - 1, currentReadingDay + 1); // monthIndex is 0-indexed


            // `dateObject` is `roundedDateObjectUTC` which is already UTC-adjusted to represent BKK time.
            // So, we can directly compare its getTime() with the `billingPeriodStartDate` and `billingPeriodEndDate`
            // which are also UTC-adjusted BKK times.
            return dateObject.getTime() >= billingPeriodStartDate.getTime() && dateObject.getTime() < billingPeriodEndDate.getTime();
        }

        function sortTable(columnIndex) {
            if (!isProcessed) return;

            if (sortState.columnIndex === columnIndex) {
                sortState.direction = sortState.direction === 'asc' ? 'desc' : 'asc';
            } else {
                sortState.columnIndex = columnIndex;
                if (columnIndex === 0) { // Datetime
                    sortState.direction = 'asc';
                } else if (columnIndex === 1) { // Rate
                    sortState.direction = 'asc';
                } else { // Numeric columns
                    sortState.direction = 'desc';
                }
            }

            updateDisplay(); // Re-render the detailed table after sorting
        }

        // Modified renderResults to accept selectedMonthYear and selectedArType
        function renderResults(unitType, selectedMonthYear, selectedArType) {
            if (!isProcessed) return;

            let whUnit, varhUnit;
            const applyMultiplier = document.getElementById('applyMultiplier').checked;
            const currentMultiplier = applyMultiplier ? multiplier : 1;

            let whCalculation, varhCalculation;
            let decimalPlaces;

            if (unitType === 'kw_kvar') {
                whUnit = 'kW';
                varhUnit = 'kVar';
                decimalPlaces = 3;

                whCalculation = (wh_val) => {
                    let baseKw = (parseFloat(wh_val) * 4 / 1000);
                    let roundedBaseKw = parseFloat(baseKw.toFixed(decimalPlaces));
                    if (applyMultiplier) {
                        return roundedBaseKw * currentMultiplier;
                    }
                    return roundedBaseKw;
                };
                varhCalculation = (varh_val) => {
                    let baseKvar = (parseFloat(varh_val) * 4 / 1000);
                    let roundedBaseKvar = parseFloat(baseKvar.toFixed(decimalPlaces));
                    if (applyMultiplier) {
                        return roundedBaseKvar * currentMultiplier;
                    }
                    return roundedBaseKvar;
                };
            } else { // kWh, kVarh
                whUnit = 'kWh';
                varhUnit = 'kVarh';
                decimalPlaces = 2;

                whCalculation = (wh_val) => (parseFloat(wh_val) / 1000) * currentMultiplier;
                varhCalculation = (varh_val) => (parseFloat(varh_val) / 1000) * currentMultiplier;
            }

            let tableRowsHtml = '';

            let maxKwValues = {
                'Peak': {
                    value: 0,
                    datetime: ''
                },
                'Off-peak': {
                    value: 0,
                    datetime: ''
                },
                'Holiday': {
                    value: 0,
                    datetime: ''
                }
            };
            let maxKvarValues = {
                'Peak': {
                    value: 0,
                    datetime: ''
                },
                'Off-peak': {
                    value: 0,
                    datetime: ''
                },
                'Holiday': {
                    value: 0,
                    datetime: ''
                }
            };
            let overallMaxKw = {
                value: 0,
                datetime: ''
            };
            let overallMaxKvar = {
                value: 0,
                datetime: ''
            };

            // New summary variables for total consumption
            let totalWhConsumption = {
                'Peak': 0,
                'Off-peak': 0,
                'Holiday': 0
            };
            let totalVarhConsumption = {
                'Peak': 0,
                'Off-peak': 0,
                'Holiday': 0
            };

            let filteredResults = [];
            if (selectedMonthYear === 'all') { // If "All Data" is selected for month/year
                filteredResults = [...globalResults];
            } else {
                const [yearStr, monthStr] = selectedMonthYear.split('-');
                const selectedMonthInt = parseInt(monthStr); // 1-indexed
                const selectedYearInt = parseInt(yearStr); // AD year

                filteredResults = globalResults.filter(r => {
                    // Filter by selected AR Type explicitly and by selected Month/Year
                    return isInBillingPeriod(r.dateObject, selectedArType, selectedMonthInt, selectedYearInt);
                });
            }

            // Apply sorting to filteredResults
            const dataToRender = [...filteredResults]; // Clone for sorting
            if (sortState.columnIndex !== null) {
                const directionModifier = sortState.direction === 'asc' ? 1 : -1;
                const selectedUnit = document.getElementById('unitSelector').value;
                const applyMultiplierForSort = document.getElementById('applyMultiplier').checked;
                const currentMultiplierForSort = applyMultiplierForSort ? multiplier : 1;

                let whUnitConverterForSort, varhUnitConverterForSort;
                if (selectedUnit === 'kw_kvar') {
                    whUnitConverterForSort = (wh) => {
                        let baseKw = (parseFloat(wh) * 4 / 1000);
                        let roundedBaseKw = parseFloat(baseKw.toFixed(3));
                        if (applyMultiplierForSort) return roundedBaseKw * currentMultiplierForSort;
                        return roundedBaseKw;
                    };
                    varhUnitConverterForSort = (varh) => {
                        let baseKvar = (parseFloat(varh) * 4 / 1000);
                        let roundedBaseKvar = parseFloat(baseKvar.toFixed(3));
                        if (applyMultiplierForSort) return roundedBaseKvar * currentMultiplierForSort;
                        return roundedBaseKvar;
                    };
                } else {
                    whUnitConverterForSort = (wh) => (parseFloat(wh) / 1000) * currentMultiplierForSort;
                    varhUnitConverterForSort = (varh) => (parseFloat(varh) / 1000) * currentMultiplierForSort;
                }

                dataToRender.sort((a, b) => {
                    let valA, valB;
                    switch (sortState.columnIndex) {
                        case 0: // Datetime
                            valA = a.dateObject.getTime();
                            valB = b.dateObject.getTime();
                            break;
                        case 1: // Rate
                            valA = getRate(a.dateObject);
                            valB = getRate(b.dateObject);
                            const rateOrder = {
                                'Holiday': 1,
                                'Off-peak': 2,
                                'Peak': 3
                            };
                            return (rateOrder[valA] - rateOrder[valB]) * directionModifier;
                        case 2: // Wh/kW
                            valA = whUnitConverterForSort(a.originalWhValue);
                            valB = whUnitConverterForSort(b.originalWhValue);
                            break;
                        case 3: // VARh/kVar
                            valA = varhUnitConverterForSort(a.originalVarhValue);
                            valB = varhUnitConverterForSort(b.originalVarhValue);
                            break;
                        default:
                            return 0;
                    }

                    if (typeof valA === 'string') {
                        return valA.localeCompare(valB) * directionModifier;
                    } else {
                        return (valA - valB) * directionModifier;
                    }
                });
            }

            dataToRender.forEach(r => {
                const wh = r.originalWhValue || 0;
                const varh = r.originalVarhValue || 0;

                const currentWh = whCalculation(wh);
                const currentVarh = varhCalculation(varh);

                const rate = getRate(r.dateObject);

                // Update total consumption
                totalWhConsumption[rate] += currentWh;
                totalVarhConsumption[rate] += currentVarh;

                if (unitType === 'kw_kvar') {
                    if (currentWh > maxKwValues[rate].value) {
                        maxKwValues[rate].value = currentWh;
                        maxKwValues[rate].datetime = r.datetime;
                    }
                    if (currentVarh > maxKvarValues[rate].value) {
                        maxKvarValues[rate].value = currentVarh;
                        maxKvarValues[rate].datetime = r.datetime;
                    }

                    if (currentWh > overallMaxKw.value) {
                        overallMaxKw.value = currentWh;
                        overallMaxKw.datetime = r.datetime;
                    }
                    if (currentVarh > overallMaxKvar.value) {
                        overallMaxKvar.value = currentVarh;
                        overallMaxKvar.datetime = r.datetime;
                    }
                }

                let displayDatetime = r.datetime;
                const cls = rate.toLowerCase().replace('-', '');
                tableRowsHtml += `<tr class="${cls}">
                    <td>${displayDatetime}</td><td>${rate}</td>
                    <td>${currentWh.toFixed(decimalPlaces)}</td><td>${currentVarh.toFixed(decimalPlaces)}</td>
                </tr>`;
            });

            const formattedMultiplier = multiplier.toLocaleString('en-US', {
                minimumFractionDigits: 4,
                maximumFractionDigits: 4
            });

            let meterInfoHtml = `
                <div class="summary-box meter-info">
                    <h3>‡∏™‡∏£‡∏∏‡∏õ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏°‡∏¥‡πÄ‡∏ï‡∏≠‡∏£‡πå‡πÅ‡∏•‡∏∞‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏û‡∏•‡∏±‡∏á‡∏á‡∏≤‡∏ô</h3>
                    <p>‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏•‡∏Ç‡∏°‡∏¥‡πÄ‡∏ï‡∏≠‡∏£‡πå: <strong>${meterNumber || 'N/A'}</strong></p>
                    <p>‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡∏±‡∏ß‡∏Ñ‡∏π‡∏ì: <strong>${formattedMultiplier}</strong></p>
                </div>`;

            let mainSummaryHtml = '';

            // Start of Rate Summary Container
            mainSummaryHtml += '<div class="rate-summary-container">';

            // Max kW/kVar Summary (if unitType is kw_kvar)
            if (unitType === 'kw_kvar') {
                mainSummaryHtml += `
                    <div class="summary-box overall-max-summary">
                        <h3>kW/kVar ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î‡∏£‡∏ß‡∏°‡∏ó‡∏∏‡∏Å‡πÄ‡∏£‡∏ó</h3>
                        <p>kW: <strong>${overallMaxKw.value.toFixed(decimalPlaces)} ${whUnit}</strong><br>
                        <small>‡πÄ‡∏°‡∏∑‡πà‡∏≠: ${overallMaxKw.datetime || 'N/A'}</small></p>
                        <p>kVar: <strong>${overallMaxKvar.value.toFixed(decimalPlaces)} ${varhUnit}</strong><br>
                        <small>‡πÄ‡∏°‡∏∑‡πà‡∏≠: ${overallMaxKvar.datetime || 'N/A'}</small></p>
                    </div>
                    <div class="summary-box max-kw-peak-summary">
                        <h3>kW/kVar ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î (Peak)</h3>
                        <p>kW: <strong>${maxKwValues['Peak'].value.toFixed(decimalPlaces)} ${whUnit}</strong><br>
                        <small>‡πÄ‡∏°‡∏∑‡πà‡∏≠: ${maxKwValues['Peak'].datetime || 'N/A'}</small></p>
                        <p>kVar: <strong>${maxKvarValues['Peak'].value.toFixed(decimalPlaces)} ${varhUnit}</strong><br>
                        <small>‡πÄ‡∏°‡∏∑‡πà‡∏≠: ${maxKvarValues['Peak'].datetime || 'N/A'}</small></p>
                    </div>
                    <div class="summary-box max-kw-off-peak-summary">
                        <h3>kW/kVar ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î (Off-peak)</h3>
                        <p>kW: <strong>${maxKwValues['Off-peak'].value.toFixed(decimalPlaces)} ${whUnit}</strong><br>
                        <small>‡πÄ‡∏°‡∏∑‡πà‡∏≠: ${maxKwValues['Off-peak'].datetime || 'N/A'}</small></p>
                        <p>kVar: <strong>${maxKvarValues['Off-peak'].value.toFixed(decimalPlaces)} ${varhUnit}</strong><br>
                        <small>‡πÄ‡∏°‡∏∑‡πà‡∏≠: ${maxKvarValues['Off-peak'].datetime || 'N/A'}</small></p>
                    </div>
                    <div class="summary-box max-kw-holiday-summary">
                        <h3>kW/kVar ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î (Holiday)</h3>
                        <p>kW: <strong>${maxKwValues['Holiday'].value.toFixed(decimalPlaces)} ${whUnit}</strong><br>
                        <small>‡πÄ‡∏°‡∏∑‡πà‡∏≠: ${maxKwValues['Holiday'].datetime || 'N/A'}</small></p>
                        <p>kVar: <strong>${maxKvarValues['Holiday'].value.toFixed(decimalPlaces)} ${varhUnit}</strong><br>
                        <small>‡πÄ‡∏°‡∏∑‡πà‡∏≠: ${maxKvarValues['Holiday'].datetime || 'N/A'}</small></p>
                    </div>
                `;
            }

            // Total Consumption Summary (for both kWh/kVarh and kW/kVar units, but values change)
            // This block will only be added if unitType is 'kwh_kvarh'
            if (unitType === 'kwh_kvarh') {
                mainSummaryHtml += `
                    <div class="summary-box consumption-summary">
                        <h3>‡∏™‡∏£‡∏∏‡∏õ‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏û‡∏•‡∏±‡∏á‡∏á‡∏≤‡∏ô (‡∏£‡∏ß‡∏°)</h3>
                        <p>‡∏£‡∏ß‡∏° Peak: <strong>${totalWhConsumption['Peak'].toFixed(decimalPlaces)} ${whUnit}</strong>, <strong>${totalVarhConsumption['Peak'].toFixed(decimalPlaces)} ${varhUnit}</strong></p>
                        <p>‡∏£‡∏ß‡∏° Off-peak: <strong>${totalWhConsumption['Off-peak'].toFixed(decimalPlaces)} ${whUnit}</strong>, <strong>${totalVarhConsumption['Off-peak'].toFixed(decimalPlaces)} ${varhUnit}</strong></p>
                        <p>‡∏£‡∏ß‡∏° Holiday: <strong>${totalWhConsumption['Holiday'].toFixed(decimalPlaces)} ${whUnit}</strong>, <strong>${totalVarhConsumption['Holiday'].toFixed(decimalPlaces)} ${varhUnit}</strong></p>
                        <p class="total-overall">‡∏£‡∏ß‡∏°‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î: <strong>${(totalWhConsumption['Peak'] + totalWhConsumption['Off-peak'] + totalWhConsumption['Holiday']).toFixed(decimalPlaces)} ${whUnit}</strong>, <strong>${(totalVarhConsumption['Peak'] + totalVarhConsumption['Off-peak'] + totalVarhConsumption['Holiday']).toFixed(decimalPlaces)} ${varhUnit}</strong></p>
                    </div>
                `;
            }

            mainSummaryHtml += '</div>'; // End of Rate Summary Container

            const headers = [{
                title: '‡∏ß‡∏±‡∏ô‡πÄ‡∏ß‡∏•‡∏≤',
                index: 0
            }, {
                title: '‡πÄ‡∏£‡∏ó',
                index: 1
            }, {
                title: whUnit,
                index: 2
            }, {
                title: varhUnit,
                index: 3
            }];

            const headerHtml = headers.map(h => {
                const isActiveSort = sortState.columnIndex !== null && sortState.columnIndex === h.index;
                const sortClass = isActiveSort ? `active-sort ${sortState.direction}` : '';
                return `<th class="sortable ${sortClass}" onclick="sortTable(${h.index})" data-column-index="${h.index}">
                                ${h.title} <span class="sort-indicator"></span>
                            </th>`;
            }).join('');

            let tableHtml = `<table><tr>${headerHtml}</tr>${tableRowsHtml}</table>`;

            document.getElementById('output').innerHTML = meterInfoHtml + mainSummaryHtml + tableHtml;
        }

        // Renamed and modified function to populate only Month and Year
        function populateMonthYearSelector() {
            const selector = document.getElementById('monthYearSelector');
            selector.innerHTML = ''; // Clear existing options

            const monthNames = ["‡∏°‡∏Å‡∏£‡∏≤‡∏Ñ‡∏°", "‡∏Å‡∏∏‡∏°‡∏†‡∏≤‡∏û‡∏±‡∏ô‡∏ò‡πå", "‡∏°‡∏µ‡∏ô‡∏≤‡∏Ñ‡∏°", "‡πÄ‡∏°‡∏©‡∏≤‡∏¢‡∏ô", "‡∏û‡∏§‡∏©‡∏†‡∏≤‡∏Ñ‡∏°", "‡∏°‡∏¥‡∏ñ‡∏∏‡∏ô‡∏≤‡∏¢‡∏ô", "‡∏Å‡∏£‡∏Å‡∏é‡∏≤‡∏Ñ‡∏°", "‡∏™‡∏¥‡∏á‡∏´‡∏≤‡∏Ñ‡∏°", "‡∏Å‡∏±‡∏ô‡∏¢‡∏≤‡∏¢‡∏ô", "‡∏ï‡∏∏‡∏•‡∏≤‡∏Ñ‡∏°", "‡∏û‡∏§‡∏®‡∏à‡∏¥‡∏Å‡∏≤‡∏¢‡∏ô", "‡∏ò‡∏±‡∏ô‡∏ß‡∏≤‡∏Ñ‡∏°"];

            // Collect unique year-month combinations from globalResults
            const uniqueMonthYears = new Set(); // Stores as "YYYY-MM" (e.g., "2024-05")
            globalResults.forEach(r => {
                const {
                    year,
                    month
                } = getBKKTimeComponents(r.dateObject); // month is 0-indexed
                uniqueMonthYears.add(`${year}-${(month + 1).toString().padStart(2, '0')}`); // Store as YYYY-MM
            });

            // Sort unique periods chronologically
            const sortedUniqueMonthYears = Array.from(uniqueMonthYears).sort();

            // Add 'All Data' option
            const allOption = document.createElement('option');
            allOption.value = 'all';
            allOption.textContent = '‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î';
            selector.appendChild(allOption);

            // Add options for each unique month and year
            sortedUniqueMonthYears.forEach(periodStr => {
                const [yearStr, monthStr] = periodStr.split('-');
                const year = parseInt(yearStr);
                const month = parseInt(monthStr); // 1-indexed month

                const option = document.createElement('option');
                option.value = `${year}-${month.toString().padStart(2, '0')}`; // Value as "YYYY-MM"
                option.textContent = `${monthNames[month - 1]} ${year + 543}`; // Display as Thai month and Buddhist year
                selector.appendChild(option);
            });
        }


        // Helper function to calculate billing period start and end dates
        function getBillingPeriodDates(selectedYear, selectedMonth, arType) {
            let billingPeriodStartDate, billingPeriodEndDate;

            // Determine the month and year for the *previous* reading
            let prevReadingMonth = selectedMonth - 1; // 1-indexed month
            let prevReadingYear = selectedYear;
            if (prevReadingMonth === 0) { // If current month is January, previous is December of last year
                prevReadingMonth = 12;
                prevReadingYear--;
            }

            // Determine the reading day for the previous month
            const prevReadingDay = getReadingDay(prevReadingYear, prevReadingMonth, arType);
            if (prevReadingDay === -1) return {
                startDate: null,
                endDate: null
            };

            // Calculate the start date of the billing period
            // It's the previous month's reading date at 00:15:00 BKK
            billingPeriodStartDate = getBKKMidnightUTCAdjusted(prevReadingYear, prevReadingMonth - 1, prevReadingDay); // monthIndex is 0-indexed for getBKKMidnightUTCAdjusted
            billingPeriodStartDate.setMinutes(billingPeriodStartDate.getMinutes() + 15);


            // Determine the reading day for the *current* billing month
            const currentReadingDay = getReadingDay(selectedYear, selectedMonth, arType);
            if (currentReadingDay === -1) return {
                startDate: null,
                endDate: null
            };

            // Calculate the end date of the billing period
            // It's the current month's reading date at 00:00:00 BKK (of the *next* day)
            billingPeriodEndDate = getBKKMidnightUTCAdjusted(selectedYear, selectedMonth - 1, currentReadingDay + 1); // monthIndex is 0-indexed

            return {
                startDate: billingPeriodStartDate,
                endDate: billingPeriodEndDate
            };
        }


        function updateDisplay() {
            if (!isProcessed) {
                return;
            }
            const selectedMonthYear = document.getElementById('monthYearSelector').value;
            const selectedArType = document.getElementById('arTypeSelector').value;
            const selectedUnit = document.getElementById('unitSelector').value;

            // New: Calculate and display billing period
            const billingPeriodInfoDiv = document.createElement('div');
            billingPeriodInfoDiv.className = 'summary-box billing-period-info';

            if (selectedMonthYear !== 'all') {
                const [yearStr, monthStr] = selectedMonthYear.split('-');
                const selectedMonthInt = parseInt(monthStr); // 1-indexed
                const selectedYearInt = parseInt(yearStr); // AD year

                const {
                    startDate,
                    endDate
                } = getBillingPeriodDates(selectedYearInt, selectedMonthInt, selectedArType);

                if (startDate && endDate) {
                    const formatDateTime = (dateObj) => {
                        const bkkComponents = getBKKTimeComponents(dateObj);
                        return `${bkkComponents.day.toString().padStart(2, '0')}/${(bkkComponents.month + 1).toString().padStart(2, '0')}/${bkkComponents.year + 543} ${bkkComponents.hour.toString().padStart(2, '0')}:${bkkComponents.minute.toString().padStart(2, '0')}:00`;
                    };

                    billingPeriodInfoDiv.innerHTML = `
                        <h3>‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡∏ö‡∏¥‡∏•‡∏•‡∏¥‡πà‡∏á</h3>
                        <p>‡∏ï‡∏±‡πâ‡∏á‡πÅ‡∏ï‡πà: <strong>${formatDateTime(startDate)}</strong></p>
                        <p>‡∏ñ‡∏∂‡∏á: <strong>${formatDateTime(endDate)}</strong></p>
                    `;
                }
            } else {
                // If "All Data" is selected, indicate that
                billingPeriodInfoDiv.innerHTML = `
                    <h3>‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡∏ö‡∏¥‡∏•‡∏•‡∏¥‡πà‡∏á</h3>
                    <p>‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏ó‡∏µ‡πà‡∏°‡∏µ‡πÉ‡∏ô‡πÑ‡∏ü‡∏•‡πå</p>
                `;
            }

            // Clear previous billing period info and append the new one
            const outputDiv = document.getElementById('output');
            const existingBillingInfo = outputDiv.querySelector('.billing-period-info');
            if (existingBillingInfo) {
                existingBillingInfo.remove();
            }

            // Find the position after meter info but before the main summary
            const meterInfoBox = outputDiv.querySelector('.meter-info');
            if (meterInfoBox) {
                meterInfoBox.insertAdjacentElement('afterend', billingPeriodInfoDiv);
            } else {
                // Fallback if meter info box isn't found (shouldn't happen with current structure)
                outputDiv.prepend(billingPeriodInfoDiv);
            }

            renderResults(selectedUnit, selectedMonthYear, selectedArType);
        }

        async function process() {
            collectHolidays();
            const file = excelFileInput.files[0];
            if (!file) {
                alert("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏ü‡∏•‡πå Excel ‡∏´‡∏£‡∏∑‡∏≠‡∏•‡∏≤‡∏Å‡πÑ‡∏ü‡∏•‡πå‡∏°‡∏≤‡∏ß‡∏≤‡∏á‡∏Å‡πà‡∏≠‡∏ô‡∏Ñ‡∏£‡∏±‡∏ö/‡∏Ñ‡πà‡∏∞");
                return;
            }

            dropArea.innerHTML = `<span class="icon" style="color: #28a745;">‚úÖ</span><p>‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å: <strong>${file.name}</strong></p><p>‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•...</p>`;
            document.getElementById('output').innerHTML = '<p>‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÑ‡∏ü‡∏•‡πå...</p>';


            const reader = new FileReader();
            reader.onload = function (e) {
                const data = new Uint8Array(e.target.result);
                const wb = XLSX.read(data, {
                    type: 'array',
                    cellDates: true
                });
                const sheet = wb.Sheets[wb.SheetNames[0]];

                if (sheet['A4'] && sheet['A4'].v !== undefined) {
                    meterNumber = sheet['A4'].v.toString();
                } else {
                    meterNumber = 'N/A';
                }

                const e4 = parseFloat(sheet['E4'] ? sheet['E4'].v : 0);
                const f4 = parseFloat(sheet['F4'] ? sheet['F4'].v : 0);
                const g4 = parseFloat(sheet['G4'] ? sheet['G4'].v : 0);
                const h4 = parseFloat(sheet['H4'] ? sheet['H4'].v : 0);

                if (f4 !== 0 && h4 !== 0) {
                    multiplier = (e4 / f4) * (g4 / h4);
                } else {
                    multiplier = 0;
                }

                const rows = XLSX.utils.sheet_to_json(sheet, {
                    header: 1
                });

                globalResults = [];
                isProcessed = false;

                for (let i = 3; i < rows.length; i++) {
                    const rawDate = rows[i][2]; // Column C, 0-indexed is 2
                    const originalWhValue = parseFloat(rows[i][26]) || 0;
                    const originalVarhValue = parseFloat(rows[i][34]) || 0;

                    if (!rawDate || isNaN(originalWhValue) || isNaN(originalVarhValue)) continue;

                    let dateObject;

                    if (rawDate instanceof Date) {
                        dateObject = new Date(rawDate.getTime());
                    } else if (typeof rawDate === 'number') {
                        const parsed = XLSX.SSF.parse_date_code(rawDate);
                        dateObject = new Date(Date.UTC(parsed.y, parsed.m - 1, parsed.d, parsed.H, parsed.M, parsed.S));
                    } else if (typeof rawDate === 'string') {
                        const match = rawDate.match(/(\d{1,2})\/(\d{1,2})\/(\d{4})\s*(\d{1,2}):(\d{2}):(\d{2})|(\d{4})-(\d{1,2})-(\d{1,2})T(\d{1,2}):(\d{2}):(\d{2})/);
                        if (match) {
                            if (match[1]) {
                                const [, day, month, year, hour, minute, second] = match;
                                const adYear = parseInt(year) > 2500 ? parseInt(year) - 543 : parseInt(year);
                                dateObject = new Date(Date.UTC(adYear, parseInt(month) - 1, parseInt(day), parseInt(hour), parseInt(minute), parseInt(second)));
                            } else if (match[7]) {
                                const [, , , , , , year, month, day, hour, minute, second] = match;
                                dateObject = new Date(Date.UTC(parseInt(year), parseInt(month) - 1, parseInt(day), parseInt(hour), parseInt(minute), parseInt(second)));
                            }
                        } else {
                            dateObject = new Date(rawDate);
                        }
                    } else {
                        continue;
                    }

                    if (isNaN(dateObject.getTime())) continue;

                    // Rounding to nearest 15-minute interval in BKK time
                    const {
                        hour: initialBkkHour,
                        minute: initialBkkMinute,
                        second: initialBkkSecond,
                        year: initialBkkYear,
                        month: initialBkkMonth,
                        day: initialBkkDay
                    } = getBKKTimeComponents(dateObject);

                    const totalMinutesFromBKKMidnight = initialBkkHour * 60 + initialBkkMinute + initialBkkSecond / 60;
                    const roundedTotalMinutesBKK = Math.round(totalMinutesFromBKKMidnight / 15) * 15;

                    const roundedDateObjectUTC = new Date(Date.UTC(
                        initialBkkYear, initialBkkMonth, initialBkkDay, 0,
                        roundedTotalMinutesBKK,
                        0, 0
                    ));
                    roundedDateObjectUTC.setUTCHours(roundedDateObjectUTC.getUTCHours() - 7);

                    const displayBkkComponents = getBKKTimeComponents(roundedDateObjectUTC);
                    const formattedDatetime = `${displayBkkComponents.year}/${(displayBkkComponents.month + 1).toString().padStart(2, '0')}/${displayBkkComponents.day.toString().padStart(2, '0')} ${displayBkkComponents.hour.toString().padStart(2, '0')}:${displayBkkComponents.minute.toString().padStart(2, '0')}:00`;

                    globalResults.push({
                        datetime: formattedDatetime,
                        originalWhValue: originalWhValue,
                        originalVarhValue: originalVarhValue,
                        dateObject: roundedDateObjectUTC
                    });
                }

                isProcessed = true;
                sortState.columnIndex = null;
                sortState.direction = 'asc';

                populateMonthYearSelector(); // Populate the Month/Year selector
                // Initial display
                updateDisplay();
            };
            reader.readAsArrayBuffer(file);
        }

        // Modified Export to Excel Function
        function exportTableToExcel() {
            if (!isProcessed) {
                alert("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå Excel ‡∏Å‡πà‡∏≠‡∏ô‡∏ó‡∏≥‡∏Å‡∏≤‡∏£‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å");
                return;
            }

            const unitType = document.getElementById('unitSelector').value;
            const applyMultiplier = document.getElementById('applyMultiplier').checked;
            const currentMultiplier = applyMultiplier ? multiplier : 1;
            const selectedMonthYear = document.getElementById('monthYearSelector').value;
            const selectedArType = document.getElementById('arTypeSelector').value;


            let whUnit, varhUnit;
            let whCalculation, varhCalculation;
            let decimalPlaces;

            if (unitType === 'kw_kvar') {
                whUnit = 'kW';
                varhUnit = 'kVar';
                decimalPlaces = 3;

                whCalculation = (wh_val) => {
                    let baseKw = (parseFloat(wh_val) * 4 / 1000);
                    let roundedBaseKw = parseFloat(baseKw.toFixed(decimalPlaces));
                    if (applyMultiplier) {
                        return roundedBaseKw * currentMultiplier;
                    }
                    return roundedBaseKw;
                };
                varhCalculation = (varh_val) => {
                    let baseKvar = (parseFloat(varh_val) * 4 / 1000);
                    let roundedBaseKvar = parseFloat(baseKvar.toFixed(decimalPlaces));
                    if (applyMultiplier) {
                        return roundedBaseKvar * currentMultiplier;
                    }
                    return roundedBaseKvar;
                };
            } else { // kWh, kVarh
                whUnit = 'kWh';
                varhUnit = 'kVarh';
                decimalPlaces = 2;

                whCalculation = (wh_val) => (parseFloat(wh_val) / 1000) * currentMultiplier;
                varhCalculation = (varh_val) => (parseFloat(varh_val) / 1000) * currentMultiplier;
            }

            const dataToExport = [];

            // Add header row
            dataToExport.push(['‡∏ß‡∏±‡∏ô‡πÄ‡∏ß‡∏•‡∏≤', '‡πÄ‡∏£‡∏ó', whUnit, varhUnit]);

            let dataForExport = [];
            if (selectedMonthYear === 'all') {
                dataForExport = [...globalResults];
            } else {
                const [yearStr, monthStr] = selectedMonthYear.split('-');
                const selectedMonthInt = parseInt(monthStr); // 1-indexed
                const selectedYearInt = parseInt(yearStr); // AD year

                dataForExport = globalResults.filter(r => {
                    return isInBillingPeriod(r.dateObject, selectedArType, selectedMonthInt, selectedYearInt);
                });
            }

            // Apply sorting if a sort state is active (same as renderResults)
            if (sortState.columnIndex !== null) {
                const directionModifier = sortState.direction === 'asc' ? 1 : -1;
                const selectedUnit = document.getElementById('unitSelector').value;
                const applyMultiplierForSort = document.getElementById('applyMultiplier').checked;
                const currentMultiplierForSort = applyMultiplierForSort ? multiplier : 1;

                let whUnitConverterForSort, varhUnitConverterForSort;
                if (selectedUnit === 'kw_kvar') {
                    whUnitConverterForSort = (wh) => {
                        let baseKw = (parseFloat(wh) * 4 / 1000);
                        let roundedBaseKw = parseFloat(baseKw.toFixed(3));
                        if (applyMultiplierForSort) return roundedBaseKw * currentMultiplierForSort;
                        return roundedBaseKw;
                    };
                    varhUnitConverterForSort = (varh) => {
                        let baseKvar = (parseFloat(varh) * 4 / 1000);
                        let roundedBaseKvar = parseFloat(baseKvar.toFixed(3));
                        if (applyMultiplierForSort) return roundedBaseKvar * currentMultiplierForSort;
                        return roundedBaseKvar;
                    };
                } else {
                    whUnitConverterForSort = (wh) => (parseFloat(wh) / 1000) * currentMultiplierForSort;
                    varhUnitConverterForSort = (varh) => (parseFloat(varh) / 1000) * currentMultiplierForSort;
                }

                dataForExport.sort((a, b) => { // Sort dataForExport, not filteredResults
                    let valA, valB;
                    switch (sortState.columnIndex) {
                        case 0: // Datetime
                            valA = a.dateObject.getTime();
                            valB = b.dateObject.getTime();
                            break;
                        case 1: // Rate
                            valA = getRate(a.dateObject);
                            valB = getRate(b.dateObject);
                            const rateOrder = {
                                'Holiday': 1,
                                'Off-peak': 2,
                                'Peak': 3
                            };
                            return (rateOrder[valA] - rateOrder[valB]) * directionModifier;
                        case 2: // Wh/kW
                            valA = whUnitConverterForSort(a.originalWhValue);
                            valB = whUnitConverterForSort(b.originalWhValue);
                            break;
                        case 3: // VARh/kVar
                            valA = varhUnitConverterForSort(a.originalVarhValue);
                            valB = varhUnitConverterForSort(b.originalVarhValue);
                            break;
                        default:
                            return 0;
                    }

                    if (typeof valA === 'string') {
                        return valA.localeCompare(valB) * directionModifier;
                    } else {
                        return (valA - valB) * directionModifier;
                    }
                });
            }

            // Add data rows
            dataForExport.forEach(r => {
                const wh = r.originalWhValue || 0;
                const varh = r.originalVarhValue || 0;

                const currentWh = whCalculation(wh);
                const currentVarh = varhCalculation(varh);

                const rate = getRate(r.dateObject);

                dataToExport.push([
                    r.datetime,
                    rate,
                    currentWh.toFixed(decimalPlaces),
                    currentVarh.toFixed(decimalPlaces)
                ]);
            });

            const ws = XLSX.utils.aoa_to_sheet(dataToExport);
            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, "Electric Rates Filtered");

            const filename = `Electric_Rates_${selectedMonthYear}_${selectedArType}_${new Date().toISOString().slice(0, 10)}.xlsx`;

            XLSX.writeFile(wb, filename);
        }

        document.getElementById('exportExcel').addEventListener('click', exportTableToExcel);
    </script>
</body>

</html>
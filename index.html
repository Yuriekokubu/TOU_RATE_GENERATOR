<!DOCTYPE html>
<html lang="th">

<head>
    <meta charset="UTF-8">
    <title>‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏£‡∏ó‡πÑ‡∏ü‡∏ü‡πâ‡∏≤ (Neumorphism)</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="./holiday_results/holiday_2022.js"></script>
    <script src="./holiday_results/holiday_2023.js"></script>
    <script src="./holiday_results/holiday_2024.js"></script>
    <script src="./holiday_results/holiday_2025.js"></script>
</head>

<body>
    <div class="container">
        <h1>‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏£‡∏ó‡πÑ‡∏ü‡∏ü‡πâ‡∏≤‡∏à‡∏≤‡∏Å‡πÑ‡∏ü‡∏•‡πå Excel</h1>

        <div id="dropArea" class="drop-area">
            <span class="icon">üìÑ</span>
            <p>‡∏•‡∏≤‡∏Å‡πÑ‡∏ü‡∏•‡πå Excel (.xlsx, .xls) ‡∏°‡∏≤‡∏ß‡∏≤‡∏á‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà</p>
            <p>‡∏´‡∏£‡∏∑‡∏≠‡∏Ñ‡∏•‡∏¥‡∏Å‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏ü‡∏•‡πå</p>
            <input type="file" id="excelFile" accept=".xlsx, .xls">
        </div>

        <div class="controls">
            <div class="control-group">
                <label for="monthYearSelector">‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÄ‡∏î‡∏∑‡∏≠‡∏ô:</label>
                <div class="select-wrapper">
                    <select id="monthYearSelector" onchange="updateDisplay()">
                    </select>
                </div>
            </div>

            <div class="control-group">
                <label for="arTypeSelector">‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó AR:</label>
                <div class="select-wrapper">
                    <select id="arTypeSelector" onchange="updateDisplay()">
                        <option value="AR1">AR1</option>
                        <option value="AR6">AR6</option>
                        <option value="HA1">HA1</option>
                    </select>
                </div>
            </div>

            <div class="control-group">
                <label for="unitSelector">‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏´‡∏ô‡πà‡∏ß‡∏¢:</label>
                <div class="select-wrapper">
                    <select id="unitSelector" onchange="updateDisplay()">
                        <option value="kwh_kvarh">kWh, kVarh</option>
                        <option value="kw_kvar">kW, kVar</option>
                    </select>
                </div>
            </div>

            <div class="control-group checkbox-group">
                <input type="checkbox" id="applyMultiplier" onchange="updateDisplay()">
                <label for="applyMultiplier" class="custom-checkbox">
                    ‡∏Ñ‡∏π‡∏ì‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏î‡πâ‡∏ß‡∏¢‡∏ï‡∏±‡∏ß‡∏Ñ‡∏π‡∏ì
                    <span class="icon-checked">‚úî</span> <span class="icon-unchecked"></span> </label>
            </div>

            <div class="control-group">
                <button id="exportExcel" class="button">Export Data to Excel</button>
            </div>
        </div>

        <div id="output"></div>
    </div>

    <script>
        const holidays = new Set();
        let globalResults = []; // Stores all raw data from the Excel file
        let isProcessed = false; // Status if file is processed
        let meterNumber = '';
        let multiplier = 0; // The base multiplier from the Excel file

        // monthlySummaries and monthlyMaxValues will now store the data for the CURRENTLY DISPLAYED summary data (all months)
        let monthlySummaries = {};
        let monthlyMaxValues = {};

        let sortState = {
            columnIndex: null,
            direction: 'asc'
        };

        const dropArea = document.getElementById('dropArea');
        const excelFileInput = document.getElementById('excelFile');

        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropArea.addEventListener(eventName, preventDefaults, false);
            document.body.addEventListener(eventName, preventDefaults, false);
        });

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        ['dragenter', 'dragover'].forEach(eventName => {
            dropArea.addEventListener(eventName, () => dropArea.classList.add('drag-over'), false);
        });

        ['dragleave', 'drop'].forEach(eventName => {
            dropArea.addEventListener(eventName, () => dropArea.classList.remove('drag-over'), false);
        });

        dropArea.addEventListener('drop', handleDrop, false);

        function handleDrop(e) {
            const dt = e.dataTransfer;
            const files = dt.files;

            if (files.length > 0) {
                // Reset isProcessed when a new file is dropped
                isProcessed = false;
                excelFileInput.files = files;
                process();
            }
        }

        dropArea.addEventListener('click', () => {
            excelFileInput.click();
        });

        excelFileInput.addEventListener('change', () => {
            if (excelFileInput.files.length > 0) {
                // Reset isProcessed when a new file is selected
                isProcessed = false;
                process();
            }
        });

        // Helper function to extract BKK time components from a UTC-adjusted Date object.
        function getBKKTimeComponents(utcDateObj) {
            return {
                hour: utcDateObj.getUTCHours(),
                minute: utcDateObj.getUTCMinutes(),
                second: utcDateObj.getUTCSeconds(),
                day: utcDateObj.getUTCDate(),
                month: utcDateObj.getUTCMonth(), // 0-indexed
                year: utcDateObj.getUTCFullYear(),
                dayOfWeek: utcDateObj.getUTCDay() // BKK day of week (0=Sun, 6=Sat)
            };
        }

        // Helper function to get a Date object representing midnight of a calendar day in BKK timezone.
        // The returned Date object's UTC components will *directly* represent BKK midnight.
        function getBKKMidnightUTCAdjusted(year, monthIndex, day) { // monthIndex is 0-indexed
            // Create a Date object where its UTC components directly represent BKK midnight for the given day.
            const d = new Date(Date.UTC(year, monthIndex, day, 0, 0, 0));
            return d;
        }

        // ******** ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏õ‡∏•‡∏á Excel Date ‡πÄ‡∏õ‡πá‡∏ô BKK Time ‡πÉ‡∏ô‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö UTC-adjusted (‡∏à‡∏∏‡∏î‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏ó‡∏µ‡πà‡∏õ‡∏£‡∏±‡∏ö) ********
        function convertExcelDateToBKKUTCAdjusted(rawDate) {
            let dateObj;
            const bkkOffsetMs = 7 * 60 * 60 * 1000; // 7 hours in milliseconds

            if (rawDate instanceof Date) {
                dateObj = new Date(rawDate.getTime() + bkkOffsetMs);
            } else if (typeof rawDate === 'number') {
                const parsed = XLSX.SSF.parse_date_code(rawDate);
                dateObj = new Date(Date.UTC(parsed.y, parsed.m - 1, parsed.d, parsed.H, parsed.M, parsed.S));
            } else if (typeof rawDate === 'string') {
                const match = rawDate.match(/(\d{1,2})\/(\d{1,2})\/(\d{4})\s*(\d{1,2}):(\d{2}):(\d{2})|(\d{4})-(\d{1,2})-(\d{1,2})T(\d{1,2}):(\d{2}):(\d{2})/);
                if (match) {
                    let year, month, day, hour, minute, second;
                    if (match[1]) { // DD/MM/YYYY HH:mm:ss format
                        [, day, month, year, hour, minute, second] = match;
                        year = parseInt(year) > 2500 ? parseInt(year) - 543 : parseInt(year); // Convert Buddhist year to AD
                    } else if (match[7]) { //YYYY-MM-DDTHH:mm:ss format
                        [, , , , , , year, month, day, hour, minute, second] = match;
                    }
                    dateObj = new Date(Date.UTC(parseInt(year), parseInt(month) - 1, parseInt(day), parseInt(hour), parseInt(minute), parseInt(second)));
                } else {
                    let tempDate = new Date(rawDate);
                    if (!isNaN(tempDate.getTime())) {
                        dateObj = new Date(tempDate.getTime() + bkkOffsetMs);
                    } else {
                        return null;
                    }
                }
            } else {
                return null;
            }

            return isNaN(dateObj.getTime()) ? null : dateObj;
        }
        // ******************************************************************************

        function collectHolidays() {
            holidays.clear();
            const allHolidayVars = [
                typeof holiday_2022 !== 'undefined' ? holiday_2022 : null,
                typeof holiday_2023 !== 'undefined' ? holiday_2023 : null,
                typeof holiday_2024 !== 'undefined' ? holiday_2024 : null,
                typeof holiday_2025 !== 'undefined' ? holiday_2025 : null
            ];
            allHolidayVars.forEach(data => {
                if (!data || !data.data) return;
                data.data.forEach(entry => {
                    if (entry.tou === 1 && entry.holiday) {
                        const [d, m, byear] = entry.holiday.split('/');
                        const year = parseInt(byear) - 543;

                        const bkkHolidayMidnight = getBKKMidnightUTCAdjusted(year, parseInt(m) - 1, parseInt(d));

                        const isoDate = bkkHolidayMidnight.toISOString().split('T')[0];
                        holidays.add(isoDate);
                    }
                });
            });
        }

        function isHoliday(date) {
            let checkDate = new Date(date.getTime());

            const bkkComponents = getBKKTimeComponents(checkDate);
            let hour = bkkComponents.hour;
            let min = bkkComponents.minute;

            if (hour === 0 && min < 15) {
                checkDate.setUTCHours(checkDate.getUTCHours() - 24);
            }

            const finalBkkComponents = getBKKTimeComponents(checkDate);
            const iso = finalBkkComponents.year + '-' +
                String(finalBkkComponents.month + 1).padStart(2, '0') + '-' +
                String(finalBkkComponents.day).padStart(2, '0');
            return holidays.has(iso);
        }

        function getRate(date) {
            let checkDate = new Date(date.getTime());

            const bkkComponents = getBKKTimeComponents(checkDate);
            let hour = bkkComponents.hour;
            let min = bkkComponents.minute;

            if (hour === 0 && min < 15) {
                checkDate.setUTCHours(checkDate.getUTCHours() - 24);
                const adjustedBkkComponents = getBKKTimeComponents(checkDate);
                hour = adjustedBkkComponents.hour;
                min = adjustedBkkComponents.minute;
            }

            const day = getBKKTimeComponents(checkDate).dayOfWeek;
            if (isHoliday(date) || day === 0 || day === 6) {
                return 'Holiday';
            }

            const totalMin = hour * 60 + min;
            const peakStart = 9 * 60 + 15; // 09:15
            const peakEnd = 22 * 60; // 22:00

            if (totalMin >= peakStart && totalMin <= peakEnd) {
                return 'Peak';
            } else {
                return 'Off-peak';
            }
        }

        function getDaysInMonth(year, month) {
            return new Date(Date.UTC(year, month, 0)).getUTCDate();
        }

        function getReadingDay(year, month, arType) { // month is 1-indexed here (1-12)
            const numDaysInMonth = getDaysInMonth(year, month);

            if (arType === 'AR1') {
                return numDaysInMonth - 10;
            } else if (arType === 'AR6') {
                return numDaysInMonth - 2;
            } else if (arType === 'HA1') {
                return 1;
            }
            console.error(`[getReadingDay] Unknown AR Type: ${arType}`);
            return -1;
        }

        function isInBillingPeriod(dateObject, arType, targetMonth, targetYear) {
            let billingPeriodStartDate, billingPeriodEndDate;

            if (arType === 'HA1') {
                billingPeriodStartDate = getBKKMidnightUTCAdjusted(targetYear, targetMonth - 1, 1);
                billingPeriodStartDate.setMinutes(billingPeriodStartDate.getMinutes() + 15);

                let nextMonth = targetMonth + 1;
                let nextMonthYear = targetYear;
                if (nextMonth > 12) {
                    nextMonth = 1;
                    nextMonthYear++;
                }
                billingPeriodEndDate = getBKKMidnightUTCAdjusted(nextMonthYear, nextMonth - 1, 1);

            } else {
                let prevReadingMonth = targetMonth - 1;
                let prevReadingYear = targetYear;
                if (prevReadingMonth === 0) {
                    prevReadingMonth = 12;
                    prevReadingYear--;
                }

                const prevReadingDay = getReadingDay(prevReadingYear, prevReadingMonth, arType);
                if (prevReadingDay === -1) {
                    return false;
                }

                billingPeriodStartDate = getBKKMidnightUTCAdjusted(prevReadingYear, prevReadingMonth - 1, prevReadingDay);
                billingPeriodStartDate.setMinutes(billingPeriodStartDate.getMinutes() + 15);

                const currentReadingDay = getReadingDay(targetYear, targetMonth, arType);
                if (currentReadingDay === -1) {
                    return false;
                }

                let thisMonthReadingDate = getBKKMidnightUTCAdjusted(targetYear, targetMonth - 1, currentReadingDay);
                billingPeriodEndDate = new Date(thisMonthReadingDate.getTime());
                billingPeriodEndDate.setUTCHours(0);
                billingPeriodEndDate.setUTCMinutes(0);
                billingPeriodEndDate.setUTCSeconds(0);
            }
            // console.log(`Checking date: ${dateObject.toISOString()} against period: ${billingPeriodStartDate.toISOString()} to ${billingPeriodEndDate.toISOString()}`);
            return dateObject.getTime() >= billingPeriodStartDate.getTime() && dateObject.getTime() <= billingPeriodEndDate.getTime();
        }

        function sortTable(columnIndex) {
            if (!isProcessed) return;

            if (sortState.columnIndex === columnIndex) {
                sortState.direction = sortState.direction === 'asc' ? 'desc' : 'asc';
            } else {
                sortState.columnIndex = columnIndex;
                if (columnIndex === 0) { // Datetime
                    sortState.direction = 'asc';
                } else if (columnIndex === 1) { // Rate
                    sortState.direction = 'asc';
                } else { // Numeric columns
                    sortState.direction = 'desc';
                }
            }

            updateDisplay(); // Re-render the detailed table after sorting
        }

        function customRound(value, decimalPlaces) {
            const factor = Math.pow(10, decimalPlaces);
            return Math.round(value * factor) / factor;
        }

        function populateMonthYearSelector() {
            const selector = document.getElementById('monthYearSelector');
            selector.innerHTML = '';

            const monthNames = ["‡∏°‡∏Å‡∏£‡∏≤‡∏Ñ‡∏°", "‡∏Å‡∏∏‡∏°‡∏†‡∏≤‡∏û‡∏±‡∏ô‡∏ò‡πå", "‡∏°‡∏µ‡∏ô‡∏≤‡∏Ñ‡∏°", "‡πÄ‡∏°‡∏©‡∏≤‡∏¢‡∏ô", "‡∏û‡∏§‡∏©‡∏†‡∏≤‡∏Ñ‡∏°", "‡∏°‡∏¥‡∏ñ‡∏∏‡∏ô‡∏≤‡∏¢‡∏ô", "‡∏Å‡∏£‡∏Å‡∏é‡∏≤‡∏Ñ‡∏°", "‡∏™‡∏¥‡∏á‡∏´‡∏≤‡∏Ñ‡∏°", "‡∏Å‡∏±‡∏ô‡∏¢‡∏≤‡∏¢‡∏ô", "‡∏ï‡∏∏‡∏•‡∏≤‡∏Ñ‡∏°", "‡∏û‡∏§‡∏®‡∏à‡∏¥‡∏Å‡∏≤‡∏¢‡∏ô", "‡∏ò‡∏±‡∏ô‡∏ß‡∏≤‡∏Ñ‡∏°"];

            const uniqueMonthYears = new Set();
            globalResults.forEach(r => {
                const {
                    year,
                    month
                } = getBKKTimeComponents(r.dateObject);
                uniqueMonthYears.add(`${year}-${(month + 1).toString().padStart(2, '0')}`);
            });

            const sortedUniqueMonthYears = Array.from(uniqueMonthYears).sort();

            const allOption = document.createElement('option');
            allOption.value = 'all';
            allOption.textContent = '‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î';
            selector.appendChild(allOption);

            sortedUniqueMonthYears.forEach(periodStr => {
                const [yearStr, monthStr] = periodStr.split('-');
                const year = parseInt(yearStr);
                const month = parseInt(monthStr);

                const option = document.createElement('option');
                option.value = `${year}-${month.toString().padStart(2, '0')}`;
                option.textContent = `${monthNames[month - 1]} ${year + 543}`;
                selector.appendChild(option);
            });

            if (sortedUniqueMonthYears.length > 0) {
                // Set default to the latest month available
                selector.value = sortedUniqueMonthYears[sortedUniqueMonthYears.length - 1];
            }
        }

        function getBillingPeriodDates(selectedYear, selectedMonth, arType) {
            let billingPeriodStartDate, billingPeriodEndDate;

            if (arType === 'HA1') {
                billingPeriodStartDate = getBKKMidnightUTCAdjusted(selectedYear, selectedMonth - 1, 1);
                billingPeriodStartDate.setMinutes(billingPeriodStartDate.getMinutes() + 15);

                let nextMonth = selectedMonth + 1;
                let nextMonthYear = selectedYear;
                if (nextMonth > 12) {
                    nextMonth = 1;
                    nextMonthYear++;
                }
                billingPeriodEndDate = getBKKMidnightUTCAdjusted(nextMonthYear, nextMonth - 1, 1);

            } else {
                let prevReadingMonth = selectedMonth - 1;
                let prevReadingYear = selectedYear;
                if (prevReadingMonth === 0) {
                    prevReadingMonth = 12;
                    prevReadingYear--;
                }

                const prevReadingDay = getReadingDay(prevReadingYear, prevReadingMonth, arType);
                if (prevReadingDay === -1) {
                    console.error(`[getBillingPeriodDates] Failed to get previous reading day for ${prevReadingYear}-${prevReadingMonth}`);
                    return {
                        startDate: null,
                        endDate: null
                    };
                }

                billingPeriodStartDate = getBKKMidnightUTCAdjusted(prevReadingYear, prevReadingMonth - 1, prevReadingDay);
                billingPeriodStartDate.setMinutes(billingPeriodStartDate.getMinutes() + 15);


                const currentReadingDay = getReadingDay(selectedYear, selectedMonth, arType);
                if (currentReadingDay === -1) {
                    console.error(`[getBillingPeriodDates] Could not determine currentReadingDay for ${selectedYear}-${selectedMonth}`);
                    return {
                        startDate: null,
                        endDate: null
                    };
                }

                let thisMonthReadingDate = getBKKMidnightUTCAdjusted(selectedYear, selectedMonth - 1, currentReadingDay);
                billingPeriodEndDate = new Date(thisMonthReadingDate.getTime());
                billingPeriodEndDate.setUTCHours(0);
                billingPeriodEndDate.setUTCMinutes(0);
                billingPeriodEndDate.setUTCSeconds(0);
            }

            return {
                startDate: billingPeriodStartDate,
                endDate: billingPeriodEndDate
            };
        }


        function calculateAllMonthsSummariesAndMaxes(selectedArType) {
            const calculatedMonthlySummaries = {};
            const calculatedMonthlyMaxValues = {};

            const applyMultiplierForSummaryCalculation = document.getElementById('applyMultiplier').checked;
            const currentMultiplierForSummaryCalculation = applyMultiplierForSummaryCalculation ? multiplier : 1;

            const decimalPlacesForKwSummary = 3;

            // First, determine all unique billing months present in the data for the selected AR type
            const uniqueBillingMonthYears = new Set();
            globalResults.forEach(r => {
                // For each data point, determine which billing period it *could* belong to.
                // This is a bit tricky since one data point's calendar month might be different from its billing month.
                // We need to iterate through possible target months.
                // A simpler approach for this summary calculation is to find all unique (year, month) pairs for the *data points themselves*,
                // then for each of those calendar months, figure out its billing period, and aggregate.
                // However, the `isInBillingPeriod` function already takes `targetMonth` and `targetYear`.
                // So, let's iterate through all *actual calendar months* present in the data.
                const bkkComponents = getBKKTimeComponents(r.dateObject);
                const calendarMonthKey = `${bkkComponents.year}-${(bkkComponents.month + 1).toString().padStart(2, '0')}`;
                uniqueBillingMonthYears.add(calendarMonthKey);
            });

            // Now, for each unique calendar month found in the data, calculate its billing period summary
            // This ensures that each "billing month" in the summary table corresponds to a distinct billing period.
            Array.from(uniqueBillingMonthYears).sort().forEach(monthKey => {
                const [yearStr, monthStr] = monthKey.split('-');
                const targetYear = parseInt(yearStr);
                const targetMonth = parseInt(monthStr); // 1-indexed

                const { startDate, endDate } = getBillingPeriodDates(targetYear, targetMonth, selectedArType);

                if (!startDate || !endDate) {
                    console.warn(`Skipping summary for ${monthKey} due to invalid billing period dates.`);
                    return;
                }

                // Initialize summary and max values for this billing month
                calculatedMonthlySummaries[monthKey] = {
                    'Peak': { wh: 0, varh: 0 },
                    'Off-peak': { wh: 0, varh: 0 },
                    'Holiday': { wh: 0, varh: 0 }
                };
                calculatedMonthlyMaxValues[monthKey] = {
                    'Peak': { wh: 0, varh: 0, wh_datetime: '', varh_datetime: '' },
                    'Off-peak': { wh: 0, varh: 0, wh_datetime: '', varh_datetime: '' },
                    'Holiday': { wh: 0, varh: 0, wh_datetime: '', varh_datetime: '' }
                };

                globalResults.forEach(r => {
                    const dateObjectBKK = r.dateObject;
                    // Check if this data point falls within the *current billing period* being processed
                    if (dateObjectBKK.getTime() >= startDate.getTime() && dateObjectBKK.getTime() <= endDate.getTime()) {
                        const originalWhValue = r.originalWhValue || 0;
                        const originalVarhValue = r.originalVarhValue || 0;
                        const rate = getRate(dateObjectBKK);

                        const wh_sum_value = (originalWhValue * currentMultiplierForSummaryCalculation);
                        const varh_sum_value = (originalVarhValue * currentMultiplierForSummaryCalculation);

                        calculatedMonthlySummaries[monthKey][rate].wh += wh_sum_value;
                        calculatedMonthlySummaries[monthKey][rate].varh += varh_sum_value;

                        const kW_calculated_base = customRound((Math.round(originalWhValue * 4) * currentMultiplierForSummaryCalculation / 1000), decimalPlacesForKwSummary);
                        const kVar_calculated_base = customRound((Math.round(originalVarhValue * 4) * currentMultiplierForSummaryCalculation / 1000), decimalPlacesForKwSummary);

                        if (kW_calculated_base > calculatedMonthlyMaxValues[monthKey][rate].wh ||
                            (kW_calculated_base === calculatedMonthlyMaxValues[monthKey][rate].wh &&
                                new Date(r.datetime) < new Date(calculatedMonthlyMaxValues[monthKey][rate].wh_datetime))) {
                            calculatedMonthlyMaxValues[monthKey][rate].wh = kW_calculated_base;
                            calculatedMonthlyMaxValues[monthKey][rate].wh_datetime = r.datetime;
                        }
                        if (kVar_calculated_base > calculatedMonthlyMaxValues[monthKey][rate].varh ||
                            (kVar_calculated_base === calculatedMonthlyMaxValues[monthKey][rate].varh &&
                                new Date(r.datetime) < new Date(calculatedMonthlyMaxValues[monthKey][rate].varh_datetime))) {
                            calculatedMonthlyMaxValues[monthKey][rate].varh = kVar_calculated_base;
                            calculatedMonthlyMaxValues[monthKey][rate].varh_datetime = r.datetime;
                        }
                    }
                });
            });

            return { monthlySummaries: calculatedMonthlySummaries, monthlyMaxValues: calculatedMonthlyMaxValues };
        }


        function renderMonthlySummaryTable(monthlySummariesToRender, monthlyMaxValuesToRender) {
            if (!isProcessed || Object.keys(monthlySummariesToRender).length === 0) {
                return `
                    <div class="summary-section">
                        <h2 class="section-title">‡∏™‡∏£‡∏∏‡∏õ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏û‡∏•‡∏±‡∏á‡∏á‡∏≤‡∏ô‡∏£‡∏≤‡∏¢‡πÄ‡∏î‡∏∑‡∏≠‡∏ô</h2>
                        <p>‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏û‡∏•‡∏±‡∏á‡∏á‡∏≤‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó AR ‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å</p>
                    </div>
                `;
            }

            let monthlyTableHtml = `
                <div class="summary-section">
                <h2 class="section-title">‡∏™‡∏£‡∏∏‡∏õ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏û‡∏•‡∏±‡∏á‡∏á‡∏≤‡∏ô‡∏£‡∏≤‡∏¢‡πÄ‡∏î‡∏∑‡∏≠‡∏ô</h2>
                <div class="monthly-summary-table-container">
                <table>
                    <thead>
                        <tr>
                            <th>‡πÄ‡∏î‡∏∑‡∏≠‡∏ô/‡∏õ‡∏µ</th>
                            <th>kWh (‡∏£‡∏ß‡∏°)</th>
                            <th>kWh (Peak)</th>
                            <th>kWh (Off-Peak)</th>
                            <th>kWh (Holiday)</th>
                            <th>kVarh (‡∏£‡∏ß‡∏°‡∏ó‡∏±‡πâ‡∏á‡∏™‡∏≤‡∏°‡πÄ‡∏£‡∏ó)</th>
                            <th>kW Max(Peak)</th>
                            <th>kW Max(Off-Peak)</th>
                            <th>kW Max(Holiday)</th>
                            <th>kVar Max(‡∏£‡∏ß‡∏°‡∏ó‡∏∏‡∏Å‡πÄ‡∏£‡∏ó)</th>
                            <th>‡πÄ‡∏ß‡∏•‡∏≤ kW (peak) ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î</th>
                            <th>‡πÄ‡∏ß‡∏•‡∏≤ kW (Off-Peak) ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î</th>
                            <th>‡πÄ‡∏ß‡∏•‡∏≤ kW (Holiday) ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            const monthNames = ["‡∏°.‡∏Ñ.", "‡∏Å.‡∏û.", "‡∏°‡∏µ.‡∏Ñ.", "‡πÄ‡∏°.‡∏¢.", "‡∏û.‡∏Ñ.", "‡∏°‡∏¥.‡∏¢.", "‡∏Å.‡∏Ñ.", "‡∏™.‡∏Ñ.", "‡∏Å.‡∏¢.", "‡∏ï.‡∏Ñ.", "‡∏û.‡∏¢.", "‡∏ò.‡∏Ñ."];
            const sortedMonthKeys = Object.keys(monthlySummariesToRender).sort((a, b) => {
                const [yearA, monthA] = a.split('-').map(Number);
                const [yearB, monthB] = b.split('-').map(Number);
                if (yearA !== yearB) return yearA - yearB;
                return monthA - monthB;
            }); // Sort ascending by year then month


            const decimalPlacesForKwhSummary = 2;
            const decimalPlacesForKwSummary = 3;


            sortedMonthKeys.forEach(monthKey => {
                const [yearStr, monthStr] = monthKey.split('-');
                const year = parseInt(yearStr);
                const monthIndex = parseInt(monthStr) - 1;

                const currentMonthSummary = monthlySummariesToRender[monthKey];
                const currentMonthMax = monthlyMaxValuesToRender[monthKey];

                const displayTotalWhMonth = customRound(((currentMonthSummary['Peak'].wh + currentMonthSummary['Off-peak'].wh + currentMonthSummary['Holiday'].wh) / 1000), decimalPlacesForKwhSummary);
                // console.log("Raw Wh sums for month (Peak, Off-peak, Holiday):", currentMonthSummary['Peak'].wh, currentMonthSummary['Off-peak'].wh, currentMonthSummary['Holiday'].wh);

                const displayTotalVarhMonth = customRound(((currentMonthSummary['Peak'].varh + currentMonthSummary['Off-peak'].varh + currentMonthSummary['Holiday'].varh) / 1000), decimalPlacesForKwhSummary);

                const displayPeakWh = customRound((currentMonthSummary['Peak'].wh / 1000), decimalPlacesForKwhSummary);
                const displayOffPeakWh = customRound((currentMonthSummary['Off-peak'].wh / 1000), decimalPlacesForKwhSummary);
                const displayHolidayWh = customRound((currentMonthSummary['Holiday'].wh / 1000), decimalPlacesForKwhSummary);

                const displayPeakKw = customRound(currentMonthMax['Peak'].wh, decimalPlacesForKwSummary);
                const displayOffPeakKw = customRound(currentMonthMax['Off-peak'].wh, decimalPlacesForKwSummary);
                const displayHolidayKw = customRound(currentMonthMax['Holiday'].wh, decimalPlacesForKwSummary);

                let baseMaxKvarMonthOverall = 0;
                ['Peak', 'Off-peak', 'Holiday'].forEach(rate => {
                    if (currentMonthMax[rate].varh > baseMaxKvarMonthOverall) {
                        baseMaxKvarMonthOverall = currentMonthMax[rate].varh;
                    }
                });
                const displayMaxKvarMonthOverall = customRound(baseMaxKvarMonthOverall, decimalPlacesForKwSummary);


                monthlyTableHtml += `
                    <tr>
                        <td>${monthNames[monthIndex]} ${year + 543}</td>
                        <td>${displayTotalWhMonth.toFixed(decimalPlacesForKwhSummary)}</td>
                        <td>${displayPeakWh.toFixed(decimalPlacesForKwhSummary)}</td>
                        <td>${displayOffPeakWh.toFixed(decimalPlacesForKwhSummary)}</td>
                        <td>${displayHolidayWh.toFixed(decimalPlacesForKwhSummary)}</td>
                        <td>${displayTotalVarhMonth.toFixed(decimalPlacesForKwhSummary)}</td>
                        <td>${displayPeakKw.toFixed(decimalPlacesForKwSummary)}</td>
                        <td>${displayOffPeakKw.toFixed(decimalPlacesForKwSummary)}</td>
                        <td>${displayHolidayKw.toFixed(decimalPlacesForKwSummary)}</td>
                        <td>${displayMaxKvarMonthOverall.toFixed(decimalPlacesForKwSummary)}</td>
                        <td><small>${currentMonthMax['Peak'].wh_datetime || 'N/A'}</small></td>
                        <td><small>${currentMonthMax['Off-peak'].wh_datetime || 'N/A'}</small></td>
                        <td><small>${currentMonthMax['Holiday'].wh_datetime || 'N/A'}</small></td>
                    </tr>
                `;
            });

            monthlyTableHtml += `
                    </tbody>
                </table>
                </div>
                </div>
            `;
            return monthlyTableHtml;
        }


        function renderResultsAsHtml(unitType, selectedMonthYear, selectedArType) {
            if (!isProcessed) return '';

            let whUnit, varhUnit;
            const applyMultiplier = document.getElementById('applyMultiplier').checked;
            const currentMultiplier = applyMultiplier ? multiplier : 1;

            let whCalculation, varhCalculation;
            let decimalPlacesForSummary;
            let decimalPlacesForTable;

            if (unitType === 'kw_kvar') {
                whUnit = 'kW';
                varhUnit = 'kVar';
                decimalPlacesForSummary = 3;
                decimalPlacesForTable = 3;

                whCalculation = (wh_val_raw) => {
                    const roundedWhTimesFour = Math.round(parseFloat(wh_val_raw) * 4);
                    return customRound((roundedWhTimesFour * currentMultiplier / 1000), decimalPlacesForTable);
                };
                varhCalculation = (varh_val_raw) => {
                    const roundedVarhTimesFour = Math.round(parseFloat(varh_val_raw) * 4);
                    return customRound((roundedVarhTimesFour * currentMultiplier / 1000), decimalPlacesForTable);
                };
            } else { // kWh, kVarh (as per UI selection, but displaying Wh for raw)
                whUnit = 'Wh';
                varhUnit = 'Varh';
                decimalPlacesForSummary = 2; // Summary still kWh/kVarh, 2 decimals
                decimalPlacesForTable = 5;

                whCalculation = (wh_val_raw) => {
                    return customRound((parseFloat(wh_val_raw) * currentMultiplier), decimalPlacesForTable);
                };

                varhCalculation = (varh_val_raw) => {
                    return customRound((parseFloat(varh_val_raw) * currentMultiplier), decimalPlacesForTable);
                };
            }

            let tableRowsHtml = '';

            let overallMaxBaseKwCalculated = { value: 0, datetime: '' };
            let overallMaxBaseKvarCalculated = { value: 0, datetime: '' };


            let filteredResults = [];
            if (selectedMonthYear === 'all') {
                filteredResults = [...globalResults];
            } else {
                const [yearStr, monthStr] = selectedMonthYear.split('-');
                const selectedMonthInt = parseInt(monthStr);
                const selectedYearInt = parseInt(yearStr);

                filteredResults = globalResults.filter(r => {
                    const isWithinBillingPeriod = isInBillingPeriod(r.dateObject, selectedArType, selectedMonthInt, selectedYearInt);
                    return isWithinBillingPeriod;
                });
            }

            const dataToRender = [...filteredResults];
            if (sortState.columnIndex !== null) {
                const directionModifier = sortState.direction === 'asc' ? 1 : -1;
                const selectedUnit = document.getElementById('unitSelector').value;
                const applyMultiplierForSort = document.getElementById('applyMultiplier').checked;
                const currentMultiplierForSort = applyMultiplierForSort ? multiplier : 1;

                let whUnitConverterForSort, varhUnitConverterForSort;
                if (selectedUnit === 'kw_kvar') {
                    whUnitConverterForSort = (wh_val) => (Math.round(parseFloat(wh_val) * 4) / 1000) * currentMultiplierForSort;
                    varhUnitConverterForSort = (varh_val) => (Math.round(parseFloat(varh_val) * 4) / 1000) * currentMultiplierForSort;
                } else {
                    whUnitConverterForSort = (wh_val) => (parseFloat(wh_val) * currentMultiplierForSort);
                    varhUnitConverterForSort = (varh_val) => (parseFloat(varh_val) * currentMultiplierForSort);
                }

                dataToRender.sort((a, b) => {
                    let valA, valB;
                    switch (sortState.columnIndex) {
                        case 0: // Datetime
                            valA = a.dateObject.getTime();
                            valB = b.dateObject.getTime();
                            break;
                        case 1: // Rate
                            valA = getRate(a.dateObject);
                            valB = getRate(b.dateObject);
                            const rateOrder = {
                                'Holiday': 1,
                                'Off-peak': 2,
                                'Peak': 3
                            };
                            return (rateOrder[valA] - rateOrder[valB]) * directionModifier;
                        case 2: // Wh/kW
                            valA = whUnitConverterForSort(a.originalWhValue);
                            valB = whUnitConverterForSort(b.originalWhValue);
                            break;
                        case 3: // VARh/kVar
                            valA = varhUnitConverterForSort(a.originalVarhValue);
                            valB = varhUnitConverterForSort(b.originalVarhValue);
                            break;
                        default:
                            return 0;
                    }

                    if (typeof valA === 'string') {
                        return valA.localeCompare(valB) * directionModifier;
                    } else {
                        return (valA - valB) * directionModifier;
                    }
                });
            }

            dataToRender.forEach(r => {
                const rawWh = r.originalWhValue || 0;
                const rawVarh = r.originalVarhValue || 0;

                if (unitType === 'kw_kvar') {
                    const currentCalculatedKwBase = Math.round(rawWh * 4) / 1000;
                    const currentCalculatedKvarBase = Math.round(rawVarh * 4) / 1000;

                    if (currentCalculatedKwBase > overallMaxBaseKwCalculated.value ||
                        (currentCalculatedKwBase === overallMaxBaseKwCalculated.value &&
                            new Date(r.datetime) < new Date(overallMaxBaseKwCalculated.datetime))) {
                        overallMaxBaseKwCalculated.value = currentCalculatedKwBase;
                        overallMaxBaseKwCalculated.datetime = r.datetime;
                    }

                    if (currentCalculatedKvarBase > overallMaxBaseKvarCalculated.value ||
                        (currentCalculatedKvarBase === overallMaxBaseKvarCalculated.value &&
                            new Date(r.datetime) < new Date(overallMaxBaseKvarCalculated.datetime))) {
                        overallMaxBaseKvarCalculated.value = currentCalculatedKvarBase;
                        overallMaxBaseKvarCalculated.datetime = r.datetime;
                    }
                }

                const currentWh = whCalculation(rawWh);
                const currentVarh = varhCalculation(rawVarh);

                let displayWhInTable, displayVarhInTable;
                displayWhInTable = currentWh.toFixed(decimalPlacesForTable);
                displayVarhInTable = currentVarh.toFixed(decimalPlacesForTable);

                let displayDatetime = r.datetime;
                const cls = getRate(r.dateObject).toLowerCase().replace('-', '');
                tableRowsHtml += `<tr class="${cls}">
            <td>${displayDatetime}</td><td>${getRate(r.dateObject)}</td>
            <td>${displayWhInTable}</td><td>${displayVarhInTable}</td>
        </tr>`;
            });


            let mainSummaryHtml = '';

            mainSummaryHtml += '<div class="rate-summary-container">';

            if (unitType === 'kw_kvar') {
                const displayOverallMaxKw = customRound(overallMaxBaseKwCalculated.value * currentMultiplier, decimalPlacesForSummary);
                const displayOverallMaxKvar = customRound(overallMaxBaseKvarCalculated.value * currentMultiplier, decimalPlacesForSummary);

                let displayPeakMaxKw = 'N/A';
                let displayPeakMaxKvar = 'N/A';
                let displayOffPeakMaxKw = 'N/A';
                let displayOffPeakMaxKvar = 'N/A';
                let displayHolidayMaxKw = 'N/A';
                let displayHolidayMaxKvar = 'N/A';

                if (selectedMonthYear !== 'all' && monthlyMaxValues[selectedMonthYear]) {
                    const currentMonthMaxData = monthlyMaxValues[selectedMonthYear];
                    if (currentMonthMaxData['Peak']) {
                        displayPeakMaxKw = customRound(currentMonthMaxData['Peak'].wh, decimalPlacesForSummary);
                        displayPeakMaxKvar = customRound(currentMonthMaxData['Peak'].varh, decimalPlacesForSummary);
                    }
                    if (currentMonthMaxData['Off-peak']) {
                        displayOffPeakMaxKw = customRound(currentMonthMaxData['Off-peak'].wh, decimalPlacesForSummary);
                        displayOffPeakMaxKvar = customRound(currentMonthMaxData['Off-peak'].varh, decimalPlacesForSummary);
                    }
                    if (currentMonthMaxData['Holiday']) {
                        displayHolidayMaxKw = customRound(currentMonthMaxData['Holiday'].wh, decimalPlacesForSummary);
                        displayHolidayMaxKvar = customRound(currentMonthMaxData['Holiday'].varh, decimalPlacesForSummary);
                    }
                }


                mainSummaryHtml += `
            <div class="summary-box overall-max-summary">
                <h3>kW/kVar ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î‡∏£‡∏ß‡∏°‡∏ó‡∏∏‡∏Å‡πÄ‡∏£‡∏ó</h3>
                <p>kW: <strong>${displayOverallMaxKw.toFixed(decimalPlacesForSummary)} ${whUnit}</strong><br>
                <small>‡πÄ‡∏°‡∏∑‡πà‡∏≠: ${overallMaxBaseKwCalculated.datetime || 'N/A'}</small></p>
                <p>kVar: <strong>${displayOverallMaxKvar.toFixed(decimalPlacesForSummary)} ${varhUnit}</strong><br>
                <small>‡πÄ‡∏°‡∏∑‡πà‡∏≠: ${overallMaxBaseKvarCalculated.datetime || 'N/A'}</small></p>
            </div>
            <div class="summary-box max-kw-peak-summary summary-peak">
                <h3>kW/kVar ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î (Peak)</h3>
                <p>kW: <strong>${displayPeakMaxKw !== 'N/A' ? displayPeakMaxKw.toFixed(decimalPlacesForSummary) : 'N/A'} ${whUnit}</strong><br>
                <small>‡πÄ‡∏°‡∏∑‡πà‡∏≠: ${selectedMonthYear !== 'all' && monthlyMaxValues[selectedMonthYear] && monthlyMaxValues[selectedMonthYear]['Peak'] ? monthlyMaxValues[selectedMonthYear]['Peak'].wh_datetime : 'N/A'}</small></p>
                <p>kVar: <strong>${displayPeakMaxKvar !== 'N/A' ? displayPeakMaxKvar.toFixed(decimalPlacesForSummary) : 'N/A'} ${varhUnit}</strong><br>
                <small>‡πÄ‡∏°‡∏∑‡πà‡∏≠: ${selectedMonthYear !== 'all' && monthlyMaxValues[selectedMonthYear] && monthlyMaxValues[selectedMonthYear]['Peak'] ? monthlyMaxValues[selectedMonthYear]['Peak'].varh_datetime : 'N/A'}</small></p>
            </div>
            <div class="summary-box max-kw-off-peak-summary summary-off-peak">
                <h3>kW/kVar ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î (Off-peak)</h3>
                <p>kW: <strong>${displayOffPeakMaxKw !== 'N/A' ? displayOffPeakMaxKw.toFixed(decimalPlacesForSummary) : 'N/A'} ${whUnit}</strong><br>
                <small>‡πÄ‡∏°‡∏∑‡πà‡∏≠: ${selectedMonthYear !== 'all' && monthlyMaxValues[selectedMonthYear] && monthlyMaxValues[selectedMonthYear]['Off-peak'] ? monthlyMaxValues[selectedMonthYear]['Off-peak'].wh_datetime : 'N/A'}</small></p>
                <p>kVar: <strong>${displayOffPeakMaxKvar !== 'N/A' ? displayOffPeakMaxKvar.toFixed(decimalPlacesForSummary) : 'N/A'} ${varhUnit}</strong><br>
                <small>‡πÄ‡∏°‡∏∑‡πà‡∏≠: ${selectedMonthYear !== 'all' && monthlyMaxValues[selectedMonthYear] && monthlyMaxValues[selectedMonthYear]['Off-peak'] ? monthlyMaxValues[selectedMonthYear]['Off-peak'].varh_datetime : 'N/A'}</small></p>
            </div>
            <div class="summary-box max-kw-holiday-summary summary-holiday">
                <h3>kW/kVar ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î (Holiday)</h3>
                <p>kW: <strong>${displayHolidayMaxKw !== 'N/A' ? displayHolidayMaxKw.toFixed(decimalPlacesForSummary) : 'N/A'} ${whUnit}</strong><br>
                <small>‡πÄ‡∏°‡∏∑‡πà‡∏≠: ${selectedMonthYear !== 'all' && monthlyMaxValues[selectedMonthYear] && monthlyMaxValues[selectedMonthYear]['Holiday'] ? monthlyMaxValues[selectedMonthYear]['Holiday'].wh_datetime : 'N/A'}</small></p>
                <p>kVar: <strong>${displayHolidayMaxKvar !== 'N/A' ? displayHolidayMaxKvar.toFixed(decimalPlacesForSummary) : 'N/A'} ${varhUnit}</strong><br>
                <small>‡πÄ‡∏°‡∏∑‡πà‡∏≠: ${selectedMonthYear !== 'all' && monthlyMaxValues[selectedMonthYear] && monthlyMaxValues[selectedMonthYear]['Holiday'] ? monthlyMaxValues[selectedMonthYear]['Holiday'].varh_datetime : 'N/A'}</small></p>
            </div>
        `;
            } else {
                let displayPeakWh = 0, displayPeakVarh = 0;
                let displayOffPeakWh = 0, displayOffPeakVarh = 0;
                let displayHolidayWh = 0, displayHolidayVarh = 0;
                let displayTotalWh = 0, displayTotalVarh = 0;

                if (selectedMonthYear !== 'all' && monthlySummaries[selectedMonthYear]) {
                    const selectedMonthSummary = monthlySummaries[selectedMonthYear];
                    displayPeakWh = selectedMonthSummary['Peak'].wh / 1000;
                    displayPeakVarh = selectedMonthSummary['Peak'].varh / 1000;
                    displayOffPeakWh = selectedMonthSummary['Off-peak'].wh / 1000;
                    displayOffPeakVarh = selectedMonthSummary['Off-peak'].varh / 1000;
                    displayHolidayWh = selectedMonthSummary['Holiday'].wh / 1000;
                    displayHolidayVarh = selectedMonthSummary['Holiday'].varh / 1000;

                    displayTotalWh = displayPeakWh + displayOffPeakWh + displayHolidayWh;
                    displayTotalVarh = displayPeakVarh + displayOffPeakVarh + displayHolidayVarh;
                } else if (selectedMonthYear === 'all') {
                    // If "‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î" is selected, sum up all monthly summaries
                    for (const monthKey in monthlySummaries) {
                        if (monthlySummaries.hasOwnProperty(monthKey)) {
                            const monthSummary = monthlySummaries[monthKey];
                            displayPeakWh += monthSummary['Peak'].wh / 1000;
                            displayPeakVarh += monthSummary['Peak'].varh / 1000;
                            displayOffPeakWh += monthSummary['Off-peak'].wh / 1000;
                            displayOffPeakVarh += monthSummary['Off-peak'].varh / 1000;
                            displayHolidayWh += monthSummary['Holiday'].wh / 1000;
                            displayHolidayVarh += monthSummary['Holiday'].varh / 1000;
                        }
                    }
                    displayTotalWh = displayPeakWh + displayOffPeakWh + displayHolidayWh;
                    displayTotalVarh = displayPeakVarh + displayOffPeakVarh + displayHolidayVarh;
                }

                mainSummaryHtml += `
            <div class="summary-box consumption-summary">
                <h3>‡∏™‡∏£‡∏∏‡∏õ‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏û‡∏•‡∏±‡∏á‡∏á‡∏≤‡∏ô (‡∏£‡∏ß‡∏°)</h3>
                <p>‡∏£‡∏ß‡∏° Peak: <strong>${displayPeakWh.toFixed(decimalPlacesForSummary)} kWh</strong>, <strong>${displayPeakVarh.toFixed(decimalPlacesForSummary)} kVarh</strong></p>
                <p>‡∏£‡∏ß‡∏° Off-peak: <strong>${displayOffPeakWh.toFixed(decimalPlacesForSummary)} kWh</strong>, <strong>${displayOffPeakVarh.toFixed(decimalPlacesForSummary)} kVarh</strong></p>
                <p>‡∏£‡∏ß‡∏° Holiday: <strong>${displayHolidayWh.toFixed(decimalPlacesForSummary)} kWh</strong>, <strong>${displayHolidayVarh.toFixed(decimalPlacesForSummary)} kVarh</strong></p>
                <p class="total-overall">‡∏£‡∏ß‡∏°‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î: <strong>${displayTotalWh.toFixed(decimalPlacesForSummary)} kWh</strong>, <strong>${displayTotalVarh.toFixed(decimalPlacesForSummary)} kVarh</strong></p>
            </div>
        `;
            }

            mainSummaryHtml += '</div>';

            const headers = [{
                title: '‡∏ß‡∏±‡∏ô‡πÄ‡∏ß‡∏•‡∏≤',
                index: 0
            }, {
                title: '‡πÄ‡∏£‡∏ó',
                index: 1
            }, {
                title: whUnit,
                index: 2
            }, {
                title: varhUnit,
                index: 3
            }];

            const headerHtml = headers.map(h => {
                const isActiveSort = sortState.columnIndex !== null && sortState.columnIndex === h.index;
                const sortClass = isActiveSort ? `active-sort ${sortState.direction}` : '';
                return `<th class="sortable ${sortClass}" onclick="sortTable(${h.index})" data-column-index="${h.index}">
                        ${h.title} <span class="sort-indicator"></span>
                    </th>`;
            }).join('');

            let tableHtml = `<h2 class="section-title">‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏£‡∏≤‡∏¢ 15 ‡∏ô‡∏≤‡∏ó‡∏µ</h2><table><tr>${headerHtml}</tr>${tableRowsHtml}</table>`;

            return mainSummaryHtml + tableHtml;
        }


        async function process() {
            if (isProcessed) {
                console.log("File already processed. Skipping re-processing.");
                return;
            }

            collectHolidays();
            const file = excelFileInput.files[0];
            if (!file) {
                alert("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏ü‡∏•‡πå Excel ‡∏´‡∏£‡∏∑‡∏≠‡∏•‡∏≤‡∏Å‡πÑ‡∏ü‡∏•‡πå‡∏°‡∏≤‡∏ß‡∏≤‡∏á‡∏Å‡πà‡∏≠‡∏ô‡∏Ñ‡∏£‡∏±‡∏ö/‡∏Ñ‡πà‡∏∞");
                return;
            }

            dropArea.innerHTML = `<span class="icon" style="color: #28a745;">‚úÖ</span><p>‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å: <strong>${file.name}</strong></p>`;
            document.getElementById('output').innerHTML = '<p>‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÑ‡∏ü‡∏•‡πå...</p>';


            const reader = new FileReader();
            reader.onload = function (e) {
                const data = new Uint8Array(e.target.result);
                const wb = XLSX.read(data, {
                    type: 'array',
                    cellDates: true
                });
                const sheet = wb.Sheets[wb.SheetNames[0]];

                let startRowForData = 3;
                let rawDateCol, whCol, varhCol;
                let isCompactFormat = false;

                const headerRowCompact = XLSX.utils.sheet_to_json(sheet, { header: 1, range: 'A1:C1' })[0];
                // console.log("Header row for compact check:", headerRowCompact); // Commented out for cleaner console

                if (headerRowCompact &&
                    headerRowCompact[0] === 'DATE_M' &&
                    headerRowCompact[1] === 'WH' &&
                    headerRowCompact[2] === 'VARHIMP Total') {

                    console.log("Detected compact format (3 columns).");
                    isCompactFormat = true;
                    startRowForData = 1;
                    rawDateCol = 0;
                    whCol = 1;
                    varhCol = 2;

                    meterNumber = 'N/A (Compact File)';
                    multiplier = 1;
                } else {
                    console.log("Detected standard format.");
                    isCompactFormat = false;
                    startRowForData = 3;
                    rawDateCol = 2;
                    whCol = 26;
                    varhCol = 34;

                    if (sheet['A4'] && sheet['A4'].v !== undefined) {
                        meterNumber = sheet['A4'].v.toString();
                    } else {
                        meterNumber = 'N/A';
                    }

                    const e4 = parseFloat(sheet['E4'] ? sheet['E4'].v : 0);
                    const f4 = parseFloat(sheet['F4'] ? sheet['F4'].v : 0);
                    const g4 = parseFloat(sheet['G4'] ? sheet['G4'].v : 0);
                    const h4 = parseFloat(sheet['H4'] ? sheet['H4'].v : 0);

                    if (f4 !== 0 && h4 !== 0) {
                        multiplier = (e4 / f4) * (g4 / h4);
                    } else {
                        multiplier = 0;
                    }
                }


                const rows = XLSX.utils.sheet_to_json(sheet, {
                    header: 1
                });

                globalResults = [];
                isProcessed = false;

                for (let i = startRowForData; i < rows.length; i++) {
                    const rawDate = rows[i][rawDateCol];
                    const originalWhValue = parseFloat(rows[i][whCol]) || 0;
                    const originalVarhValue = parseFloat(rows[i][varhCol]) || 0;

                    if (!rawDate || isNaN(originalWhValue) || isNaN(originalVarhValue)) continue;

                    let dateObjectBKK = convertExcelDateToBKKUTCAdjusted(rawDate);
                    if (!dateObjectBKK) continue;

                    const totalMinutesFromBKKMidnight = dateObjectBKK.getUTCHours() * 60 + dateObjectBKK.getUTCMinutes() + dateObjectBKK.getUTCSeconds() / 60;
                    const roundedTotalMinutesBKK = Math.round(totalMinutesFromBKKMidnight / 15) * 15;

                    const roundedDateObjectUTC = new Date(Date.UTC(
                        dateObjectBKK.getUTCFullYear(),
                        dateObjectBKK.getUTCMonth(),
                        dateObjectBKK.getUTCDate(),
                        0,
                        roundedTotalMinutesBKK,
                        0, 0
                    ));

                    const displayBkkComponents = getBKKTimeComponents(roundedDateObjectUTC);
                    const formattedDatetime = `${displayBkkComponents.year}/${(displayBkkComponents.month + 1).toString().padStart(2, '0')}/${displayBkkComponents.day.toString().padStart(2, '0')} ${displayBkkComponents.hour.toString().padStart(2, '0')}:${displayBkkComponents.minute.toString().padStart(2, '0')}:00`;

                    globalResults.push({
                        datetime: formattedDatetime,
                        originalWhValue: originalWhValue,
                        originalVarhValue: originalVarhValue,
                        dateObject: roundedDateObjectUTC
                    });
                }

                isProcessed = true;
                sortState.columnIndex = null;
                sortState.direction = 'asc';

                populateMonthYearSelector();
                updateDisplay();
            };
            reader.readAsArrayBuffer(file);
        }

        function updateDisplay() {
            if (!isProcessed) {
                return;
            }
            const selectedMonthYear = document.getElementById('monthYearSelector').value;
            const selectedArType = document.getElementById('arTypeSelector').value;
            const selectedUnit = document.getElementById('unitSelector').value;

            console.log(`[updateDisplay] User selected Month/Year: ${selectedMonthYear}, AR Type: ${selectedArType}`);

            const outputDiv = document.getElementById('output');
            outputDiv.innerHTML = '';

            const { monthlySummaries: calculatedMonthlySummaries, monthlyMaxValues: calculatedMonthlyMaxValues } =
                calculateAllMonthsSummariesAndMaxes(selectedArType);

            monthlySummaries = calculatedMonthlySummaries;
            monthlyMaxValues = calculatedMonthlyMaxValues;


            outputDiv.innerHTML += renderMonthlySummaryTable(monthlySummaries, monthlyMaxValues);

            const summaryBoxWrapper = document.createElement('div');
            summaryBoxWrapper.className = 'summary-box-wrapper';

            const formattedMultiplier = multiplier.toLocaleString('en-US', {
                minimumFractionDigits: 4,
                maximumFractionDigits: 4
            });
            const meterInfoHtml = `
                <div class="summary-box meter-info">
                    <h3>‡∏™‡∏£‡∏∏‡∏õ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏°‡∏¥‡πÄ‡∏ï‡∏≠‡∏£‡πå‡πÅ‡∏•‡∏∞‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏û‡∏•‡∏±‡∏á‡∏á‡∏≤‡∏ô</h3>
                    <p>‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏•‡∏Ç‡∏°‡∏¥‡πÄ‡∏ï‡∏≠‡∏£‡πå: <strong>${meterNumber || 'N/A'}</strong></p>
                    <p>‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡∏±‡∏ß‡∏Ñ‡∏π‡∏ì: <strong>${formattedMultiplier}</strong></p>
                </div>`;
            summaryBoxWrapper.innerHTML += meterInfoHtml;

            const billingPeriodInfoDiv = document.createElement('div');
            billingPeriodInfoDiv.className = 'summary-box billing-period-info';

            if (selectedMonthYear !== 'all') {
                const [yearStr, monthStr] = selectedMonthYear.split('-');
                const selectedMonthInt = parseInt(monthStr);
                const selectedYearInt = parseInt(yearStr);

                const {
                    startDate,
                    endDate
                } = getBillingPeriodDates(selectedYearInt, selectedMonthInt, selectedArType);

                if (startDate && endDate) {
                    const formatDateTime = (dateObj) => {
                        const bkkComponents = {
                            year: dateObj.getUTCFullYear(),
                            month: dateObj.getUTCMonth(),
                            day: dateObj.getUTCDate(),
                            hour: dateObj.getUTCHours(),
                            minute: dateObj.getUTCMinutes()
                        };
                        return `${bkkComponents.day.toString().padStart(2, '0')}/${(bkkComponents.month + 1).toString().padStart(2, '0')}/${bkkComponents.year + 543} ${bkkComponents.hour.toString().padStart(2, '0')}:${bkkComponents.minute.toString().padStart(2, '0')}:00`;
                    };

                    billingPeriodInfoDiv.innerHTML = `
                        <h3>‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡∏ö‡∏¥‡∏•‡∏•‡∏¥‡πà‡∏á</h3>
                        <p>‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å (${selectedMonthYear}):</p>
                        <p>‡∏ï‡∏±‡πâ‡∏á‡πÅ‡∏ï‡πà: <strong>${formatDateTime(startDate)}</strong></p>
                        <p>‡∏ñ‡∏∂‡∏á: <strong>${formatDateTime(endDate)}</strong></p>
                    `;
                } else {
                    console.warn("[updateDisplay] Could not calculate billing period dates for display.");
                    billingPeriodInfoDiv.innerHTML = `
                        <h3>‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡∏ö‡∏¥‡∏•‡∏•‡∏¥‡πà‡∏á</h3>
                        <p>‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡∏ö‡∏¥‡∏•‡∏•‡∏¥‡πà‡∏á‡πÑ‡∏î‡πâ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å</p>
                    `;
                }
            } else {
                billingPeriodInfoDiv.innerHTML = `
                    <h3>‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡∏ö‡∏¥‡∏•‡∏•‡∏¥‡πà‡∏á</h3>
                    <p>‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏ó‡∏µ‡πà‡∏°‡∏µ‡πÉ‡∏ô‡πÑ‡∏ü‡∏•‡πå</p>
                    <p>‡∏Ñ‡πà‡∏≤‡πÉ‡∏ô‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏™‡∏£‡∏∏‡∏õ‡∏£‡∏≤‡∏¢‡πÄ‡∏î‡∏∑‡∏≠‡∏ô ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏ï‡∏≤‡∏°‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó AR "${selectedArType}"</p>
                `;
            }
            summaryBoxWrapper.appendChild(billingPeriodInfoDiv);


            outputDiv.appendChild(summaryBoxWrapper);


            outputDiv.innerHTML += renderResultsAsHtml(selectedUnit, selectedMonthYear, selectedArType);

            updateExportButtonVisibility();
        }

        function exportTableToExcel() {
            if (!isProcessed) {
                alert("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå Excel ‡∏Å‡πà‡∏≠‡∏ô‡∏ó‡∏≥‡∏Å‡∏≤‡∏£‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å");
                return;
            }

            const unitType = document.getElementById('unitSelector').value;
            const applyMultiplier = document.getElementById('applyMultiplier').checked;
            const currentMultiplierForDisplayOrExport = applyMultiplier ? multiplier : 1;

            let whUnit, varhUnit;
            let whCalculation, varhCalculation;
            let decimalPlaces;

            if (unitType === 'kw_kvar') {
                whUnit = 'kW';
                varhUnit = 'kVar';
                decimalPlaces = 3;

                whCalculation = (wh_val_raw) => {
                    const roundedWhTimesFour = Math.round(parseFloat(wh_val_raw) * 4);
                    return customRound((roundedWhTimesFour * currentMultiplierForDisplayOrExport / 1000), decimalPlaces);
                };
                varhCalculation = (varh_val_raw) => {
                    const roundedVarhTimesFour = Math.round(parseFloat(varh_val_raw) * 4);
                    return customRound((roundedVarhTimesFour * currentMultiplierForDisplayOrExport / 1000), decimalPlaces);
                };
            } else {
                whUnit = 'Wh';
                varhUnit = 'Varh';
                decimalPlaces = 5;

                whCalculation = (wh_val_raw) => {
                    return customRound((parseFloat(wh_val_raw) * currentMultiplierForDisplayOrExport), decimalPlaces);
                };

                varhCalculation = (varh_val_raw) => {
                    return customRound((parseFloat(varh_val_raw) * currentMultiplierForDisplayOrExport), decimalPlaces);
                };
            }

            const dataToExport = [];

            dataToExport.push(['‡∏ß‡∏±‡∏ô‡πÄ‡∏ß‡∏•‡∏≤', '‡πÄ‡∏£‡∏ó', whUnit, varhUnit]);

            let dataForExport = [];
            const selectedMonthYear = document.getElementById('monthYearSelector').value;
            const selectedArType = document.getElementById('arTypeSelector').value;

            if (selectedMonthYear === 'all') {
                dataForExport = [...globalResults];
            } else {
                const [yearStr, monthStr] = selectedMonthYear.split('-');
                const selectedMonthInt = parseInt(monthStr);
                const selectedYearInt = parseInt(yearStr);

                dataForExport = globalResults.filter(r => {
                    return isInBillingPeriod(r.dateObject, selectedArType, selectedMonthInt, selectedYearInt);
                });
            }

            if (sortState.columnIndex !== null) {
                const directionModifier = sortState.direction === 'asc' ? 1 : -1;
                const selectedUnitForSort = document.getElementById('unitSelector').value;
                const applyMultiplierForSort = document.getElementById('applyMultiplier').checked;
                const currentMultiplierForSort = applyMultiplierForSort ? multiplier : 1;

                let whUnitConverterForSort, varhUnitConverterForSort;
                if (selectedUnitForSort === 'kw_kvar') {
                    whUnitConverterForSort = (wh_val) => (Math.round(parseFloat(wh_val) * 4) / 1000) * currentMultiplierForSort;
                    varhUnitConverterForSort = (varh_val) => (Math.round(parseFloat(varh_val) * 4) / 1000) * currentMultiplierForSort;
                } else {
                    whUnitConverterForSort = (wh_val) => (parseFloat(wh_val) * currentMultiplierForSort);
                    varhUnitConverterForSort = (varh_val) => (parseFloat(varh_val) * currentMultiplierForSort);
                }

                dataForExport.sort((a, b) => {
                    let valA, valB;
                    switch (sortState.columnIndex) {
                        case 0:
                            valA = a.dateObject.getTime();
                            valB = b.dateObject.getTime();
                            break;
                        case 1:
                            valA = getRate(a.dateObject);
                            valB = getRate(b.dateObject);
                            const rateOrder = {
                                'Holiday': 1,
                                'Off-peak': 2,
                                'Peak': 3
                            };
                            return (rateOrder[valA] - rateOrder[valB]) * directionModifier;
                        case 2:
                            valA = whUnitConverterForSort(a.originalWhValue);
                            valB = whUnitConverterForSort(b.originalWhValue);
                            break;
                        case 3:
                            valA = varhUnitConverterForSort(a.originalVarhValue);
                            valB = varhUnitConverterForSort(b.originalVarhValue);
                            break;
                        default:
                            return 0;
                    }

                    if (typeof valA === 'string') {
                        return valA.localeCompare(valB) * directionModifier;
                    } else {
                        return (valA - valB) * directionModifier;
                    }
                });
            }

            dataForExport.forEach(r => {
                if (!r || !r.dateObject) {
                    console.error("Skipping malformed data row during export:", r);
                    return;
                }

                const wh = r.originalWhValue || 0;
                const varh = r.originalVarhValue || 0;

                const currentWh = whCalculation(wh);
                const currentVarh = varhCalculation(varh);

                const rate = getRate(r.dateObject);

                dataToExport.push([
                    r.datetime,
                    rate,
                    currentWh.toFixed(decimalPlaces),
                    currentVarh.toFixed(decimalPlaces)
                ]);
            });

            const ws = XLSX.utils.aoa_to_sheet(dataToExport);
            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, "Electric Rates Filtered");

            const now = new Date();
            const day = String(now.getDate()).padStart(2, '0');
            const month = String(now.getMonth() + 1).padStart(2, '0');
            const year = now.getFullYear();
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            const seconds = String(now.getSeconds()).padStart(2, '0');

            const formattedDateTime = `${day}/${month}/${year}_${hours}${minutes}${seconds}`;
            const filename = `${meterNumber || 'N_A'}_${formattedDateTime}.xlsx`;

            XLSX.writeFile(wb, filename);
        }

        document.getElementById('exportExcel').addEventListener('click', exportTableToExcel);

        function updateExportButtonVisibility() {
            const exportButton = document.getElementById('exportExcel');
            if (isProcessed && globalResults.length > 0) {
                exportButton.style.display = 'block';
            } else {
                exportButton.style.display = 'none';
            }
        }
        document.addEventListener('DOMContentLoaded', updateExportButtonVisibility);
    </script>
</body>

</html>